# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013–2020, PyPA
# This file is distributed under the same license as the Python Packaging User Guide package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python Packaging User Guide \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-29 06:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/contribute.rst:5
msgid "Contribute to this guide"
msgstr ""

#: ../source/contribute.rst:7
msgid "The |PyPUG| welcomes contributors! There are lots of ways to help out, including:"
msgstr ""

#: ../source/contribute.rst:10
msgid "Reading the guide and giving feedback"
msgstr ""

#: ../source/contribute.rst:11
msgid "Reviewing new contributions"
msgstr ""

#: ../source/contribute.rst:12
msgid "Revising existing content"
msgstr ""

#: ../source/contribute.rst:13
msgid "Writing new content"
msgstr ""

#: ../source/contribute.rst:14
msgid "Translate the guide"
msgstr ""

#: ../source/contribute.rst:16
msgid "Most of the work on the |PyPUG| takes place on the `project's GitHub repository`__. To get started, check out the list of `open issues`__ and `pull requests`__. If you're planning to write or edit the guide, please read the :ref:`style guide <contributing_style_guide>`."
msgstr ""

#: ../source/contribute.rst:25
msgid "By contributing to the |PyPUG|, you're expected to follow the PSF's `Code of Conduct`__."
msgstr ""

#: ../source/contribute.rst:32
msgid "Documentation types"
msgstr ""

#: ../source/contribute.rst:34
msgid "This project consists of four distinct documentation types with specific purposes. The project aspires to follow the `Diátaxis process`_ for creating quality documentation. When proposing new additions to the project please pick the appropriate documentation type."
msgstr ""

#: ../source/contribute.rst:42
#: ../source/index.rst:55
#: ../source/tutorials/index.rst:2
msgid "Tutorials"
msgstr ""

#: ../source/contribute.rst:44
msgid "Tutorials are focused on teaching the reader new concepts by accomplishing a goal. They are opinionated step-by-step guides. They do not include extraneous warnings or information. `example tutorial-style document`_."
msgstr ""

#: ../source/contribute.rst:51
#: ../source/guides/index.rst:2
#: ../source/index.rst:69
msgid "Guides"
msgstr ""

#: ../source/contribute.rst:53
msgid "Guides are focused on accomplishing a specific task and can assume some level of pre-requisite knowledge. These are similar to tutorials, but have a narrow and clear focus and can provide lots of caveats and additional information as needed. They may also discuss multiple approaches to accomplishing the task. :doc:`example guide-style document <guides/packaging-namespace-packages>`."
msgstr ""

#: ../source/contribute.rst:60
#: ../source/discussions/index.rst:2
msgid "Discussions"
msgstr ""

#: ../source/contribute.rst:62
msgid "Discussions are focused on understanding and information. These explore a specific topic without a specific goal in mind. :doc:`example discussion-style document <discussions/install-requires-vs-requirements>`."
msgstr ""

#: ../source/contribute.rst:67
msgid "Specifications"
msgstr ""

#: ../source/contribute.rst:69
msgid "Specifications are reference documentation focused on comprehensively documenting an agreed-upon interface for interoperability between packaging tools. :doc:`example specification-style document <specifications/core-metadata>`."
msgstr ""

#: ../source/contribute.rst:75
msgid "Translations"
msgstr ""

#: ../source/contribute.rst:77
msgid "We use `Weblate`_ to manage translations of this project. Please visit the `packaging.python.org`_ project on Weblate to contribute."
msgstr ""

#: ../source/contribute.rst:80
msgid "If you are experiencing issues while you are working on translations, please open an issue on `GitHub`_."
msgstr ""

#: ../source/contribute.rst:85
msgid "Any translations of this project should follow `reStructuredText syntax`_."
msgstr ""

#: ../source/contribute.rst:93
msgid "Adding a language"
msgstr ""

#: ../source/contribute.rst:95
msgid "If your language is not listed on `packaging.python.org`_, click the button :guilabel:`Start new translation` at the bottom of the language list and add the language you want to translate."
msgstr ""

#: ../source/contribute.rst:100
msgid "Following reStructuredText syntax"
msgstr ""

#: ../source/contribute.rst:102
msgid "If you are not familiar with reStructuredText (RST) syntax, please read `this guide`_ before translating on Weblate."
msgstr ""

#: ../source/contribute.rst:105
msgid "**Do not translate the text in reference directly**"
msgstr ""

#: ../source/contribute.rst:107
msgid "When translating the text in reference, please do not translate them directly."
msgstr ""

#: ../source/contribute.rst:0
msgid "Wrong: Translate the following text directly:"
msgstr ""

#: ../source/contribute.rst:0
msgid "Right: Translate the following text with your own language and add the original reference:"
msgstr ""

#: ../source/contribute.rst:124
msgid "Building the guide locally"
msgstr ""

#: ../source/contribute.rst:126
msgid "Though not required to contribute, it may be useful to build this guide locally in order to test your changes. In order to build this guide locally, you'll need:"
msgstr ""

#: ../source/contribute.rst:130
msgid ":doc:`Nox <nox:index>`. You can install or upgrade nox using ``pip``:"
msgstr ""

#: ../source/contribute.rst:137
msgid "Python 3.11. Our build scripts are usually tested with Python 3.11 only. See the :doc:`Hitchhiker's Guide to Python installation instructions <python-guide:starting/installation>` to install Python 3.11 on your operating system."
msgstr ""

#: ../source/contribute.rst:141
msgid "To build the guide, run the following shell command in the project's root folder:"
msgstr ""

#: ../source/contribute.rst:147
msgid "After the process has completed you can find the HTML output in the ``./build/html`` directory. You can open the ``index.html`` file to view the guide in web browser, but it's recommended to serve the guide using an HTTP server."
msgstr ""

#: ../source/contribute.rst:152
msgid "You can build the guide and serve it via an HTTP server using the following command:"
msgstr ""

#: ../source/contribute.rst:159
msgid "The guide will be browsable via http://localhost:8000."
msgstr ""

#: ../source/contribute.rst:163
msgid "Where the guide is deployed"
msgstr ""

#: ../source/contribute.rst:165
msgid "The guide is deployed via ReadTheDocs and the configuration lives at https://readthedocs.org/projects/python-packaging-user-guide/. It's served from a custom domain and fronted by Fast.ly."
msgstr ""

#: ../source/contribute.rst:171
msgid "Style guide"
msgstr ""

#: ../source/contribute.rst:173
msgid "This style guide has recommendations for how you should write the |PyPUG|. Before you start writing, please review it. By following the style guide, your contributions will help add to a cohesive whole and make it easier for your contributions to be accepted into the project."
msgstr ""

#: ../source/contribute.rst:180
msgid "Purpose"
msgstr ""

#: ../source/contribute.rst:182
msgid "The purpose of the |PyPUG| is to be the authoritative resource on how to package, publish, and install Python projects using current tools."
msgstr ""

#: ../source/contribute.rst:187
msgid "Scope"
msgstr ""

#: ../source/contribute.rst:189
msgid "The guide is meant to answer questions and solve problems with accurate and focused recommendations."
msgstr ""

#: ../source/contribute.rst:192
msgid "The guide isn't meant to be comprehensive and it's not meant to replace individual projects' documentation. For example, pip has dozens of commands, options, and settings. The pip documentation describes each of them in detail, while this guide describes only the parts of pip that are needed to complete the specific tasks described in this guide."
msgstr ""

#: ../source/contribute.rst:200
msgid "Audience"
msgstr ""

#: ../source/contribute.rst:202
msgid "The audience of this guide is anyone who uses Python with packages."
msgstr ""

#: ../source/contribute.rst:204
msgid "Don't forget that the Python community is big and welcoming. Readers may not share your age, gender, education, culture, and more, but they deserve to learn about packaging just as much as you do."
msgstr ""

#: ../source/contribute.rst:208
msgid "In particular, keep in mind that not all people who use Python see themselves as programmers. The audience of this guide includes astronomers or painters or students as well as professional software developers."
msgstr ""

#: ../source/contribute.rst:214
msgid "Voice and tone"
msgstr ""

#: ../source/contribute.rst:216
msgid "When writing this guide, strive to write with a voice that's approachable and humble, even if you have all the answers."
msgstr ""

#: ../source/contribute.rst:219
msgid "Imagine you're working on a Python project with someone you know to be smart and skilled. You like working with them and they like working with you. That person has asked you a question and you know the answer. How do you respond? *That* is how you should write this guide."
msgstr ""

#: ../source/contribute.rst:224
msgid "Here's a quick check: try reading aloud to get a sense for your writing's voice and tone. Does it sound like something you would say or does it sound like you're acting out a part or giving a speech? Feel free to use contractions and don't worry about sticking to fussy grammar rules. You are hereby granted permission to end a sentence in a preposition, if that's what you want to end it with."
msgstr ""

#: ../source/contribute.rst:231
msgid "When writing the guide, adjust your tone for the seriousness and difficulty of the topic. If you're writing an introductory tutorial, it's OK to make a joke, but if you're covering a sensitive security recommendation, you might want to avoid jokes altogether."
msgstr ""

#: ../source/contribute.rst:238
msgid "Conventions and mechanics"
msgstr ""

#: ../source/contribute.rst:246
msgid "**Write to the reader**"
msgstr ""

#: ../source/contribute.rst:241
msgid "When giving recommendations or steps to take, address the reader as *you* or use the imperative mood."
msgstr ""

#: ../source/contribute.rst:0
msgid "Wrong: To install it, the user runs…"
msgstr ""

#: ../source/contribute.rst:0
msgid "Right: You can install it by running…"
msgstr ""

#: ../source/contribute.rst:0
msgid "Right: To install it, run…"
msgstr ""

#: ../source/contribute.rst:252
msgid "**State assumptions**"
msgstr ""

#: ../source/contribute.rst:249
msgid "Avoid making unstated assumptions. Reading on the web means that any page of the guide may be the first page of the guide that the reader ever sees. If you're going to make assumptions, then say what assumptions that you're going to make."
msgstr ""

#: ../source/contribute.rst:257
msgid "**Cross-reference generously**"
msgstr ""

#: ../source/contribute.rst:255
msgid "The first time you mention a tool or practice, link to the part of the guide that covers it, or link to a relevant document elsewhere. Save the reader a search."
msgstr ""

#: ../source/contribute.rst:267
msgid "**Respect naming practices**"
msgstr ""

#: ../source/contribute.rst:260
msgid "When naming tools, sites, people, and other proper nouns, use their preferred capitalization."
msgstr ""

#: ../source/contribute.rst:0
msgid "Wrong: Pip uses…"
msgstr ""

#: ../source/contribute.rst:0
msgid "Right: pip uses…"
msgstr ""

#: ../source/contribute.rst:0
msgid "Wrong: …hosted on github."
msgstr ""

#: ../source/contribute.rst:0
msgid "Right: …hosted on GitHub."
msgstr ""

#: ../source/contribute.rst:276
msgid "**Use a gender-neutral style**"
msgstr ""

#: ../source/contribute.rst:270
msgid "Often, you'll address the reader directly with *you*, *your* and *yours*. Otherwise, use gender-neutral pronouns *they*, *their*, and *theirs* or avoid pronouns entirely."
msgstr ""

#: ../source/contribute.rst:0
msgid "Wrong: A maintainer uploads the file. Then he…"
msgstr ""

#: ../source/contribute.rst:0
msgid "Right: A maintainer uploads the file. Then they…"
msgstr ""

#: ../source/contribute.rst:0
msgid "Right: A maintainer uploads the file. Then the maintainer…"
msgstr ""

#: ../source/contribute.rst:288
msgid "**Headings**"
msgstr ""

#: ../source/contribute.rst:279
msgid "Write headings that use words the reader is searching for. A good way to do this is to have your heading complete an implied question. For example, a reader might want to know *How do I install MyLibrary?* so a good heading might be *Install MyLibrary*."
msgstr ""

#: ../source/contribute.rst:284
msgid "In section headings, use sentence case. In other words, write headings as you would write a typical sentence."
msgstr ""

#: ../source/contribute.rst:0
msgid "Wrong: Things You Should Know About Python"
msgstr ""

#: ../source/contribute.rst:0
msgid "Right: Things you should know about Python"
msgstr ""

#: ../source/contribute.rst:291
msgid "**Numbers**"
msgstr ""

#: ../source/contribute.rst:291
msgid "In body text, write numbers one through nine as words. For other numbers or numbers in tables, use numerals."
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:4
msgid "Deploying Python applications"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:0
#: ../source/guides/index-mirrors-and-caches.rst:0
#: ../source/guides/installing-using-linux-tools.rst:0
#: ../source/guides/migrating-to-pypi-org.rst:0
#: ../source/guides/multi-version-installs.rst:0
#: ../source/guides/packaging-binary-extensions.rst:0
#: ../source/guides/supporting-multiple-python-versions.rst:0
#: ../source/guides/supporting-windows-using-appveyor.rst:0
msgid "Page Status"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:6
#: ../source/guides/index-mirrors-and-caches.rst:7
#: ../source/guides/installing-using-linux-tools.rst:7
#: ../source/guides/packaging-binary-extensions.rst:7
msgid "Incomplete"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:0
#: ../source/guides/index-mirrors-and-caches.rst:0
#: ../source/guides/installing-using-linux-tools.rst:0
#: ../source/guides/packaging-binary-extensions.rst:0
#: ../source/guides/supporting-multiple-python-versions.rst:0
#: ../source/guides/supporting-windows-using-appveyor.rst:0
msgid "Last Reviewed"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:7
msgid "2021-8-24"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:11
#: ../source/specifications/externally-managed-environments.rst:130
#: ../source/specifications/platform-compatibility-tags.rst:21
msgid "Overview"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:15
msgid "Supporting multiple hardware platforms"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:37
msgid "OS packaging & installers"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:49
#: ../source/discussions/deploying-python-applications.rst:86
msgid "Windows"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:58
msgid "Pynsist"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:60
msgid "`Pynsist <https://pypi.org/project/pynsist>`__ is a tool that bundles Python programs together with the Python-interpreter into a single installer based on NSIS. In most cases, packaging only requires the user to choose a version of the Python-interpreter and declare the dependencies of the program. The tool downloads the specified Python-interpreter for Windows and packages it with all the dependencies in a single Windows-executable installer."
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:67
msgid "The installed program can be started from a shortcut that the installer adds to the start-menu. It uses a Python interpreter installed within its application directory, independent of any other Python installation on the computer."
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:71
msgid "A big advantage of Pynsist is that the Windows packages can be built on Linux. There are several examples for different kinds of programs (console, GUI) in the :any:`documentation <pynsist:index>`. The tool is released under the MIT-licence."
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:77
msgid "Application bundles"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:89
msgid "py2exe"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:91
msgid "`py2exe <https://pypi.org/project/py2exe/>`__ is a distutils extension which allows to build standalone Windows executable programs (32-bit and 64-bit) from Python scripts. Python versions included in the official development cycle are supported (refers to `Status of Python branches`__). py2exe can build console executables and windows (GUI) executables. Building windows services, and DLL/EXE COM servers might work but it is not actively supported. The distutils extension is released under the MIT-licence and Mozilla Public License 2.0."
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:103
msgid "macOS"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:106
msgid "py2app"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:108
msgid "`py2app <https://pypi.org/project/py2app/>`__ is a Python setuptools command which will allow you to make standalone macOS application bundles and plugins from Python scripts. Note that py2app MUST be used on macOS to build applications, it cannot create Mac applications on other platforms. py2app is released under the MIT-license."
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:115
msgid "Unix (including Linux and macOS)"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:118
#: ../source/key_projects.rst:532
msgid "pex"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:120
msgid "`pex <https://pypi.org/project/pex/>`__ is  a library for generating .pex (Python EXecutable) files which are executable Python environments in the spirit of virtualenvs. pex is an expansion upon the ideas outlined in :pep:`441` and makes the deployment of Python applications as simple as cp. pex files may even include multiple platform-specific Python distributions, meaning that a single pex file can be portable across Linux and macOS. pex is released under the Apache License 2.0."
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:129
msgid "Configuration management"
msgstr ""

#: ../source/discussions/index.rst:4
msgid "**Discussions** are focused on providing comprehensive information about a specific topic. If you're just trying to get stuff done, see :doc:`/guides/index`."
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:5
msgid "install_requires vs requirements files"
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:9
msgid "install_requires"
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:11
msgid "``install_requires`` is a :ref:`setuptools` :file:`setup.py` keyword that should be used to specify what a project **minimally** needs to run correctly. When the project is installed by :ref:`pip`, this is the specification that is used to install its dependencies."
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:16
msgid "For example, if the project requires A and B, your ``install_requires`` would be like so:"
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:26
msgid "Additionally, it's best practice to indicate any known lower or upper bounds."
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:28
msgid "For example, it may be known, that your project requires at least v1 of 'A', and v2 of 'B', so it would be like so:"
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:38
msgid "It may also be known that project 'A' introduced a change in its v2 that breaks the compatibility of your project with v2 of 'A' and later, so it makes sense to not allow v2:"
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:49
msgid "It is not considered best practice to use ``install_requires`` to pin dependencies to specific versions, or to specify sub-dependencies (i.e. dependencies of your dependencies).  This is overly-restrictive, and prevents the user from gaining the benefit of dependency upgrades."
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:54
msgid "Lastly, it's important to understand that ``install_requires`` is a listing of \"Abstract\" requirements, i.e just names and version restrictions that don't determine where the dependencies will be fulfilled from (i.e. from what index or source).  The where (i.e. how they are to be made \"Concrete\") is to be determined at install time using :ref:`pip` options. [1]_"
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:62
#: ../source/tutorials/installing-packages.rst:464
msgid "Requirements files"
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:64
msgid ":ref:`Requirements Files <pip:Requirements Files>` described most simply, are just a list of :ref:`pip:pip install` arguments placed into a file."
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:67
msgid "Whereas ``install_requires`` defines the dependencies for a single project, :ref:`Requirements Files <pip:Requirements Files>` are often used to define the requirements for a complete Python environment."
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:71
msgid "Whereas ``install_requires`` requirements are minimal, requirements files often contain an exhaustive listing of pinned versions for the purpose of achieving :ref:`repeatable installations <pip:Repeatability>` of a complete environment."
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:76
msgid "Whereas ``install_requires`` requirements are \"Abstract\", i.e. not associated with any particular index, requirements files often contain pip options like ``--index-url`` or ``--find-links`` to make requirements \"Concrete\", i.e. associated with a particular index or directory of packages. [1]_"
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:82
msgid "Whereas ``install_requires`` metadata is automatically analyzed by pip during an install, requirements files are not, and only are used when a user specifically installs them using ``python -m pip install -r``."
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:88
msgid "For more on \"Abstract\" vs \"Concrete\" requirements, see https://caremad.io/posts/2013/07/setup-vs-requirement/."
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:6
msgid "pip vs easy_install"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:9
msgid ":ref:`easy_install <easy_install>`, now `deprecated`_, was released in 2004 as part of :ref:`setuptools`. It was notable at the time for installing :term:`packages <Distribution Package>` from :term:`PyPI <Python Package Index (PyPI)>` using requirement specifiers, and automatically installing dependencies."
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:14
msgid ":ref:`pip` came later in 2008, as alternative to :ref:`easy_install <easy_install>`, although still largely built on top of :ref:`setuptools` components.  It was notable at the time for *not* installing packages as :term:`Eggs <Egg>` or from :term:`Eggs <Egg>` (but rather simply as 'flat' packages from :term:`sdists <Source Distribution (or \"sdist\")>`), and introducing the idea of :ref:`Requirements Files <pip:Requirements Files>`, which gave users the power to easily replicate environments."
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:22
msgid "Here's a breakdown of the important differences between pip and the deprecated easy_install:"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:25
msgid "**pip**"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:25
msgid "**easy_install**"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:27
msgid "Installs from :term:`Wheels <Wheel>`"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:27
#: ../source/discussions/pip-vs-easy-install.rst:38
#: ../source/discussions/pip-vs-easy-install.rst:44
#: ../source/discussions/pip-vs-easy-install.rst:48
#: ../source/discussions/pip-vs-easy-install.rst:54
#: ../source/discussions/pip-vs-easy-install.rst:57
msgid "Yes"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:27
#: ../source/discussions/pip-vs-easy-install.rst:30
#: ../source/discussions/pip-vs-easy-install.rst:32
#: ../source/discussions/pip-vs-easy-install.rst:35
#: ../source/discussions/pip-vs-easy-install.rst:38
#: ../source/discussions/pip-vs-easy-install.rst:44
#: ../source/discussions/pip-vs-easy-install.rst:48
#: ../source/discussions/pip-vs-easy-install.rst:51
#: ../source/discussions/pip-vs-easy-install.rst:54
#: ../source/discussions/pip-vs-easy-install.rst:57
msgid "No"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:30
msgid "Uninstall Packages"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:30
msgid "Yes (``python -m pip uninstall``)"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:32
msgid "Dependency Overrides"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:32
msgid "Yes (:ref:`Requirements Files <pip:Requirements Files>`)"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:35
msgid "List Installed Packages"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:35
msgid "Yes (``python -m pip list`` and ``python -m pip freeze``)"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:38
msgid ":pep:`438` Support"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:41
msgid "Installation format"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:41
msgid "'Flat' packages with :file:`egg-info` metadata."
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:41
msgid "Encapsulated Egg format"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:44
msgid "sys.path modification"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:48
msgid "Installs from :term:`Eggs <Egg>`"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:51
msgid "`pylauncher support`_"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:51
msgid "Yes [1]_"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:54
msgid ":ref:`Multi-version Installs`"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:57
msgid "Exclude scripts during install"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:60
msgid "per project index"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:60
msgid "Only in virtualenv"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:60
msgid "Yes, via setup.cfg"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:68
msgid "https://setuptools.readthedocs.io/en/latest/deprecated/easy_install.html#natural-script-launcher"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:6
msgid "Is ``setup.py`` deprecated?"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:8
msgid "No, :term:`setup.py` is not deprecated, it is a valid configuration file for :ref:`setuptools` that happens to be written in Python, instead of in *TOML* for example (a similar practice is used by other tools like *nox* and its :file:`nox.py` configuration file, or *pytest* and :file:`conftest.py`)."
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:15
msgid "And of course *setuptools* itself is not deprecated either."
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:17
msgid "It is however deprecated to run ``python setup.py`` as a command line tool."
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:19
msgid "This means for example that the following commands **MUST NOT** be run anymore:"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:21
#: ../source/discussions/setup-py-deprecated.rst:33
#: ../source/guides/modernize-setup-py-project.rst:32
msgid "``python setup.py install``"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:22
#: ../source/discussions/setup-py-deprecated.rst:35
#: ../source/guides/modernize-setup-py-project.rst:34
msgid "``python setup.py develop``"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:23
#: ../source/discussions/setup-py-deprecated.rst:37
#: ../source/guides/modernize-setup-py-project.rst:36
msgid "``python setup.py sdist``"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:24
#: ../source/discussions/setup-py-deprecated.rst:39
#: ../source/guides/modernize-setup-py-project.rst:38
msgid "``python setup.py bdist_wheel``"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:28
msgid "What commands should be used instead?"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:31
#: ../source/guides/modernize-setup-py-project.rst:30
msgid "Deprecated"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:31
msgid "Current recommendation"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:33
#: ../source/guides/modernize-setup-py-project.rst:32
msgid "``python -m pip install .``"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:35
#: ../source/guides/modernize-setup-py-project.rst:34
msgid "``python -m pip install --editable .``"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:37
msgid "``python -m build`` [#needs-build]_"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:43
msgid "This requires the :ref:`build` dependency. It is recommended to always build and publish both the source distribution and wheel of a project, which is what ``python -m build`` does. If necessary the ``--sdist`` and ``--wheel`` options can be used to generate only one or the other."
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:50
msgid "In order to install a setuptools based project, it was common to run :file:`setup.py`'s ``install`` command such as: ``python setup.py install``. Nowadays, the recommended method is to use :ref:`pip` directly with a command like this one: ``python -m pip install .``. Where the dot ``.`` is actually a file system path, it is the path notation for the current directory. Indeed, *pip* accepts a path to a project's source tree directory on the local filesystem as argument to its ``install`` sub-command. So this would also be a valid command: ``python -m pip install path/to/project``."
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:63
msgid "As for the installation in *develop* mode aka *editable* mode, instead of ``python setup.py develop`` one can use the ``--editable`` option of pip's *install* sub-command: ``python -m pip install --editable .``."
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:68
msgid "One recommended, simple, and straightforward method of building :term:`source distributions <Source Distribution (or \"sdist\")>` and :term:`wheels <Wheel>` is to use the :ref:`build` tool with a command like ``python -m build`` which triggers the generation of both distribution formats. If necessary the ``--sdist`` and ``--wheel`` options can be used to generate only one or the other. Note that the build tool needs to be installed separately."
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:78
msgid "The command ``python setup.py install`` was deprecated in setuptools version *58.3.0*."
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:83
msgid "What about custom commands?"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:85
msgid "Likewise, custom :file:`setup.py` commands are deprecated. The recommendation is to migrate those custom commands to a task runner tool or any other similar tool. Some examples of such tools are: chuy, make, nox or tox, pydoit, pyinvoke, taskipy, and thx."
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:93
msgid "What about custom build steps?"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:95
msgid "Custom build steps that for example either overwrite existing steps such as ``build_py``, ``build_ext``, and ``bdist_wheel`` or add new build steps are not deprecated. Those will be automatically called as expected."
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:102
#: ../source/guides/modernize-setup-py-project.rst:21
msgid "Should ``setup.py`` be deleted?"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:104
msgid "Although the usage of :file:`setup.py` as an executable script is deprecated, its usage as a configuration file for setuptools is absolutely fine. There is likely no modification needed in :file:`setup.py`."
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:110
msgid "Is ``pyproject.toml`` mandatory?"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:112
msgid "While it is not technically necessary yet, it is **STRONGLY RECOMMENDED** for a project to have a :file:`pyproject.toml` file at the root of its source tree with a content like this:"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:123
msgid "The guide :ref:`modernize-setup-py-project` has more details about this."
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:125
msgid "The standard fallback behavior for a :term:`build frontend <Build Frontend>` in the absence of a :file:`pyproject.toml` file and its ``[build-system]`` table is to assume that the :term:`build backend <Build Backend>` is setuptools."
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:131
msgid "Why? What does it all mean?"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:133
msgid "One way to look at it is that the scope of setuptools has now been reduced to the role of a build backend."
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:138
#: ../source/guides/modernize-setup-py-project.rst:244
msgid "Where to read more about this?"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:140
msgid "https://blog.ganssle.io/articles/2021/10/setup-py-deprecated.html"
msgstr ""

#: ../source/discussions/setup-py-deprecated.rst:142
msgid ":doc:`setuptools:deprecated/commands`"
msgstr ""

#: ../source/discussions/src-layout-vs-flat-layout.rst:5
msgid "src layout vs flat layout"
msgstr ""

#: ../source/discussions/src-layout-vs-flat-layout.rst:7
msgid "The \"flat layout\" refers to organising a project's files in a folder or repository, such that the various configuration files and :term:`import packages <Import Package>` are all in the top-level directory."
msgstr ""

#: ../source/discussions/src-layout-vs-flat-layout.rst:25
msgid "The \"src layout\" deviates from the flat layout by moving the code that is intended to be importable (i.e. ``import awesome_package``, also known as :term:`import packages <Import Package>`) into a subdirectory. This subdirectory is typically named ``src/``, hence \"src layout\"."
msgstr ""

#: ../source/discussions/src-layout-vs-flat-layout.rst:45
msgid "Here's a breakdown of the important behaviour differences between the src layout and the flat layout:"
msgstr ""

#: ../source/discussions/src-layout-vs-flat-layout.rst:48
msgid "The src layout requires installation of the project to be able to run its code, and the flat layout does not."
msgstr ""

#: ../source/discussions/src-layout-vs-flat-layout.rst:51
msgid "This means that the src layout involves an additional step in the development workflow of a project (typically, an :doc:`editable installation <setuptools:userguide/development_mode>` is used for development and a regular installation is used for testing)."
msgstr ""

#: ../source/discussions/src-layout-vs-flat-layout.rst:56
msgid "The src layout helps prevent accidental usage of the in-development copy of the code."
msgstr ""

#: ../source/discussions/src-layout-vs-flat-layout.rst:59
msgid "This is relevant since the Python interpreter includes the current working directory as the first item on the import path. This means that if an import package exists in the current working directory with the same name as an installed import package, the variant from the current working directory will be used. This can lead to subtle  misconfiguration of the project's packaging tooling, which could result in files not being included in a distribution."
msgstr ""

#: ../source/discussions/src-layout-vs-flat-layout.rst:66
msgid "The src layout helps avoid this by keeping import packages in a directory separate from the root directory of the project, ensuring that the installed copy is used."
msgstr ""

#: ../source/discussions/src-layout-vs-flat-layout.rst:70
msgid "The src layout helps enforce that an :doc:`editable installation <setuptools:userguide/development_mode>` is only able to import files that were meant to be importable."
msgstr ""

#: ../source/discussions/src-layout-vs-flat-layout.rst:74
msgid "This is especially relevant when the editable installation is implemented using a `path configuration file <https://docs.python.org/3/library/site.html#index-2>`_ that adds the directory to the import path."
msgstr ""

#: ../source/discussions/src-layout-vs-flat-layout.rst:78
msgid "The flat layout would add the other project files (eg: ``README.md``, ``tox.ini``) and packaging/tooling configuration files (eg: ``setup.py``, ``noxfile.py``) on the import path. This would make certain imports work in editable installations but not regular installations."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:5
msgid "Wheel vs Egg"
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:7
msgid ":term:`Wheel` and :term:`Egg` are both packaging formats that aim to support the use case of needing an install artifact that doesn't require building or compilation, which can be costly in testing and production workflows."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:11
msgid "The :term:`Egg` format was introduced by :ref:`setuptools` in 2004, whereas the :term:`Wheel` format was introduced by :pep:`427` in 2012."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:14
msgid ":term:`Wheel` is currently considered the standard for :term:`built <Built Distribution>` and :term:`binary <Binary Distribution>` packaging for Python."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:17
msgid "Here's a breakdown of the important differences between :term:`Wheel` and :term:`Egg`."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:20
msgid ":term:`Wheel` has an :doc:`official standard specification </specifications/binary-distribution-format>`. :term:`Egg` did not."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:24
msgid ":term:`Wheel` is a :term:`distribution <Distribution Package>` format, i.e a packaging format. [1]_ :term:`Egg` was both a distribution format and a runtime installation format (if left zipped), and was designed to be importable."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:28
msgid ":term:`Wheel` archives do not include .pyc files. Therefore, when the distribution only contains Python files (i.e. no compiled extensions), and is compatible with Python 2 and 3, it's possible for a wheel to be \"universal\", similar to an :term:`sdist <Source Distribution (or \"sdist\")>`."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:33
msgid ":term:`Wheel` uses :pep:`PEP376-compliant <376>` ``.dist-info`` directories. Egg used ``.egg-info``."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:36
msgid ":term:`Wheel` has a :pep:`richer file naming convention <425>`. A single wheel archive can indicate its compatibility with a number of Python language versions and implementations, ABIs, and system architectures."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:40
msgid ":term:`Wheel` is versioned. Every wheel file contains the version of the wheel specification and the implementation that packaged it."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:43
msgid ":term:`Wheel` is internally organized by `sysconfig path type <https://docs.python.org/2/library/sysconfig.html#installation-paths>`_, therefore making it easier to convert to other formats."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:47
msgid ":term:`Egg` uploads have been disabled for upload to PyPI, per :pep:`715`. Read the `deprecation notice <https://blog.pypi.org/posts/2023-06-26-deprecate-egg-uploads/>`_ for more information."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:53
msgid "Circumstantially, in some cases, wheels can be used as an importable runtime format, although :ref:`this is not officially supported at this time <binary-distribution-format-import-wheel>`."
msgstr ""

#: ../source/flow.rst:3
msgid "The Packaging Flow"
msgstr ""

#: ../source/flow.rst:5
msgid "The document aims to outline the flow involved in publishing/distributing a :term:`distribution package <Distribution Package>`, usually to the `Python Package Index (PyPI)`_. It is written for package publishers, who are assumed to be the package author."
msgstr ""

#: ../source/flow.rst:12
msgid "While the :doc:`tutorial <tutorials/packaging-projects>` walks through the process of preparing a simple package for release, it does not fully enumerate what steps and files are required, and for what purpose."
msgstr ""

#: ../source/flow.rst:16
msgid "Publishing a package requires a flow from the author's source code to an end user's Python environment. The steps to achieve this are:"
msgstr ""

#: ../source/flow.rst:19
msgid "Have a source tree containing the package. This is typically a checkout from a version control system (VCS)."
msgstr ""

#: ../source/flow.rst:22
msgid "Prepare a configuration file describing the package metadata (name, version and so forth) and how to create the build artifacts. For most packages, this will be a :file:`pyproject.toml` file, maintained manually in the source tree."
msgstr ""

#: ../source/flow.rst:27
msgid "Create build artifacts to be sent to the package distribution service (usually PyPI); these will normally be a :term:`source distribution (\"sdist\") <Source Distribution (or \"sdist\")>` and one or more :term:`built distributions (\"wheels\") <Built Distribution>`. These are made by a build tool using the configuration file from the previous step. Often there is just one generic wheel for a pure Python package."
msgstr ""

#: ../source/flow.rst:35
msgid "Upload the build artifacts to the package distribution service."
msgstr ""

#: ../source/flow.rst:37
msgid "At that point, the package is present on the package distribution service. To use the package, end users must:"
msgstr ""

#: ../source/flow.rst:40
msgid "Download one of the package's build artifacts from the package distribution service."
msgstr ""

#: ../source/flow.rst:43
msgid "Install it in their Python environment, usually in its ``site-packages`` directory. This step may involve a build/compile step which, if needed, must be described by the package metadata."
msgstr ""

#: ../source/flow.rst:47
msgid "These last 2 steps are typically performed by :ref:`pip` when an end user runs ``pip install``."
msgstr ""

#: ../source/flow.rst:50
msgid "The steps above are described in more detail below."
msgstr ""

#: ../source/flow.rst:53
msgid "The source tree"
msgstr ""

#: ../source/flow.rst:55
msgid "The source tree contains the package source code, usually a checkout from a VCS. The particular version of the code used to create the build artifacts will typically be a checkout based on a tag associated with the version."
msgstr ""

#: ../source/flow.rst:60
msgid "The configuration file"
msgstr ""

#: ../source/flow.rst:62
msgid "The configuration file depends on the tool used to create the build artifacts. The standard practice is to use a :file:`pyproject.toml` file in the `TOML format`_."
msgstr ""

#: ../source/flow.rst:68
msgid "At a minimum, the :file:`pyproject.toml` file needs a ``[build-system]`` table specifying your build tool. There are many build tools available, including but not limited to :ref:`flit`, :ref:`hatch`, :ref:`pdm`, :ref:`poetry`, :ref:`setuptools`, `trampolim`_, and `whey`_. Each tool's documentation will show what to put in the ``[build-system]`` table."
msgstr ""

#: ../source/flow.rst:77
msgid "For example, here is a table for using :ref:`hatch`:"
msgstr ""

#: ../source/flow.rst:85
msgid "With such a table in the :file:`pyproject.toml` file, a \":term:`frontend <Build Frontend>`\" tool like :ref:`build` can run your chosen build tool's \":term:`backend <Build Backend>`\" to create the build artifacts. Your build tool may also provide its own frontend. An install tool like :ref:`pip` also acts as a frontend when it runs your build tool's backend to install from a source distribution."
msgstr ""

#: ../source/flow.rst:94
msgid "The particular build tool you choose dictates what additional information is required in the :file:`pyproject.toml` file. For example, you might specify:"
msgstr ""

#: ../source/flow.rst:97
msgid "a ``[project]`` table containing project :doc:`Core Metadata </specifications/core-metadata/>` (name, version, author and so forth); see :doc:`Declaring project metadata </specifications/declaring-project-metadata/>` for more detail"
msgstr ""

#: ../source/flow.rst:103
msgid "a ``[tool]`` table containing tool-specific configuration options"
msgstr ""

#: ../source/flow.rst:106
msgid "Build artifacts"
msgstr ""

#: ../source/flow.rst:109
msgid "The source distribution (sdist)"
msgstr ""

#: ../source/flow.rst:111
msgid "A source distribution contains enough to install the package from source in an end user's Python environment. As such, it needs the package source, and may also include tests and documentation. These are useful for end users wanting to develop your sources, and for end user systems where some local compilation step is required (such as a C extension)."
msgstr ""

#: ../source/flow.rst:117
#: ../source/flow.rst:141
msgid "The :ref:`build` package knows how to invoke your build tool to create one of these:"
msgstr ""

#: ../source/flow.rst:124
msgid "Or, your build tool may provide its own interface for creating an sdist."
msgstr ""

#: ../source/flow.rst:128
msgid "The built distributions (wheels)"
msgstr ""

#: ../source/flow.rst:130
msgid "A built distribution contains only the files needed for an end user's Python environment. No compilation steps are required during the install, and the wheel file can simply be unpacked into the ``site-packages`` directory. This makes the install faster and more convenient for end users."
msgstr ""

#: ../source/flow.rst:135
msgid "A pure Python package typically needs only one \"generic\" wheel. A package with compiled binary extensions needs a wheel for each supported combination of Python interpreter, operating system, and CPU architecture that it supports. If a suitable wheel file is not available, tools like :ref:`pip` will fall back to installing the source distribution."
msgstr ""

#: ../source/flow.rst:148
msgid "Or, your build tool may provide its own interface for creating a wheel."
msgstr ""

#: ../source/flow.rst:152
msgid "The default behaviour of :ref:`build` is to make both an sdist and a wheel from the source in the current directory; the above examples are deliberately specific."
msgstr ""

#: ../source/flow.rst:157
msgid "Upload to the package distribution service"
msgstr ""

#: ../source/flow.rst:159
msgid "The :ref:`twine` tool can upload build artifacts to PyPI for distribution, using a command like:"
msgstr ""

#: ../source/flow.rst:166
msgid "Or, your build tool may provide its own interface for uploading."
msgstr ""

#: ../source/flow.rst:169
msgid "Download and install"
msgstr ""

#: ../source/flow.rst:171
msgid "Now that the package is published, end users can download and install the package into their Python environment. Typically this is done with :ref:`pip`, using a command like:"
msgstr ""

#: ../source/flow.rst:179
msgid "End users may also use other tools like :ref:`pipenv`, :ref:`poetry`, or :ref:`pdm`."
msgstr ""

#: ../source/glossary.rst:3
msgid "Glossary"
msgstr ""

#: ../source/glossary.rst:8
msgid "Binary Distribution"
msgstr ""

#: ../source/glossary.rst:11
msgid "A specific kind of :term:`Built Distribution` that contains compiled extensions."
msgstr ""

#: ../source/glossary.rst:14
msgid "Build Backend"
msgstr ""

#: ../source/glossary.rst:17
msgid "A library that takes a source tree or :term:`source distribution <Source Distribution (or \"sdist\")>` and builds a source distribution or :term:`wheel <Wheel>` from it. The build is delegated to the backend by a :term:`frontend <Build Frontend>`. All backends offer a standardized interface."
msgstr ""

#: ../source/glossary.rst:24
msgid "Examples of build backends are :ref:`flit's flit-core <flit>`, :ref:`hatch's hatchling <hatch>`, :ref:`maturin`, :ref:`meson-python`, :ref:`scikit-build-core`, and :ref:`setuptools`."
msgstr ""

#: ../source/glossary.rst:32
msgid "Build Frontend"
msgstr ""

#: ../source/glossary.rst:35
msgid "A tool that users might run that takes arbitrary source trees or :term:`source distributions <Source Distribution (or \"sdist\")>` and builds source distributions or :term:`wheels <Wheel>` from them. The actual building is delegated to each source tree's :term:`build backend <Build Backend>`."
msgstr ""

#: ../source/glossary.rst:42
msgid "Examples of build frontends are :ref:`pip` and :ref:`build`."
msgstr ""

#: ../source/glossary.rst:44
msgid "Built Distribution"
msgstr ""

#: ../source/glossary.rst:47
msgid "A :term:`Distribution <Distribution Package>` format containing files and metadata that only need to be moved to the correct location on the target system, to be installed. :term:`Wheel` is such a format, whereas distutil's :term:`Source Distribution <Source Distribution (or \"sdist\")>` is not, in that it requires a build step before it can be installed.  This format does not imply that Python files have to be precompiled (:term:`Wheel` intentionally does not include compiled Python files)."
msgstr ""

#: ../source/glossary.rst:56
msgid "Distribution Package"
msgstr ""

#: ../source/glossary.rst:59
msgid "A versioned archive file that contains Python :term:`packages <Import Package>`, :term:`modules <Module>`, and other resource files that are used to distribute a :term:`Release`. The archive file is what an end-user will download from the internet and install."
msgstr ""

#: ../source/glossary.rst:64
msgid "A distribution package is more commonly referred to with the single words \"package\" or \"distribution\", but this guide may use the expanded term when more clarity is needed to prevent confusion with an :term:`Import Package` (which is also commonly called a \"package\") or another kind of distribution (e.g. a Linux distribution or the Python language distribution), which are often referred to with the single term \"distribution\"."
msgstr ""

#: ../source/glossary.rst:71
msgid "Egg"
msgstr ""

#: ../source/glossary.rst:74
msgid "A :term:`Built Distribution` format introduced by :ref:`setuptools`, which is being replaced by :term:`Wheel`.  For details, see :doc:`The Internal Structure of Python Eggs <setuptools:deprecated/python_eggs>` and `Python Eggs <http://peak.telecommunity.com/DevCenter/PythonEggs>`_"
msgstr ""

#: ../source/glossary.rst:78
msgid "Extension Module"
msgstr ""

#: ../source/glossary.rst:81
msgid "A :term:`Module` written in the low-level language of the Python implementation: C/C++ for Python, Java for Jython. Typically contained in a single dynamically loadable pre-compiled file, e.g.  a shared object (.so) file for Python extensions on Unix, a DLL (given the .pyd extension) for Python extensions on Windows, or a Java class file for Jython extensions."
msgstr ""

#: ../source/glossary.rst:88
msgid "Known Good Set (KGS)"
msgstr ""

#: ../source/glossary.rst:91
msgid "A set of distributions at specified versions which are compatible with each other. Typically a test suite will be run which passes all tests before a specific set of packages is declared a known good set. This term is commonly used by frameworks and toolkits which are comprised of multiple individual distributions."
msgstr ""

#: ../source/glossary.rst:97
msgid "Import Package"
msgstr ""

#: ../source/glossary.rst:100
msgid "A Python module which can contain other modules or recursively, other packages."
msgstr ""

#: ../source/glossary.rst:103
msgid "An import package is more commonly referred to with the single word \"package\", but this guide will use the expanded term when more clarity is needed to prevent confusion with a :term:`Distribution Package` which is also commonly called a \"package\"."
msgstr ""

#: ../source/glossary.rst:107
msgid "Module"
msgstr ""

#: ../source/glossary.rst:110
msgid "The basic unit of code reusability in Python, existing in one of two types: :term:`Pure Module`, or :term:`Extension Module`."
msgstr ""

#: ../source/glossary.rst:113
msgid "Package Index"
msgstr ""

#: ../source/glossary.rst:116
msgid "A repository of distributions with a web interface to automate :term:`package <Distribution Package>` discovery and consumption."
msgstr ""

#: ../source/glossary.rst:119
msgid "Per Project Index"
msgstr ""

#: ../source/glossary.rst:122
msgid "A private or other non-canonical :term:`Package Index` indicated by a specific :term:`Project` as the index preferred or required to resolve dependencies of that project."
msgstr ""

#: ../source/glossary.rst:126
msgid "Project"
msgstr ""

#: ../source/glossary.rst:129
msgid "A library, framework, script, plugin, application, or collection of data or other resources, or some combination thereof that is intended to be packaged into a :term:`Distribution <Distribution Package>`."
msgstr ""

#: ../source/glossary.rst:133
msgid "Since most projects create :term:`Distributions <Distribution Package>` using either :pep:`518` ``build-system``, :ref:`distutils` or :ref:`setuptools`, another practical way to define projects currently is something that contains a :term:`pyproject.toml`, :term:`setup.py`, or :term:`setup.cfg` file at the root of the project source directory."
msgstr ""

#: ../source/glossary.rst:139
msgid "Python projects must have unique names, which are registered on :term:`PyPI <Python Package Index (PyPI)>`. Each project will then contain one or more :term:`Releases <Release>`, and each release may comprise one or more :term:`distributions <Distribution Package>`."
msgstr ""

#: ../source/glossary.rst:144
msgid "Note that there is a strong convention to name a project after the name of the package that is imported to run that project. However, this doesn't have to hold true. It's possible to install a distribution from the project 'foo' and have it provide a package importable only as 'bar'."
msgstr ""

#: ../source/glossary.rst:150
msgid "Pure Module"
msgstr ""

#: ../source/glossary.rst:153
msgid "A :term:`Module` written in Python and contained in a single ``.py`` file (and possibly associated ``.pyc`` and/or ``.pyo`` files)."
msgstr ""

#: ../source/glossary.rst:156
msgid "Python Packaging Authority (PyPA)"
msgstr ""

#: ../source/glossary.rst:159
msgid "PyPA is a working group that maintains many of the relevant projects in Python packaging. They maintain a site at :doc:`pypa.io <pypa:index>`, host projects on `GitHub <https://github.com/pypa>`_ and `Bitbucket <https://bitbucket.org/pypa>`_, and discuss issues on the `distutils-sig mailing list <https://mail.python.org/mailman3/lists/distutils-sig.python.org/>`_ and `the Python Discourse forum <https://discuss.python.org/c/packaging>`__."
msgstr ""

#: ../source/glossary.rst:168
msgid "Python Package Index (PyPI)"
msgstr ""

#: ../source/glossary.rst:171
msgid "`PyPI <https://pypi.org>`_ is the default :term:`Package Index` for the Python community. It is open to all Python developers to consume and distribute their distributions."
msgstr ""

#: ../source/glossary.rst:174
msgid "pypi.org"
msgstr ""

#: ../source/glossary.rst:177
msgid "`pypi.org <https://pypi.org>`_ is the domain name for the :term:`Python Package Index (PyPI)`. It replaced the legacy index domain name, ``pypi.python.org``, in 2017. It is powered by :ref:`warehouse`."
msgstr ""

#: ../source/glossary.rst:181
msgid "pyproject.toml"
msgstr ""

#: ../source/glossary.rst:184
msgid "The tool-agnostic :term:`Project` specification file. Defined in :pep:`518`."
msgstr ""

#: ../source/glossary.rst:186
msgid "Release"
msgstr ""

#: ../source/glossary.rst:189
msgid "A snapshot of a :term:`Project` at a particular point in time, denoted by a version identifier."
msgstr ""

#: ../source/glossary.rst:192
msgid "Making a release may entail the publishing of multiple :term:`Distributions <Distribution Package>`.  For example, if version 1.0 of a project was released, it could be available in both a source distribution format and a Windows installer distribution format."
msgstr ""

#: ../source/glossary.rst:197
msgid "Requirement"
msgstr ""

#: ../source/glossary.rst:200
msgid "A specification for a :term:`package <Distribution Package>` to be installed.  :ref:`pip`, the :term:`PYPA <Python Packaging Authority (PyPA)>` recommended installer, allows various forms of specification that can all be considered a \"requirement\". For more information, see the :ref:`pip:pip install` reference."
msgstr ""

#: ../source/glossary.rst:206
msgid "Requirement Specifier"
msgstr ""

#: ../source/glossary.rst:209
msgid "A format used by :ref:`pip` to install packages from a :term:`Package Index`. For an EBNF diagram of the format, see the `pkg_resources.Requirement <https://setuptools.readthedocs.io/en/latest/pkg_resources.html#requirement-objects>`_ entry in the :ref:`setuptools` docs. For example, \"foo>=1.3\" is a requirement specifier, where \"foo\" is the project name, and the \">=1.3\" portion is the :term:`Version Specifier`"
msgstr ""

#: ../source/glossary.rst:216
msgid "Requirements File"
msgstr ""

#: ../source/glossary.rst:219
msgid "A file containing a list of :term:`Requirements <Requirement>` that can be installed using :ref:`pip`. For more information, see the :ref:`pip` docs on :ref:`pip:Requirements Files`."
msgstr ""

#: ../source/glossary.rst:223
#: ../source/guides/distributing-packages-using-setuptools.rst:56
msgid "setup.py"
msgstr ""

#: ../source/glossary.rst:224
#: ../source/guides/distributing-packages-using-setuptools.rst:77
msgid "setup.cfg"
msgstr ""

#: ../source/glossary.rst:227
msgid "The project specification files for :ref:`distutils` and :ref:`setuptools`. See also :term:`pyproject.toml`."
msgstr ""

#: ../source/glossary.rst:230
msgid "Source Archive"
msgstr ""

#: ../source/glossary.rst:233
msgid "An archive containing the raw source code for a :term:`Release`, prior to creation of a :term:`Source Distribution <Source Distribution (or \"sdist\")>` or :term:`Built Distribution`."
msgstr ""

#: ../source/glossary.rst:237
msgid "Source Distribution (or \"sdist\")"
msgstr ""

#: ../source/glossary.rst:240
msgid "A :term:`distribution <Distribution Package>` format (usually generated using ``python -m build --sdist``) that provides metadata and the essential source files needed for installing by a tool like :ref:`pip`, or for generating a :term:`Built Distribution`."
msgstr ""

#: ../source/glossary.rst:245
msgid "System Package"
msgstr ""

#: ../source/glossary.rst:248
msgid "A package provided in a format native to the operating system, e.g. an rpm or dpkg file."
msgstr ""

#: ../source/glossary.rst:251
msgid "Version Specifier"
msgstr ""

#: ../source/glossary.rst:254
msgid "The version component of a :term:`Requirement Specifier`. For example, the \">=1.3\" portion of \"foo>=1.3\".  Read the :ref:`Version specifier specification <version-specifiers>` for a full description of the specifiers that Python packaging currently supports.  Support for this specification was implemented in :ref:`setuptools` v8.0 and :ref:`pip` v6.0."
msgstr ""

#: ../source/glossary.rst:259
msgid "Virtual Environment"
msgstr ""

#: ../source/glossary.rst:262
msgid "An isolated Python environment that allows packages to be installed for use by a particular application, rather than being installed system wide. For more information, see the section on :ref:`Creating and using Virtual Environments`."
msgstr ""

#: ../source/glossary.rst:266
msgid "Wheel"
msgstr ""

#: ../source/glossary.rst:269
msgid "A :term:`Built Distribution` format introduced by an official :doc:`standard specification </specifications/binary-distribution-format/>`, which is intended to replace the :term:`Egg` format.  Wheel is currently supported by :ref:`pip`."
msgstr ""

#: ../source/glossary.rst:274
msgid "Working Set"
msgstr ""

#: ../source/glossary.rst:277
msgid "A collection of :term:`distributions <Distribution Package>` available for importing. These are the distributions that are on the `sys.path` variable. At most, one :term:`Distribution <Distribution Package>` for a project is possible in a working set."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:3
msgid "Analyzing PyPI package downloads"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:5
msgid "This section covers how to use the public PyPI download statistics dataset to learn more about downloads of a package (or packages) hosted on PyPI. For example, you can use it to discover the distribution of Python versions used to download a package."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:12
#: ../source/guides/supporting-windows-using-appveyor.rst:17
msgid "Background"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:14
msgid "PyPI does not display download statistics for a number of reasons: [#]_"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:16
msgid "**Inefficient to make work with a Content Distribution Network (CDN):** Download statistics change constantly. Including them in project pages, which are heavily cached, would require invalidating the cache more often, and reduce the overall effectiveness of the cache."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:21
msgid "**Highly inaccurate:** A number of things prevent the download counts from being accurate, some of which include:"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:24
msgid "``pip``'s download cache (lowers download counts)"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:25
msgid "Internal or unofficial mirrors (can both raise or lower download counts)"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:26
msgid "Packages not hosted on PyPI (for comparisons sake)"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:27
msgid "Unofficial scripts or attempts at download count inflation (raises download counts)"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:29
msgid "Known historical data quality issues (lowers download counts)"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:31
msgid "**Not particularly useful:** Just because a project has been downloaded a lot doesn't mean it's good; Similarly just because a project hasn't been downloaded a lot doesn't mean it's bad!"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:35
msgid "In short, because it's value is low for various reasons, and the tradeoffs required to make it work are high, it has been not an effective use of limited resources."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:40
msgid "Public dataset"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:42
msgid "As an alternative, the `Linehaul project <https://github.com/pypa/linehaul-cloud-function/>`__ streams download logs from PyPI to `Google BigQuery`_ [#]_, where they are stored as a public dataset."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:47
msgid "Getting set up"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:49
msgid "In order to use `Google BigQuery`_ to query the `public PyPI download statistics dataset`_, you'll need a Google account and to enable the BigQuery API on a Google Cloud Platform project. You can run up to 1TB of queries per month `using the BigQuery free tier without a credit card <https://cloud.google.com/blog/products/data-analytics/query-without-a-credit-card-introducing-bigquery-sandbox>`__"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:55
msgid "Navigate to the `BigQuery web UI`_."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:56
msgid "Create a new project."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:57
msgid "Enable the `BigQuery API <https://console.developers.google.com/apis/library/bigquery-json.googleapis.com>`__."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:60
msgid "For more detailed instructions on how to get started with BigQuery, check out the `BigQuery quickstart guide <https://cloud.google.com/bigquery/docs/quickstarts/quickstart-web-ui>`__."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:66
msgid "Data schema"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:68
msgid "Linehaul writes an entry in a ``bigquery-public-data.pypi.file_downloads`` table for each download. The table contains information about what file was downloaded and how it was downloaded. Some useful columns from the `table schema <https://console.cloud.google.com/bigquery?pli=1&p=bigquery-public-data&d=pypi&t=file_downloads&page=table>`__ include:"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:75
msgid "Column"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:75
#: ../source/specifications/core-metadata.rst:196
msgid "Description"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:75
#: ../source/specifications/dependency-specifiers.rst:27
#: ../source/specifications/direct-url-data-structure.rst:234
#: ../source/specifications/version-specifiers.rst:1063
msgid "Examples"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:77
msgid "timestamp"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:77
msgid "Date and time"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:77
msgid "``2020-03-09 00:33:03 UTC``"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:79
msgid "file.project"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:79
msgid "Project name"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:79
msgid "``pipenv``, ``nose``"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:81
msgid "file.version"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:81
msgid "Package version"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:81
msgid "``0.1.6``, ``1.4.2``"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:83
msgid "details.installer.name"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:83
msgid "Installer"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:83
msgid "pip, :ref:`bandersnatch`"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:85
msgid "details.python"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:85
msgid "Python version"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:85
msgid "``2.7.12``, ``3.6.4``"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:90
msgid "Useful queries"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:92
msgid "Run queries in the `BigQuery web UI`_ by clicking the \"Compose query\" button."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:94
msgid "Note that the rows are stored in a partitioned table, which helps limit the cost of queries. These example queries analyze downloads from recent history by filtering on the ``timestamp`` column."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:99
msgid "Counting package downloads"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:101
msgid "The following query counts the total number of downloads for the project \"pytest\"."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:116
#: ../source/guides/analyzing-pypi-package-downloads.rst:137
#: ../source/guides/analyzing-pypi-package-downloads.rst:165
#: ../source/guides/analyzing-pypi-package-downloads.rst:202
msgid "num_downloads"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:118
msgid "26190085"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:121
msgid "To count downloads from pip only, filter on the ``details.installer.name`` column."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:139
msgid "24334215"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:143
msgid "Package downloads over time"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:145
msgid "To group by monthly downloads, use the ``TIMESTAMP_TRUNC`` function. Also filtering by this column reduces corresponding costs."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:165
msgid "month"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:167
msgid "1956741"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:167
msgid "2018-01-01"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:169
msgid "2344692"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:169
msgid "2017-12-01"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:171
msgid "1730398"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:171
msgid "2017-11-01"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:173
msgid "2047310"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:173
msgid "2017-10-01"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:175
msgid "1744443"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:175
msgid "2017-09-01"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:177
msgid "1916952"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:177
msgid "2017-08-01"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:181
msgid "Python versions over time"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:183
msgid "Extract the Python version from the ``details.python`` column. Warning: This query processes over 500 GB of data."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:202
msgid "python"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:204
msgid "3.7"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:204
msgid "18051328726"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:206
msgid "3.6"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:206
msgid "9635067203"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:208
msgid "3.8"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:208
msgid "7781904681"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:210
msgid "2.7"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:210
msgid "6381252241"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:212
msgid "null"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:212
msgid "2026630299"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:214
msgid "3.5"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:214
msgid "1894153540"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:219
msgid "Getting absolute links to artifacts"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:221
msgid "It's sometimes helpful to be able to get the absolute links to download artifacts from PyPI based on their hashes, e.g. if a particular project or release has been deleted from PyPI. The metadata table includes the ``path`` column, which includes the hash and artifact filename."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:227
msgid "The URL generated here is not guaranteed to be stable, but currently aligns with the URL where PyPI artifacts are hosted."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:240
msgid "url"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:242
msgid "https://files.pythonhosted.org/packages/eb/45/79be82bdeafcecb9dca474cad4003e32ef8e4a0dec6abbd4145ccb02abe1/sampleproject-1.2.0.tar.gz"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:244
msgid "https://files.pythonhosted.org/packages/56/0a/178e8bbb585ec5b13af42dae48b1d7425d6575b3ff9b02e5ec475e38e1d6/sampleproject_nomura-1.2.0-py2.py3-none-any.whl"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:246
msgid "https://files.pythonhosted.org/packages/63/88/3200eeaf22571f18d2c41e288862502e33365ccbdc12b892db23f51f8e70/sampleproject_nomura-1.2.0.tar.gz"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:248
msgid "https://files.pythonhosted.org/packages/21/e9/2743311822e71c0756394b6c5ab15cb64ca66c78c6c6a5cd872c9ed33154/sampleproject_doubleyoung18-1.3.0-py2.py3-none-any.whl"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:250
msgid "https://files.pythonhosted.org/packages/6f/5b/2f3fe94e1c02816fe23c7ceee5292fb186912929e1972eee7fb729fa27af/sampleproject-1.3.1.tar.gz"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:255
msgid "Caveats"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:257
msgid "In addition to the caveats listed in the background above, Linehaul suffered from a bug which caused it to significantly under-report download statistics prior to July 26, 2018. Downloads before this date are proportionally accurate (e.g. the percentage of Python 2 vs. Python 3 downloads) but total numbers are lower than actual by an order of magnitude."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:265
msgid "Additional tools"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:267
msgid "Besides using the BigQuery console, there are some additional tools which may be useful when analyzing download statistics."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:271
msgid "``google-cloud-bigquery``"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:273
msgid "You can also access the public PyPI download statistics dataset programmatically via the BigQuery API and the `google-cloud-bigquery`_ project, the official Python client library for BigQuery."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:301
msgid "``pypinfo``"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:303
msgid "`pypinfo`_ is a command-line tool which provides access to the dataset and can generate several useful queries. For example, you can query the total number of download for a package with the command ``pypinfo package_name``."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:307
msgid "Install `pypinfo`_ using pip."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:313
msgid "Usage:"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:329
msgid "``pandas-gbq``"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:331
msgid "The `pandas-gbq`_ project allows for accessing query results via `Pandas`_."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:335
#: ../source/specifications/binary-distribution-format.rst:482
#: ../source/specifications/dependency-specifiers.rst:483
msgid "References"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:337
msgid "`PyPI Download Counts deprecation email <https://mail.python.org/pipermail/distutils-sig/2013-May/020855.html>`__"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:338
msgid "`PyPI BigQuery dataset announcement email <https://mail.python.org/pipermail/distutils-sig/2016-May/028986.html>`__"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:3
msgid "Creating and discovering plugins"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:5
msgid "Often when creating a Python application or library you'll want the ability to provide customizations or extra features via **plugins**. Because Python packages can be separately distributed, your application or library may want to automatically **discover** all of the plugins available."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:10
msgid "There are three major approaches to doing automatic plugin discovery:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:12
msgid "`Using naming convention`_."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:13
msgid "`Using namespace packages`_."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:14
msgid "`Using package metadata`_."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:18
msgid "Using naming convention"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:20
msgid "If all of the plugins for your application follow the same naming convention, you can use :func:`pkgutil.iter_modules` to discover all of the top-level modules that match the naming convention. For example, `Flask`_ uses the naming convention ``flask_{plugin_name}``. If you wanted to automatically discover all of the Flask plugins installed:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:38
msgid "If you had both the `Flask-SQLAlchemy`_ and `Flask-Talisman`_ plugins installed then ``discovered_plugins`` would be:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:48
msgid "Using naming convention for plugins also allows you to query the Python Package Index's :ref:`simple repository API <simple-repository-api>` for all packages that conform to your naming convention."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:58
msgid "Using namespace packages"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:60
msgid ":doc:`Namespace packages <packaging-namespace-packages>` can be used to provide a convention for where to place plugins and also provides a way to perform discovery. For example, if you make the sub-package ``myapp.plugins`` a namespace package then other :term:`distributions <Distribution Package>` can provide modules and packages to that namespace. Once installed, you can use :func:`pkgutil.iter_modules` to discover all modules and packages installed under that namespace:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:88
msgid "Specifying ``myapp.plugins.__path__`` to :func:`~pkgutil.iter_modules` causes it to only look for the modules directly under that namespace. For example, if you have installed distributions that provide the modules ``myapp.plugins.a`` and ``myapp.plugins.b`` then ``discovered_plugins`` in this case would be:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:100
msgid "This sample uses a sub-package as the namespace package (``myapp.plugins``), but it's also possible to use a top-level package for this purpose (such as ``myapp_plugins``). How to pick the namespace to use is a matter of preference, but it's not recommended to make your project's main top-level package (``myapp`` in this case) a namespace package for the purpose of plugins, as one bad plugin could cause the entire namespace to break which would in turn make your project unimportable. For the \"namespace sub-package\" approach to work, the plugin packages must omit the :file:`__init__.py` for your top-level package directory (``myapp`` in this case) and include the namespace-package style :file:`__init__.py` in the namespace sub-package directory (``myapp/plugins``).  This also means that plugins will need to explicitly pass a list of packages to :func:`setup`'s ``packages`` argument instead of using :func:`setuptools.find_packages`."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:114
msgid "Namespace packages are a complex feature and there are several different ways to create them. It's highly recommended to read the :doc:`packaging-namespace-packages` documentation and clearly document which approach is preferred for plugins to your project."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:122
msgid "Using package metadata"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:124
msgid "Packages can have metadata for plugins described in the :ref:`entry-points`. By specifying them, a package announces that it contains a specific kind of plugin. Another package supporting this kind of plugin can use the metadata to discover that plugin."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:128
msgid "For example if you have a package named ``myapp-plugin-a`` and it includes the following in its ``pyproject.toml``:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:136
msgid "Then you can discover and load all of the registered entry points by using :func:`importlib.metadata.entry_points` (or the backport_ ``importlib_metadata >= 3.6`` for Python 3.6-3.9):"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:151
msgid "In this example, ``discovered_plugins`` would be a collection of type :class:`importlib.metadata.EntryPoint`:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:160
msgid "Now the module of your choice can be imported by executing ``discovered_plugins['a'].load()``."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:163
msgid "The ``entry_point`` specification in :file:`setup.py` is fairly flexible and has a lot of options. It's recommended to read over the entire section on :doc:`entry points <setuptools:userguide/entry_point>` ."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:167
msgid "Since this specification is part of the :doc:`standard library <python:library/importlib.metadata>`, most packaging tools other than setuptools provide support for defining entry points."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:5
msgid "Packaging and distributing projects"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:7
msgid "This section covers some additional details on configuring, packaging and distributing Python projects with ``setuptools`` that aren't covered by the introductory tutorial in :doc:`/tutorials/packaging-projects`.  It still assumes that you are already familiar with the contents of the :doc:`/tutorials/installing-packages` page."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:13
msgid "The section does *not* aim to cover best practices for Python project development as a whole.  For example, it does not provide guidance or tool recommendations for version control, documentation, or testing."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:17
msgid "For more reference material, see :std:doc:`Building and Distributing Packages <setuptools:userguide/index>` in the :ref:`setuptools` docs, but note that some advisory content there may be outdated. In the event of conflicts, prefer the advice in the Python Packaging User Guide."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:25
msgid "Requirements for packaging and distributing"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:26
msgid "First, make sure you have already fulfilled the :ref:`requirements for installing packages <installing_requirements>`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:29
msgid "Install \"twine\" [1]_:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:43
msgid "You'll need this to upload your project :term:`distributions <Distribution Package>` to :term:`PyPI <Python Package Index (PyPI)>` (see :ref:`below <Uploading your Project to PyPI>`)."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:49
msgid "Configuring your project"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:53
msgid "Initial files"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:58
msgid "The most important file is :file:`setup.py` which exists at the root of your project directory. For an example, see the `setup.py <https://github.com/pypa/sampleproject/blob/db5806e0a3204034c51b1c00dde7d5eb3fa2532e/setup.py>`_ in the `PyPA sample project <https://github.com/pypa/sampleproject>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:63
msgid ":file:`setup.py` serves two primary functions:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:65
msgid "It's the file where various aspects of your project are configured. The primary feature of :file:`setup.py` is that it contains a global ``setup()`` function.  The keyword arguments to this function are how specific details of your project are defined.  The most relevant arguments are explained in :ref:`the section below <setup() args>`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:71
msgid "It's the command line interface for running various commands that relate to packaging tasks. To get a listing of available commands, run ``python3 setup.py --help-commands``."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:79
msgid ":file:`setup.cfg` is an ini file that contains option defaults for :file:`setup.py` commands.  For an example, see the `setup.cfg <https://github.com/pypa/sampleproject/blob/db5806e0a3204034c51b1c00dde7d5eb3fa2532e/setup.cfg>`_ in the `PyPA sample project <https://github.com/pypa/sampleproject>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:86
msgid "README.rst / README.md"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:88
msgid "All projects should contain a readme file that covers the goal of the project. The most common format is `reStructuredText <https://docutils.sourceforge.io/rst.html>`_ with an \"rst\" extension, although this is not a requirement; multiple variants of `Markdown <https://daringfireball.net/projects/markdown/>`_ are supported as well (look at ``setup()``'s :ref:`long_description_content_type <description>` argument)."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:95
msgid "For an example, see `README.md <https://github.com/pypa/sampleproject/blob/main/README.md>`_ from the `PyPA sample project <https://github.com/pypa/sampleproject>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:99
msgid "Projects using :ref:`setuptools` 0.6.27+ have standard readme files (:file:`README.rst`, :file:`README.txt`, or :file:`README`) included in source distributions by default. The built-in :ref:`distutils` library adopts this behavior beginning in Python 3.7. Additionally, :ref:`setuptools` 36.4.0+ will include a :file:`README.md` if found. If you are using setuptools, you don't need to list your readme file in :file:`MANIFEST.in`. Otherwise, include it to be explicit."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:108
msgid "MANIFEST.in"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:110
msgid "A :file:`MANIFEST.in` is needed when you need to package additional files that are not automatically included in a source distribution.  For details on writing a :file:`MANIFEST.in` file, including a list of what's included by default, see \":ref:`Using MANIFEST.in`\"."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:115
msgid "However, you may not have to use a :file:`MANIFEST.in`. For an example, the `PyPA sample project <https://github.com/pypa/sampleproject>`_ has removed its manifest file, since all the necessary files have been included by :ref:`setuptools` 43.0.0 and newer."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:120
msgid ":file:`MANIFEST.in` does not affect binary distributions such as wheels."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:123
msgid "LICENSE.txt"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:125
msgid "Every package should include a license file detailing the terms of distribution. In many jurisdictions, packages without an explicit license can not be legally used or distributed by anyone other than the copyright holder. If you're unsure which license to choose, you can use resources such as `GitHub's Choose a License <https://choosealicense.com/>`_ or consult a lawyer."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:131
msgid "For an example, see the `LICENSE.txt <https://github.com/pypa/sampleproject/blob/main/LICENSE.txt>`_ from the `PyPA sample project <https://github.com/pypa/sampleproject>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:136
msgid "<your package>"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:138
msgid "Although it's not required, the most common practice is to include your Python modules and packages under a single top-level package that has the same :ref:`name <setup() name>` as your project, or something very close."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:142
msgid "For an example, see the `sample <https://github.com/pypa/sampleproject/tree/main/src/sample>`_ package that's included in the `PyPA sample project <https://github.com/pypa/sampleproject>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:150
msgid "setup() args"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:152
msgid "As mentioned above, the primary feature of :file:`setup.py` is that it contains a global ``setup()`` function.  The keyword arguments to this function are how specific details of your project are defined."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:156
msgid "The most relevant arguments are explained below. Most of the snippets given are taken from the `setup.py <https://github.com/pypa/sampleproject/blob/db5806e0a3204034c51b1c00dde7d5eb3fa2532e/setup.py>`_ contained in the `PyPA sample project <https://github.com/pypa/sampleproject>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:165
#: ../source/guides/writing-pyproject-toml.rst:120
#: ../source/specifications/declaring-project-metadata.rst:41
#: ../source/specifications/declaring-project-metadata.rst:63
#: ../source/specifications/declaring-project-metadata.rst:73
msgid "``name``"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:171
msgid "This is the name of your project, determining how your project is listed on :term:`PyPI <Python Package Index (PyPI)>`.  Per :pep:`508`, valid project names must:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:175
msgid "Consist only of ASCII letters, digits, underscores (``_``), hyphens (``-``), and/or periods (``.``), and"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:177
msgid "Start & end with an ASCII letter or digit."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:179
msgid "Comparison of project names is case insensitive and treats arbitrarily-long runs of underscores, hyphens, and/or periods as equal.  For example, if you register a project named ``cool-stuff``, users will be able to download it or declare a dependency on it using any of the following spellings::"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:191
#: ../source/guides/writing-pyproject-toml.rst:132
#: ../source/specifications/declaring-project-metadata.rst:46
#: ../source/specifications/declaring-project-metadata.rst:69
#: ../source/specifications/declaring-project-metadata.rst:85
msgid "``version``"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:197
msgid "This is the current version of your project, allowing your users to determine whether or not they have the latest version, and to indicate which specific versions they've tested their own software against."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:201
msgid "Versions are displayed on :term:`PyPI <Python Package Index (PyPI)>` for each release if you publish your project."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:204
msgid "See :ref:`Choosing a versioning scheme` for more information on ways to use versions to convey compatibility information to your users."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:207
msgid "If the project code itself needs run-time access to the version, the simplest way is to keep the version in both :file:`setup.py` and your code. If you'd rather not duplicate the value, there are a few ways to manage this. See the \":ref:`Single sourcing the version`\" Advanced Topics section."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:215
#: ../source/guides/writing-pyproject-toml.rst:263
#: ../source/specifications/declaring-project-metadata.rst:56
#: ../source/specifications/declaring-project-metadata.rst:98
msgid "``description``"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:223
msgid "Give a short and long description for your project."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:225
msgid "These values will be displayed on :term:`PyPI <Python Package Index (PyPI)>` if you publish your project. On ``pypi.org``, the user interface displays ``description`` in the grey banner and ``long_description`` in the section named \"Project Description\"."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:230
msgid "``description`` is also displayed in lists of projects. For example, it's visible in the search results pages such as https://pypi.org/search/?q=jupyter, the front-page lists of trending projects and new releases, and the list of projects you maintain within your account profile (such as https://pypi.org/user/jaraco/)."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:236
msgid "A `content type <https://packaging.python.org/specifications/core-metadata/#description-content-type-optional>`_ can be specified with the ``long_description_content_type`` argument, which can be one of ``text/plain``, ``text/x-rst``, or ``text/markdown``, corresponding to no formatting, `reStructuredText (reST) <https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#reference-names>`_, and the GitHub-flavored Markdown dialect of `Markdown <https://daringfireball.net/projects/markdown/>`_ respectively."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:246
msgid "``url``"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:253
msgid "Give a homepage URL for your project."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:257
msgid "``author``"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:264
msgid "Provide details about the author."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:268
#: ../source/guides/writing-pyproject-toml.rst:302
#: ../source/specifications/declaring-project-metadata.rst:61
#: ../source/specifications/declaring-project-metadata.rst:157
msgid "``license``"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:274
msgid "The ``license`` argument doesn't have to indicate the license under which your package is being released, although you may optionally do so if you want.  If you're using a standard, well-known license, then your main indication can and should be via the ``classifiers`` argument. Classifiers exist for all major open-source licenses."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:280
msgid "The ``license`` argument is more typically used to indicate differences from well-known licenses, or to include your own, unique license. As a general rule, it's a good idea to use a standard, well-known license, both to avoid confusion and because some organizations avoid software whose license is unapproved."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:288
#: ../source/guides/writing-pyproject-toml.rst:335
#: ../source/specifications/declaring-project-metadata.rst:54
#: ../source/specifications/declaring-project-metadata.rst:224
msgid "``classifiers``"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:317
msgid "Provide a list of classifiers that categorize your project. For a full listing, see https://pypi.org/classifiers/."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:320
msgid "Although the list of classifiers is often used to declare what Python versions a project supports, this information is only used for searching & browsing projects on PyPI, not for installing projects.  To actually restrict what Python versions a project can be installed on, use the :ref:`python_requires` argument."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:326
msgid "To prevent a package from being uploaded to PyPI, use the special ``'Private :: Do Not Upload'`` classifier. PyPI will always reject packages with classifiers beginning with ``\"Private ::'``."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:332
#: ../source/guides/writing-pyproject-toml.rst:323
#: ../source/specifications/declaring-project-metadata.rst:60
#: ../source/specifications/declaring-project-metadata.rst:214
msgid "``keywords``"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:338
msgid "List keywords that describe your project."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:342
msgid "``project_urls``"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:354
msgid "List additional relevant URLs about your project. This is the place to link to bug trackers, source repositories, or where to support package development. The string of the key is the exact text that will be displayed on PyPI."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:360
msgid "``packages``"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:366
msgid "Set ``packages`` to a list of all :term:`packages <Import Package>` in your project, including their subpackages, sub-subpackages, etc.  Although the packages can be listed manually, ``setuptools.find_packages()`` finds them automatically.  Use the ``include`` keyword argument to find only the given packages.  Use the ``exclude`` keyword argument to omit packages that are not intended to be released and installed."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:375
msgid "``py_modules``"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:381
msgid "If your project contains any single-file Python modules that aren't part of a package, set ``py_modules`` to a list of the names of the modules (minus the ``.py`` extension) in order to make :ref:`setuptools` aware of them."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:387
msgid "``install_requires``"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:393
msgid "\"install_requires\" should be used to specify what dependencies a project minimally needs to run. When the project is installed by :ref:`pip`, this is the specification that is used to install its dependencies."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:397
msgid "For more on using \"install_requires\" see :ref:`install_requires vs Requirements files`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:403
msgid "``python_requires``"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:405
msgid "If your project only runs on certain Python versions, setting the ``python_requires`` argument to the appropriate :pep:`440` version specifier string will prevent :ref:`pip` from installing the project on other Python versions.  For example, if your package is for Python 3+ only, write::"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:412
msgid "If your package is for Python 2.6, 2.7, and all versions of Python 3 starting with 3.3, write::"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:417
msgid "And so on."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:421
msgid "Support for this feature is relatively recent.  Your project's source distributions and wheels (see :ref:`Packaging Your Project`) must be built using at least version 24.2.0 of :ref:`setuptools` in order for the ``python_requires`` argument to be recognized and the appropriate metadata generated."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:427
msgid "In addition, only versions 9.0.0 and higher of :ref:`pip` recognize the ``python_requires`` metadata.  Users with earlier versions of pip will be able to download & install projects on any Python version regardless of the projects' ``python_requires`` values."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:436
msgid "``package_data``"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:445
msgid "Often, additional files need to be installed into a :term:`package <Import Package>`. These files are often data that’s closely related to the package’s implementation, or text files containing documentation that might be of interest to programmers using the package. These files are called \"package data\"."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:450
msgid "The value must be a mapping from package name to a list of relative path names that should be copied into the package. The paths are interpreted as relative to the directory containing the package."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:454
msgid "For more information, see :std:doc:`Including Data Files <setuptools:userguide/datafiles>` from the :std:doc:`setuptools docs <setuptools:index>`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:462
msgid "``data_files``"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:468
msgid "Although configuring :ref:`Package Data` is sufficient for most needs, in some cases you may need to place data files *outside* of your :term:`packages <Import Package>`.  The ``data_files`` directive allows you to do that. It is mostly useful if you need to install files which are used by other programs, which may be unaware of Python packages."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:474
msgid "Each ``(directory, files)`` pair in the sequence specifies the installation directory and the files to install there. The ``directory`` must be a relative path (although this may change in the future, see `wheel Issue #92 <https://github.com/pypa/wheel/issues/92>`_), and it is interpreted relative to the installation prefix (Python’s ``sys.prefix`` for a default installation; ``site.USER_BASE`` for a user installation). Each file name in ``files`` is interpreted relative to the :file:`setup.py` script at the top of the project source distribution."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:484
msgid "For more information see the distutils section on :ref:`Installing Additional Files <setuptools:distutils-additional-files>`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:489
msgid "When installing packages as egg, ``data_files`` is not supported. So, if your project uses :ref:`setuptools`, you must use ``pip`` to install it. Alternatively, if you must use ``python setup.py``, then you need to pass the ``--old-and-unmanageable`` option."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:496
#: ../source/specifications/declaring-project-metadata.rst:67
msgid "``scripts``"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:498
msgid "Although ``setup()`` supports a :ref:`scripts <setuptools:distutils-installing-scripts>` keyword for pointing to pre-made scripts to install, the recommended approach to achieve cross-platform compatibility is to use :ref:`console_scripts` entry points (see below)."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:505
msgid "``entry_points``"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:514
msgid "Use this keyword to specify any plugins that your project provides for any named entry points that may be defined by your project or others that you depend on."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:517
msgid "For more information, see the section on :ref:`Advertising Behavior <setuptools:dynamic discovery of services and plugins>` from the :ref:`setuptools` docs."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:521
msgid "The most commonly used entry point is \"console_scripts\" (see below)."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:526
msgid "``console_scripts``"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:536
msgid "Use ``console_script`` :ref:`entry points <setuptools:dynamic discovery of services and plugins>` to register your script interfaces. You can then let the toolchain handle the work of turning these interfaces into actual scripts [2]_.  The scripts will be generated during the install of your :term:`distribution <Distribution Package>`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:543
msgid "For more information, see :doc:`Entry Points <setuptools:userguide/entry_point>` from the :doc:`setuptools docs <setuptools:index>`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:549
msgid "Choosing a versioning scheme"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:552
msgid "Standards compliance for interoperability"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:554
msgid "Different Python projects may use different versioning schemes based on the needs of that particular project, but all of them are required to comply with the flexible :pep:`public version scheme <440#public-version-identifiers>` specified in :pep:`440` in order to be supported in tools and libraries like ``pip`` and ``setuptools``."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:560
msgid "Here are some examples of compliant version numbers::"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:571
msgid "To further accommodate historical variations in approaches to version numbering, :pep:`440` also defines a comprehensive technique for :pep:`version normalisation <440#normalization>` that maps variant spellings of different version numbers to a standardised canonical form."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:577
msgid "Scheme choices"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:580
msgid "Semantic versioning (preferred)"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:582
msgid "For new projects, the recommended versioning scheme is based on `Semantic Versioning <https://semver.org/>`_, but adopts a different approach to handling pre-releases and build metadata."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:586
msgid "The essence of semantic versioning is a 3-part MAJOR.MINOR.MAINTENANCE numbering scheme, where the project author increments:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:589
msgid "MAJOR version when they make incompatible API changes,"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:590
msgid "MINOR version when they add functionality in a backwards-compatible manner, and"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:591
msgid "MAINTENANCE version when they make backwards-compatible bug fixes."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:593
msgid "Adopting this approach as a project author allows users to make use of :pep:`\"compatible release\" <440#compatible-release>` specifiers, where ``name ~= X.Y`` requires at least release X.Y, but also allows any later release with a matching MAJOR version."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:598
msgid "Python projects adopting semantic versioning should abide by clauses 1-8 of the `Semantic Versioning 2.0.0 specification <https://semver.org/>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:602
msgid "Date based versioning"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:604
msgid "Semantic versioning is not a suitable choice for all projects, such as those with a regular time based release cadence and a deprecation process that provides warnings for a number of releases prior to removal of a feature."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:608
msgid "A key advantage of date based versioning is that it is straightforward to tell how old the base feature set of a particular release is given just the version number."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:611
msgid "Version numbers for date based projects typically take the form of YEAR.MONTH (for example, ``12.04``, ``15.10``)."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:615
msgid "Serial versioning"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:617
msgid "This is the simplest possible versioning scheme, and consists of a single number which is incremented every release."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:620
msgid "While serial versioning is very easy to manage as a developer, it is the hardest to track as an end user, as serial version numbers convey little or no information regarding API backwards compatibility."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:625
msgid "Hybrid schemes"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:627
msgid "Combinations of the above schemes are possible. For example, a project may combine date based versioning with serial versioning to create a YEAR.SERIAL numbering scheme that readily conveys the approximate age of a release, but doesn't otherwise commit to a particular release cadence within the year."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:633
msgid "Pre-release versioning"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:635
msgid "Regardless of the base versioning scheme, pre-releases for a given final release may be published as:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:638
msgid "zero or more dev releases (denoted with a \".devN\" suffix)"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:639
msgid "zero or more alpha releases (denoted with a \".aN\" suffix)"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:640
msgid "zero or more beta releases (denoted with a \".bN\" suffix)"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:641
msgid "zero or more release candidates (denoted with a \".rcN\" suffix)"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:643
msgid "``pip`` and other modern Python package installers ignore pre-releases by default when deciding which versions of dependencies to install."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:648
#: ../source/specifications/version-specifiers.rst:110
msgid "Local version identifiers"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:650
msgid "Public version identifiers are designed to support distribution via :term:`PyPI <Python Package Index (PyPI)>`. Python's software distribution tools also support the notion of a :pep:`local version identifier <440#local-version-identifiers>`, which can be used to identify local development builds not intended for publication, or modified variants of a release maintained by a redistributor."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:657
msgid "A local version identifier takes the form ``<public version identifier>+<local version label>``. For example::"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:665
msgid "Working in \"development mode\""
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:667
msgid "You can install a project in \"editable\" or \"develop\" mode while you're working on it. When installed as editable, a project can be edited in-place without reinstallation: changes to Python source files in projects installed as editable will be reflected the next time an interpreter process is started."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:673
msgid "To install a Python package in \"editable\"/\"development\" mode Change directory to the root of the project directory and run:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:681
msgid "The pip command-line flag ``-e`` is short for ``--editable``, and ``.`` refers to the current working directory, so together, it means to install the current directory (i.e. your project) in editable mode.  This will also install any dependencies declared with ``install_requires`` and any scripts declared with ``console_scripts``.  Dependencies will be installed in the usual, non-editable mode."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:688
msgid "You may want to install some of your dependencies in editable mode as well. For example, supposing your project requires \"foo\" and \"bar\", but you want \"bar\" installed from VCS in editable mode, then you could construct a requirements file like so::"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:696
msgid "The first line says to install your project and any dependencies. The second line overrides the \"bar\" dependency, such that it's fulfilled from VCS, not PyPI."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:700
msgid "If, however, you want \"bar\" installed from a local directory in editable mode, the requirements file should look like this, with the local paths at the top of the file::"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:705
msgid "Otherwise, the dependency will be fulfilled from PyPI, due to the installation order of the requirements file.  For more on requirements files, see the :ref:`Requirements File <pip:Requirements Files>` section in the pip docs.  For more on VCS installs, see the :ref:`VCS Support <pip:VCS Support>` section of the pip docs."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:709
msgid "Lastly, if you don't want to install any dependencies at all, you can run:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:716
msgid "For more information, see the :doc:`Development Mode <setuptools:userguide/development_mode>` section of the :ref:`setuptools` docs."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:723
msgid "Packaging your project"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:725
msgid "To have your project installable from a :term:`Package Index` like :term:`PyPI <Python Package Index (PyPI)>`, you'll need to create a :term:`Distribution <Distribution Package>` (aka \":term:`Package <Distribution Package>`\") for your project."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:730
msgid "Before you can build wheels and sdists for your project, you'll need to install the ``build`` package:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:747
msgid "Source distributions"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:749
msgid "Minimally, you should create a :term:`Source Distribution <Source Distribution (or \"sdist\")>`:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:765
msgid "A \"source distribution\" is unbuilt (i.e. it's not a :term:`Built Distribution`), and requires a build step when installed by pip.  Even if the distribution is pure Python (i.e. contains no extensions), it still involves a build step to build out the installation metadata from :file:`setup.py` and/or :file:`setup.cfg`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:773
msgid "Wheels"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:775
msgid "You should also create a wheel for your project. A wheel is a :term:`built package <Built Distribution>` that can be installed without needing to go through the \"build\" process. Installing wheels is substantially faster for the end user than installing from a source distribution."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:780
msgid "If your project is pure Python then you'll be creating a :ref:`\"Pure Python Wheel\" (see section below) <Pure Python Wheels>`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:783
msgid "If your project contains compiled extensions, then you'll be creating what's called a :ref:`*Platform Wheel* (see section below) <Platform Wheels>`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:786
msgid "If your project also supports Python 2 *and* contains no C extensions, then you should create what's called a *Universal Wheel* by adding the following to your :file:`setup.cfg` file:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:795
msgid "Only use this setting if your project does not have any C extensions *and* supports Python 2 and 3."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:802
msgid "Pure Python Wheels"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:804
msgid "*Pure Python Wheels* contain no compiled extensions, and therefore only require a single Python wheel."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:807
#: ../source/guides/distributing-packages-using-setuptools.rst:836
msgid "To build the wheel:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:821
msgid "The ``wheel`` package will detect that the code is pure Python, and build a wheel that's named such that it's usable on any Python 3 installation.  For details on the naming of wheel files, see :pep:`425`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:825
msgid "If you run ``build`` without ``--wheel`` or ``--sdist``, it will build both files for you; this is useful when you don't need multiple wheels."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:831
msgid "Platform Wheels"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:833
msgid "*Platform Wheels* are wheels that are specific to a certain platform like Linux, macOS, or Windows, usually due to containing compiled extensions."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:851
msgid "The ``wheel`` package will detect that the code is not pure Python, and build a wheel that's named such that it's only usable on the platform that it was built on. For details on the naming of wheel files, see :pep:`425`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:857
msgid ":term:`PyPI <Python Package Index (PyPI)>` currently supports uploads of platform wheels for Windows, macOS, and the multi-distro ``manylinux*`` ABI. Details of the latter are defined in :pep:`513`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:865
msgid "Uploading your Project to PyPI"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:867
msgid "When you ran the command to create your distribution, a new directory ``dist/`` was created under your project's root directory. That's where you'll find your distribution file(s) to upload."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:871
msgid "These files are only created when you run the command to create your distribution. This means that any time you change the source of your project or the configuration in your :file:`setup.py` file, you will need to rebuild these files again before you can distribute the changes to PyPI."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:876
msgid "Before releasing on main PyPI repo, you might prefer training with the `PyPI test site <https://test.pypi.org/>`_ which is cleaned on a semi regular basis. See :ref:`using-test-pypi` on how to setup your configuration in order to use it."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:881
msgid "In other resources you may encounter references to using ``python setup.py register`` and ``python setup.py upload``. These methods of registering and uploading a package are **strongly discouraged** as it may use a plaintext HTTP or unverified HTTPS connection on some Python versions, allowing your username and password to be intercepted during transmission."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:887
msgid "The reStructuredText parser used on PyPI is **not** Sphinx! Furthermore, to ensure safety of all users, certain kinds of URLs and directives are forbidden or stripped out (e.g., the ``.. raw::`` directive). **Before** trying to upload your distribution, you should check to see if your brief / long descriptions provided in :file:`setup.py` are valid.  You can do this by running :std:doc:`twine check <index>` on your package files:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:900
msgid "Create an account"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:902
msgid "First, you need a :term:`PyPI <Python Package Index (PyPI)>` user account. You can create an account `using the form on the PyPI website <https://pypi.org/account/register/>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:906
msgid "Now you'll create a PyPI `API token`_ so you will be able to securely upload your project."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:909
msgid "Go to https://pypi.org/manage/account/#api-tokens and create a new `API token`_; don't limit its scope to a particular project, since you are creating a new project."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:913
msgid "**Don't close the page until you have copied and saved the token — you won't see that token again.**"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:916
msgid "To avoid having to copy and paste the token every time you upload, you can create a :file:`$HOME/.pypirc` file:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:925
msgid "**Be aware that this stores your token in plaintext.**"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:927
#: ../source/guides/migrating-to-pypi-org.rst:74
#: ../source/guides/migrating-to-pypi-org.rst:113
#: ../source/guides/using-testpypi.rst:83
msgid "For more details, see the :ref:`specification <pypirc>` for :file:`.pypirc`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:933
msgid "Upload your distributions"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:935
msgid "Once you have an account you can upload your distributions to :term:`PyPI <Python Package Index (PyPI)>` using :ref:`twine`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:938
msgid "The process for uploading a release is the same regardless of whether or not the project already exists on PyPI - if it doesn't exist yet, it will be automatically created when the first release is uploaded."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:942
msgid "For the second and subsequent releases, PyPI only requires that the version number of the new release differ from any previous releases."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:949
msgid "You can see if your package has successfully uploaded by navigating to the URL ``https://pypi.org/project/<sampleproject>`` where ``sampleproject`` is the name of your project that you uploaded. It may take a minute or two for your project to appear on the site."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:956
#: ../source/tutorials/installing-packages.rst:670
msgid "Depending on your platform, this may require root or Administrator access. :ref:`pip` is currently considering changing this by `making user installs the default behavior <https://github.com/pypa/pip/issues/1668>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:962
msgid "Specifically, the \"console_script\" approach generates ``.exe`` files on Windows, which are necessary because the OS special-cases ``.exe`` files. Script-execution features like ``PATHEXT`` and the :pep:`Python Launcher for Windows <397>` allow scripts to be used in many cases, but not all."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:5
msgid "Dropping support for older Python versions"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:7
msgid "Dropping support for older Python versions is supported by the standard :ref:`core-metadata` 1.2 specification via a \"Requires-Python\" attribute."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:9
msgid "Metadata 1.2+ clients, such as Pip 9.0+, will adhere to this specification by matching the current Python runtime and comparing it with the required version in the package metadata. If they do not match, it will attempt to install the last package distribution that supported that Python runtime."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:12
msgid "This mechanism can be used to drop support for older Python versions, by amending the \"Requires-Python\" attribute in the package metadata."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:14
msgid "This guide is specifically for users of :ref:`setuptools`, other packaging tools such as ``flit`` may offer similar functionality but users will need to consult relevant documentation."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:17
msgid "Requirements"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:19
msgid "This workflow requires that:"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:21
msgid "The publisher is using the latest version of :ref:`setuptools`,"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:22
msgid "The latest version of :ref:`twine` is used to upload the package,"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:23
msgid "The user installing the package has at least Pip 9.0, or a client that supports the Metadata 1.2 specification."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:26
msgid "Dealing with the universal wheels"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:28
msgid "Traditionally, projects providing Python code that is semantically compatible with both Python 2 and Python 3, produce :term:`wheels <Wheel>` that have a ``py2.py3`` tag in their names. When dropping support for Python 2, it is important not to forget to change this tag to just ``py3``. It is often configured within :file:`setup.cfg` under the ``[bdist_wheel]`` section by setting ``universal = 1`` if they use setuptools."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:36
msgid "If you use this method, either remove this option or section, or explicitly set ``universal`` to ``0``:"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:48
msgid "Since it is possible to override the :file:`setup.cfg` settings via CLI flags, make sure that your scripts don't have ``--universal`` in your package creation scripts."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:53
msgid "Defining the Python version required"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:56
msgid "1. Download the newest version of Setuptools"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:58
msgid "Ensure that before you generate source distributions or binary distributions, you update Setuptools and install twine."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:60
msgid "Steps:"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:74
msgid "``setuptools`` version should be above 24.0.0."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:77
msgid "2. Specify the version ranges for supported Python distributions"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:79
msgid "You can specify version ranges and exclusion rules, such as at least Python 3. Or, Python 2.7, 3.4 and beyond."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:81
#: ../source/specifications/core-metadata.rst:149
#: ../source/specifications/core-metadata.rst:473
#: ../source/specifications/core-metadata.rst:497
#: ../source/specifications/core-metadata.rst:538
#: ../source/specifications/core-metadata.rst:594
#: ../source/specifications/core-metadata.rst:727
#: ../source/specifications/core-metadata.rst:757
#: ../source/specifications/core-metadata.rst:798
#: ../source/specifications/core-metadata.rst:820
msgid "Examples::"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:86
msgid "The way to set those values is within the call to ``setup`` within your :file:`setup.py` script. This will insert the ``Requires-Python`` metadata values based on the argument you provide in ``python_requires``."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:101
msgid "3. Validating the Metadata before publishing"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:103
msgid "Within a Python source package (the zip or the tar-gz file you download) is a text file called PKG-INFO."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:105
msgid "This file is generated by :ref:`distutils` or :ref:`setuptools` when it generates the source package. The file contains a set of keys and values, the list of keys is part of the PyPa standard metadata format."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:108
msgid "You can see the contents of the generated file like this:"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:114
msgid "Validate that the following is in place, before publishing the package:"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:116
msgid "If you have upgraded correctly, the Metadata-Version value should be 1.2 or higher."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:117
msgid "The Requires-Python field is set and matches your specification in setup.py."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:120
msgid "4. Using Twine to publish"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:122
msgid "Twine has a number of advantages, apart from being faster it is now the supported method for publishing packages."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:124
msgid "Make sure you are using the newest version of Twine, at least 1.9."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:127
msgid "Dropping a Python release"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:129
msgid "Once you have published a package with the Requires-Python metadata, you can then make a further update removing that Python runtime from support."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:131
msgid "It must be done in this order for the automated fallback to work."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:133
msgid "For example, you published the Requires-Python: \">=2.7\" as version 1.0.0 of your package."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:135
msgid "If you were then to update the version string to \">=3.5\", and publish a new version 2.0.0 of your package, any users running Pip 9.0+ from version 2.7 will have version 1.0.0 of the package installed, and any >=3.5 users will receive version 2.0.0."
msgstr ""

#: ../source/guides/hosting-your-own-index.rst:5
msgid "Hosting your own simple repository"
msgstr ""

#: ../source/guides/hosting-your-own-index.rst:8
msgid "If you wish to host your own simple repository [1]_, you can either use a software package like :doc:`devpi <devpi:index>` or you can use simply create the proper directory structure and use any web server that can serve static files and generate an autoindex."
msgstr ""

#: ../source/guides/hosting-your-own-index.rst:13
msgid "In either case, since you'll be hosting a repository that is likely not in your user's default repositories, you should instruct them in your project's description to configure their installer appropriately. For example with pip:"
msgstr ""

#: ../source/guides/hosting-your-own-index.rst:29
msgid "In addition, it is **highly** recommended that you serve your repository with valid HTTPS. At this time, the security of your user's installations depends on all repositories using a valid HTTPS setup."
msgstr ""

#: ../source/guides/hosting-your-own-index.rst:35
msgid "\"Manual\" repository"
msgstr ""

#: ../source/guides/hosting-your-own-index.rst:37
msgid "The directory layout is fairly simple, within a root directory you need to create a directory for each project. This directory should be the :ref:`normalized name <name-normalization>` of the project. Within each of these directories simply place each of the downloadable files. If you have the projects \"Foo\" (with the versions 1.0 and 2.0) and \"bar\" (with the version 0.1) You should end up with a structure that looks like::"
msgstr ""

#: ../source/guides/hosting-your-own-index.rst:50
msgid "Once you have this layout, simply configure your webserver to serve the root directory with autoindex enabled. For an example using the built in Web server in `Twisted`_, you would simply run ``twistd -n web --path .`` and then instruct users to add the URL to their installer's configuration."
msgstr ""

#: ../source/guides/hosting-your-own-index.rst:57
msgid "For complete documentation of the simple repository protocol, see :ref:`simple repository API <simple-repository-api>`."
msgstr ""

#: ../source/guides/index.rst:4
msgid "**Guides** are focused on accomplishing a specific task and assume that you are already familiar with the basics of Python packaging. If you're looking for an introduction to packaging, see :doc:`/tutorials/index`."
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:5
msgid "Package index mirrors and caches"
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:8
#: ../source/guides/supporting-multiple-python-versions.rst:10
msgid "2014-12-24"
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:11
msgid "Mirroring or caching of PyPI can be used to speed up local package installation, allow offline work, handle corporate firewalls or just plain Internet flakiness."
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:14
msgid "Three options are available in this area:"
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:16
msgid "pip provides local caching options,"
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:17
msgid "devpi provides higher-level caching option, potentially shared amongst many users or machines, and"
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:19
msgid "bandersnatch provides a local complete mirror of all PyPI :term:`packages <Distribution Package>`."
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:24
msgid "Caching with pip"
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:26
msgid "pip provides a number of facilities for speeding up installation by using local cached copies of :term:`packages <Distribution Package>`:"
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:29
msgid ":ref:`Fast & local installs <pip:installing from local packages>` by downloading all the requirements for a project and then pointing pip at those downloaded files instead of going to PyPI."
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:32
msgid "A variation on the above which pre-builds the installation files for the requirements using :ref:`python3 -m pip wheel <pip:pip wheel>`:"
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:42
msgid "Caching with devpi"
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:44
msgid "devpi is a caching proxy server which you run on your laptop, or some other machine you know will always be available to you. See the `devpi documentation for getting started`__."
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:52
msgid "Complete mirror with bandersnatch"
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:54
msgid "bandersnatch will set up a complete local mirror of all PyPI :term:`packages <Distribution Package>` (externally-hosted packages are not mirrored). See the `bandersnatch documentation for getting that going`__."
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:60
msgid "A benefit of devpi is that it will create a mirror which includes :term:`packages <Distribution Package>` that are external to PyPI, unlike bandersnatch which will only cache :term:`packages <Distribution Package>` hosted on PyPI."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:5
msgid "Installing scientific packages"
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:8
msgid "Scientific software tends to have more complex dependencies than most, and it will often have multiple build options to take advantage of different kinds of hardware, or to interoperate with different pieces of external software."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:13
msgid "In particular, `NumPy <https://numpy.org/>`__, which provides the basis for most of the software in the `scientific Python stack <https://scientific-python.org>`_ can be configured to interoperate with different FORTRAN libraries, and can take advantage of different levels of vectorised instructions available in modern CPUs."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:19
msgid "Starting with version 1.10.4 of NumPy and version 1.0.0 of SciPy, pre-built 32-bit and 64-bit binaries in the ``wheel`` format are available for all major operating systems (Windows, macOS, and Linux) on PyPI. Note, however, that on Windows, NumPy binaries are linked against the `ATLAS <http://www.netlib.org/atlas/>`__ BLAS/LAPACK library, restricted to SSE2 instructions, so they may not provide optimal linear algebra performance."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:26
msgid "There are a number of alternative options for obtaining scientific Python libraries (or any other Python libraries that require a compilation environment to install from source and don't provide pre-built wheel files on PyPI)."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:32
msgid "Building from source"
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:34
msgid "The same complexity which makes it difficult to distribute NumPy (and many of the projects that depend on it) as wheel files also make them difficult to build from source yourself. However, for intrepid folks that are willing to spend the time wrangling compilers and linkers for both C and FORTRAN, building from source is always an option."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:42
msgid "Linux distribution packages"
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:44
msgid "For Linux users, the system package manager will often have pre-compiled versions of various pieces of scientific software, including NumPy and other parts of the scientific Python stack."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:48
msgid "If using versions which may be several months old is acceptable, then this is likely to be a good option (just make sure to allow access to distributions installed into the system Python when using virtual environments)."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:54
msgid "Windows installers"
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:56
msgid "Many Python projects that don't (or can't) currently publish wheel files at least publish Windows installers, either on PyPI or on their project download page. Using these installers allows users to avoid the need to set up a suitable environment to build extensions locally."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:61
msgid "The extensions provided in these installers are typically compatible with the CPython Windows installers published on python.org."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:64
msgid "As with Linux system packages, the Windows installers will only install into a system Python installation - they do not support installation in virtual environments. Allowing access to distributions installed into the system Python when using virtual environments is a common approach to working around this limitation."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:70
msgid "The :term:`Wheel` project also provides a :command:`wheel convert` subcommand that can convert a Windows :command:`bdist_wininst` installer to a wheel."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:77
msgid "macOS installers and package managers"
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:79
msgid "Similar to the situation on Windows, many projects (including NumPy) publish macOS installers that are compatible with the macOS CPython binaries published on python.org."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:83
msgid "macOS users also have access to Linux distribution style package managers such as ``Homebrew``. The SciPy site has more details on using Homebrew to `install SciPy on macOS <https://scipy.org/install/#macos>`_."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:89
msgid "SciPy distributions"
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:91
msgid "The SciPy site lists `several distributions <https://scipy.org/install/#distributions>`_ that provide the full SciPy stack to end users in an easy to use and update format."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:96
msgid "Some of these distributions may not be compatible with the standard ``pip`` and ``virtualenv`` based toolchain."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:100
#: ../source/key_projects.rst:676
msgid "Spack"
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:101
msgid "`Spack <https://github.com/spack/spack>`_ is a flexible package manager designed to support multiple versions, configurations, platforms, and compilers. It was built to support the needs of large supercomputing centers and scientific application teams, who must often build software many different ways. Spack is not limited to Python; it can install packages for ``C``, ``C++``, ``Fortran``, ``R``, and other languages.  It is non-destructive; installing a new version of one package does not break existing installations, so many configurations can coexist on the same system."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:110
msgid "Spack offers a simple but powerful syntax that allows users to specify versions and configuration options concisely. Package files are written in pure Python, and they are templated so that it is easy to swap compilers, dependency implementations (like MPI), versions, and build options with a single package file.  Spack also generates *module* files so that packages can be loaded and unloaded from the user's environment."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:119
msgid "The conda cross-platform package manager"
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:121
msgid "`Anaconda <https://www.anaconda.com/products/individual/>`_ is a Python distribution published by Anaconda, Inc. It is a stable collection of Open Source packages for big data and scientific use.  As of the 5.0 release of Anaconda, about 200 packages are installed by default, and a total of 400-500 can be installed and updated from the Anaconda repository."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:127
msgid "``conda`` is an open source (BSD licensed) package management system and environment management system included in Anaconda that allows users to install multiple versions of binary software packages and their dependencies, and easily switch between them. It is a cross-platform tool working on Windows, macOS, and Linux. Conda can be used to package up and distribute all kinds of packages, it is not limited to just Python packages. It has full support for native virtual environments. Conda makes environments first-class citizens, making it easy to create independent environments even for C libraries. It is written in Python, but is Python-agnostic. Conda manages Python itself as a package, so that :command:`conda update python` is possible, in contrast to pip, which only manages Python packages. Conda is available in Anaconda and Miniconda (an easy-to-install download with just Python and conda)."
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:2
msgid "Installing stand alone command line tools"
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:4
msgid "Many packages provide command line applications. Examples of such packages are `mypy <https://github.com/python/mypy>`_, `flake8 <https://github.com/PyCQA/flake8>`_, `black <https://github.com/psf/black>`_, and :ref:`pipenv`."
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:10
msgid "Usually you want to be able to access these applications from anywhere on your system, but installing packages and their dependencies to the same global environment can cause version conflicts and break dependencies the operating system has on Python packages."
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:15
msgid ":ref:`pipx` solves this by creating a virtual environment for each package, while also ensuring that its applications are accessible through a directory that is on your ``$PATH``. This allows each package to be upgraded or uninstalled without causing conflicts with other packages, and allows you to safely run the applications from anywhere."
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:21
msgid "pipx only works with Python 3.6+."
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:23
msgid "pipx is installed with pip:"
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:41
msgid "``ensurepath`` ensures that the application directory is on your ``$PATH``. You may need to restart your terminal for this update to take effect."
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:44
msgid "Now you can install packages with ``pipx install`` and run the package's applications(s) from anywhere."
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:52
msgid "For example:"
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:74
msgid "To see a list of packages installed with pipx and which applications are available, use ``pipx list``:"
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:95
msgid "To upgrade or uninstall a package:"
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:102
msgid "pipx can be upgraded or uninstalled with pip:"
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:118
msgid "pipx also allows you to install and run the latest version of an application in a temporary, ephemeral environment. For example:"
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:125
msgid "To see the full list of commands pipx offers, run:"
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:131
msgid "You can learn more about pipx at https://pypa.github.io/pipx/."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:5
msgid "Installing pip/setuptools/wheel with Linux Package Managers"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:8
msgid "2021-07-26"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:10
msgid "This section covers how to install :ref:`pip`, :ref:`setuptools`, and :ref:`wheel` using Linux package managers."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:13
msgid "If you're using a Python that was downloaded from `python.org <https://www.python.org>`_, then this section does not apply.  See the :ref:`installing_requirements` section instead."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:17
msgid "Note that it's common for the versions of :ref:`pip`, :ref:`setuptools`, and :ref:`wheel` supported by a specific Linux Distribution to be outdated by the time it's released to the public, and updates generally only occur for security reasons, not for feature updates.  For certain Distributions, there are additional repositories that can be enabled to provide newer versions.  The repositories we know about are explained below."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:24
msgid "Also note that it's somewhat common for Distributions to apply patches for the sake of security and normalization to their own standards.  In some cases, this can lead to bugs or unexpected behaviors that vary from the original unpatched versions.  When this is known, we will make note of it below."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:31
msgid "Fedora"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:37
msgid "To learn more about Python in Fedora, please visit the `official Fedora docs`_, `Python Classroom`_ or `Fedora Loves Python`_."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:45
msgid "CentOS/RHEL"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:47
msgid "CentOS and RHEL don't offer :ref:`pip` or :ref:`wheel` in their core repositories, although :ref:`setuptools` is installed by default."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:50
msgid "To install pip and wheel for the system Python, there are two options:"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:52
msgid "Enable the `EPEL repository <https://fedoraproject.org/wiki/EPEL>`_ using `these instructions <https://docs.fedoraproject.org/en-US/epel/#how_can_i_use_these_extra_packages>`__. On EPEL 7, you can install pip and wheel like so:"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:61
msgid "Since EPEL only offers extra, non-conflicting packages, EPEL does not offer setuptools, since it's in the core repository."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:65
msgid "Enable the `PyPA Copr Repo <https://copr.fedorainfracloud.org/coprs/pypa/pypa/>`_ using `these instructions <https://fedoraproject.org/wiki/Infrastructure/Fedorahosted-retirement>`__ [1]_. You can install pip and wheel like so:"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:74
msgid "To additionally upgrade setuptools, run:"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:81
msgid "To install pip, wheel, and setuptools, in a parallel, non-system environment (using yum) then there are two options:"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:85
msgid "Use the \"Software Collections\" feature to enable a parallel collection that includes pip, setuptools, and wheel."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:88
msgid "For Redhat, see here: https://developers.redhat.com/products/softwarecollections/overview"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:90
msgid "For CentOS, see here: https://github.com/sclorg"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:92
msgid "Be aware that collections may not contain the most recent versions."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:94
msgid "Enable the `IUS repository <https://ius.io/setup>`_ and install one of the `parallel-installable <https://ius.io/usage#parallel-installable-packages>`_ Pythons, along with pip, setuptools, and wheel, which are kept fairly up to date."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:100
msgid "For example, for Python 3.4 on CentOS7/RHEL7:"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:108
msgid "openSUSE"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:118
msgid "Debian/Ubuntu and derivatives"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:120
msgid "Firstly, update and refresh repository lists by running this command:"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:129
msgid "Recent Debian/Ubuntu versions have modified pip to use the `\"User Scheme\" <https://pip.pypa.io/en/stable/user_guide/#user-installs>`_ by default, which is a significant behavior change that can be surprising to some users."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:135
msgid "Arch Linux"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:143
msgid "Currently, there is no \"copr\" yum plugin available for CentOS/RHEL, so the only option is to manually place the repo files as described."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:2
msgid "Install packages in a virtual environment using pip and venv"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:4
msgid "This guide discusses how to create and activate a virtual environment using the standard library's virtual environment tool :ref:`venv` and install packages. The guide covers how to:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:8
msgid "Create and activate a virtual environment"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:9
#: ../source/guides/installing-using-pip-and-virtual-environments.rst:152
msgid "Prepare pip"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:10
msgid "Install packages into a virtual environment using the ``pip`` command"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:11
msgid "Use and create a requirements file"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:14
msgid "This guide applies to supported versions of Python, currently 3.8 and higher."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:18
msgid "This guide uses the term **package** to refer to a :term:`Distribution Package`, which commonly is installed from an external host. This differs from the term :term:`Import Package` which refers to import modules in your Python source code."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:25
msgid "This guide has the prerequisite that you are using an official Python version obtained from <https://www.python.org/downloads/>. If you are using your operating system's package manager to install Python, please ensure that Python is installed before proceeding with these steps."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:32
msgid "Create and Use Virtual Environments"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:35
msgid "Create a new virtual environment"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:37
msgid ":ref:`venv` (for Python 3) allows you to manage separate package installations for different projects. It creates a \"virtual\" isolated Python installation. When you switch projects, you can create a new virtual environment which is isolated from other virtual environments. You benefit from the virtual environment since packages can be installed confidently and will not interfere with another project's environment."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:45
msgid "It is recommended to use a virtual environment when working with third party packages."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:48
msgid "To create a virtual environment, go to your project's directory and run ``venv``. This will create a new virtual environment in a local folder ``.venv``:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:63
msgid "The second argument is the location to create the virtual environment. Generally, you can just create this in your project and call it ``.venv``."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:66
msgid "``venv`` will create a virtual Python installation in the ``.venv`` folder."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:68
msgid "You should exclude your virtual environment directory from your version control system using ``.gitignore`` or similar."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:73
msgid "Activate a virtual environment"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:75
msgid "Before you can start installing or using packages in your virtual environment you'll need to ``activate`` it. Activating a virtual environment will put the virtual environment-specific ``python`` and ``pip`` executables into your shell's ``PATH``."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:92
msgid "To confirm the virtual environment is activated, check the location of your Python interpreter:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:107
msgid "While the virtual environment is active, the above command will output a filepath that includes the ``.venv`` directory, by ending with the following:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:123
msgid "While a virtual environment is activated, pip will install packages into that specific environment. This enables you to import and use packages in your Python application."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:129
msgid "Deactivate a virtual environment"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:131
msgid "If you want to switch projects or leave your virtual environment, ``deactivate`` the environment:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:139
msgid "Closing your shell will deactivate the virtual environment. If you open a new shell window and want to use the virtual environment, reactivate it."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:144
msgid "Reactivate a virtual environment"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:146
msgid "If you want to reactivate an existing virtual environment, follow the same instructions about activating a virtual environment. There's no need to create a new virtual environment."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:154
msgid ":ref:`pip` is the reference Python package manager. It's used to install and update packages into a virtual environment."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:160
msgid "The Python installers for macOS include pip. On Linux, you may have to install an additional package such as ``python3-pip``. You can make sure that pip is up-to-date by running:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:169
msgid "Afterwards, you should have the latest version of pip installed in your user site:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:178
msgid "The Python installers for Windows include pip. You can make sure that pip is up-to-date by running:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:186
msgid "Afterwards, you should have the latest version of pip:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:194
msgid "Install packages using pip"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:196
msgid "When your virtual environment is activated, you can install packages. Use the ``pip install`` command to install packages."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:200
msgid "Install a package"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:202
msgid "For example,let's install the `Requests`_ library from the :term:`Python Package Index (PyPI)`:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:217
msgid "pip should download requests and all of its dependencies and install them:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:238
msgid "Install a specific package version"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:240
msgid "pip allows you to specify which version of a package to install using :term:`version specifiers <Version Specifier>`. For example, to install a specific version of ``requests``:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:256
msgid "To install the latest ``2.x`` release of requests:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:270
msgid "To install pre-release versions of packages, use the ``--pre`` flag:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:286
msgid "Install extras"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:288
msgid "Some packages have optional `extras`_. You can tell pip to install these by specifying the extra in brackets:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:308
msgid "Install a package from source"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:310
msgid "pip can install a package directly from its source code. For example, to install the source code in the ``google-auth`` directory:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:327
msgid "Additionally, pip can install packages from source in :doc:`development mode <setuptools:userguide/development_mode>`, meaning that changes to the source directory will immediately affect the installed package without needing to re-install:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:346
msgid "Install from version control systems"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:348
msgid "pip can install packages directly from their version control system. For example, you can install directly from a git repository:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:355
msgid "For more information on supported version control systems and syntax, see pip's documentation on :ref:`VCS Support <pip:VCS Support>`."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:360
msgid "Install from local archives"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:362
msgid "If you have a local copy of a :term:`Distribution Package`'s archive (a zip, wheel, or tar file) you can install it directly with pip:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:377
msgid "If you have a directory containing archives of multiple packages, you can tell pip to look for packages there and not to use the :term:`Python Package Index (PyPI)` at all:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:393
msgid "This is useful if you are installing packages on a system with limited connectivity or if you want to strictly control the origin of distribution packages."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:399
msgid "Install from other package indexes"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:401
msgid "If you want to download packages from a different index than the :term:`Python Package Index (PyPI)`, you can use the ``--index-url`` flag:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:416
msgid "If you want to allow packages from both the :term:`Python Package Index (PyPI)` and a separate index, you can use the ``--extra-index-url`` flag instead:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:433
#: ../source/tutorials/installing-packages.rst:393
msgid "Upgrading packages"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:435
msgid "pip can upgrade packages in-place using the ``--upgrade`` flag. For example, to install the latest version of ``requests`` and all of its dependencies:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:451
msgid "Using a requirements file"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:453
msgid "Instead of installing packages individually, pip allows you to declare all dependencies in a :ref:`Requirements File <pip:Requirements Files>`. For example you could create a :file:`requirements.txt` file containing:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:462
msgid "And tell pip to install all of the packages in this file using the ``-r`` flag:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:477
msgid "Freezing dependencies"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:479
msgid "Pip can export a list of all installed packages and their versions using the ``freeze`` command:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:494
msgid "Which will output a list of package specifiers such as:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:510
msgid "The ``pip freeze`` command is useful for creating :ref:`pip:Requirements Files` that can re-create the exact versions of all packages installed in an environment."
msgstr ""

#: ../source/guides/installing-using-virtualenv.rst:2
msgid "Installing packages using virtualenv"
msgstr ""

#: ../source/guides/installing-using-virtualenv.rst:4
msgid "This guide discusses how to install packages using :ref:`pip` and :ref:`virtualenv`, a tool to create isolated Python environments."
msgstr ""

#: ../source/guides/installing-using-virtualenv.rst:8
msgid "This \"how to\" guide on installing packages and using :ref:`virtualenv` is under development. Please refer to the :ref:`virtualenv` documentation for details on installation and usage."
msgstr ""

#: ../source/guides/installing-using-virtualenv.rst:13
msgid "This doc uses the term **package** to refer to a :term:`Distribution Package`  which is different from an :term:`Import Package` that which is used to import modules in your Python source code."
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:2
msgid "Making a PyPI-friendly README"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:4
msgid "README files can help your users understand your project and can be used to set your project's description on PyPI. This guide helps you create a README in a PyPI-friendly format and include your README in your package so it appears on PyPI."
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:9
msgid "Creating a README file"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:11
msgid "README files for Python projects are often named ``README``, ``README.txt``, ``README.rst``, or ``README.md``."
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:13
msgid "For your README to display properly on PyPI, choose a markup language supported by PyPI. Formats supported by `PyPI's README renderer <https://github.com/pypa/readme_renderer>`_ are:"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:16
msgid "plain text"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:17
msgid "`reStructuredText <https://docutils.sourceforge.io/rst.html>`_ (without Sphinx extensions)"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:18
msgid "Markdown (`GitHub Flavored Markdown <https://github.github.com/gfm/>`_ by default, or `CommonMark <https://commonmark.org/>`_)"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:21
msgid "It's customary to save your README file in the root of your project, in the same directory as your :file:`setup.py` file."
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:25
msgid "Including your README in your package's metadata"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:27
msgid "To include your README's contents as your package description, set your project's ``Description`` and ``Description-Content-Type`` metadata, typically in your project's :file:`setup.py` file."
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:33
msgid ":ref:`description-optional`"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:34
msgid ":ref:`description-content-type-optional`"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:36
msgid "For example, to set these values in a package's :file:`setup.py` file, use ``setup()``'s ``long_description`` and ``long_description_content_type``."
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:39
msgid "Set the value of ``long_description`` to the contents (not the path) of the README file itself. Set the ``long_description_content_type`` to an accepted ``Content-Type``-style value for your README file's markup, such as ``text/plain``, ``text/x-rst`` (for reStructuredText), or ``text/markdown``."
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:45
msgid "If you're using GitHub-flavored Markdown to write a project's description, ensure you upgrade the following tools:"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:60
msgid "The minimum required versions of the respective tools are:"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:62
msgid "``setuptools >= 38.6.0``"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:63
msgid "``wheel >= 0.31.0``"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:64
msgid "``twine >= 1.11.0``"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:66
msgid "It's recommended that you use ``twine`` to upload the project's distribution packages:"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:72
msgid "For example, see this :file:`setup.py` file, which reads the contents of :file:`README.md` as ``long_description`` and identifies the markup as GitHub-flavored Markdown:"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:94
msgid "Validating reStructuredText markup"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:96
msgid "If your README is written in reStructuredText, any invalid markup will prevent it from rendering, causing PyPI to instead just show the README's raw source."
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:99
msgid "Note that Sphinx extensions used in docstrings, such as :doc:`directives <sphinx:usage/restructuredtext/directives>` and :doc:`roles <sphinx:usage/restructuredtext/roles>` (e.g., \"``:py:func:`getattr```\" or \"``:ref:`my-reference-label```\"), are not allowed here and will result in error messages like \"``Error: Unknown interpreted text role \"py:func\".``\"."
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:104
msgid "You can check your README for markup errors before uploading as follows:"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:106
msgid "Install the latest version of `twine <https://github.com/pypa/twine>`_; version 1.12.0 or higher is required:"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:121
msgid "Build the sdist and wheel for your project as described under :ref:`Packaging Your Project`."
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:124
msgid "Run ``twine check`` on the sdist and wheel:"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:130
msgid "This command will report any problems rendering your README.  If your markup renders fine, the command will output ``Checking distribution FILENAME: Passed``."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:6
msgid "Migrating to PyPI.org"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:8
#: ../source/guides/multi-version-installs.rst:8
#: ../source/guides/supporting-multiple-python-versions.rst:9
#: ../source/guides/supporting-windows-using-appveyor.rst:7
msgid "Obsolete"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:10
msgid ":term:`pypi.org` is the new, rewritten version of PyPI that has replaced the legacy PyPI code base. It is the default version of PyPI that people are expected to use. These are the tools and processes that people will need to interact with ``PyPI.org``."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:16
msgid "Publishing releases"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:18
msgid "``pypi.org`` is the default upload platform as of September 2016."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:20
msgid "Uploads through ``pypi.python.org`` were *switched off* on **July 3, 2017**. As of April 13th, 2018, ``pypi.org`` is the URL for PyPI."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:23
msgid "The recommended way to migrate to PyPI.org for uploading is to ensure that you are using a new enough version of your upload tool."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:26
msgid "The default upload settings switched to ``pypi.org`` in the following versions:"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:28
msgid "``twine`` 1.8.0"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:29
msgid "``setuptools`` 27.0.0"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:30
msgid "Python 2.7.13 (``distutils`` update)"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:31
msgid "Python 3.4.6 (``distutils`` update)"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:32
msgid "Python 3.5.3 (``distutils`` update)"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:33
msgid "Python 3.6.0 (``distutils`` update)"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:35
msgid "In addition to ensuring you're on a new enough version of the tool for the tool's default to have switched, you must also make sure that you have not configured the tool to override its default upload URL. Typically this is configured in a file located at :file:`$HOME/.pypirc`. If you see a file like:"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:52
msgid "Then simply delete the line starting with ``repository`` and you will use your upload tool's default URL."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:55
msgid "If for some reason you're unable to upgrade the version of your tool to a version that defaults to using PyPI.org, then you may edit :file:`$HOME/.pypirc` and include the ``repository:`` line, but use the value ``https://upload.pypi.org/legacy/`` instead:"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:71
msgid "(``legacy`` in this URL refers to the fact that this is the new server implementation's emulation of the legacy server implementation's upload API.)"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:77
msgid "Registering package names & metadata"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:79
msgid "Explicit pre-registration of package names with the ``setup.py register`` command prior to the first upload is no longer required, and is not currently supported by the legacy upload API emulation on PyPI.org."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:83
msgid "As a result, attempting explicit registration after switching to using PyPI.org for uploads will give the following error message::"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:88
msgid "The solution is to skip the registration step, and proceed directly to uploading artifacts."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:93
#: ../source/guides/using-testpypi.rst:5
msgid "Using TestPyPI"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:95
msgid "Legacy TestPyPI (testpypi.python.org) is no longer available; use `test.pypi.org <https://test.pypi.org>`_ instead. If you use TestPyPI, you must update your :file:`$HOME/.pypirc` to handle TestPyPI's new location, by replacing ``https://testpypi.python.org/pypi`` with ``https://test.pypi.org/legacy/``, for example:"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:117
msgid "Registering new user accounts"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:119
msgid "In order to help mitigate spam attacks against PyPI, new user registration through ``pypi.python.org`` was *switched off* on **February 20, 2018**. New user registrations at ``pypi.org`` are open."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:125
msgid "Browsing packages"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:127
msgid "While ``pypi.python.org`` is may still be used in links from other PyPA documentation, etc, the default interface for browsing packages is ``pypi.org``. The domain pypi.python.org now redirects to pypi.org, and may be disabled sometime in the future."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:134
msgid "Downloading packages"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:136
msgid "``pypi.org`` is the default host for downloading packages."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:139
msgid "Managing published packages and releases"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:141
msgid "``pypi.org`` provides a fully functional interface for logged in users to manage their published packages and releases."
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:6
msgid "How to modernize a ``setup.py`` based project?"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:10
msgid "Should ``pyproject.toml`` be added?"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:12
msgid "A :term:`pyproject.toml` file is strongly recommended. The presence of a :file:`pyproject.toml` file itself does not bring much. [#]_ What is actually strongly recommended is the ``[build-system]`` table in :file:`pyproject.toml`."
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:16
msgid "Note that it has influence on the build isolation feature of pip, see below."
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:23
msgid "No, :file:`setup.py` can exist in a modern :ref:`setuptools` based project. The :term:`setup.py` file is a valid configuration file for setuptools that happens to be written in Python. However, the following commands are deprecated and **MUST NOT** be run anymore, and their recommended replacement commands should be used instead:"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:30
msgid "Recommendation"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:36
msgid "``python -m build``"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:42
#: ../source/guides/modernize-setup-py-project.rst:66
#: ../source/guides/modernize-setup-py-project.rst:111
#: ../source/guides/modernize-setup-py-project.rst:129
#: ../source/guides/modernize-setup-py-project.rst:221
msgid "For more details:"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:44
msgid ":ref:`setup-py-deprecated`"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:48
msgid "Where to start?"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:50
msgid "The :term:`project` must contain a :file:`pyproject.toml` file at the root of its source tree that contains a ``[build-system]`` table like so:"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:60
msgid "This is the standardized method of letting :term:`build frontends <Build Frontend>` know that :ref:`setuptools` is the :term:`build backend <Build Backend>` for this project."
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:63
msgid "Note that the presence of a :file:`pyproject.toml` file (even if empty) triggers :ref:`pip` to change its default behavior to use *build isolation*."
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:68
msgid ":ref:`distributing-packages`"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:69
#: ../source/guides/modernize-setup-py-project.rst:113
#: ../source/guides/modernize-setup-py-project.rst:246
msgid ":ref:`declaring-build-dependencies`"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:70
#: ../source/guides/modernize-setup-py-project.rst:131
#: ../source/guides/modernize-setup-py-project.rst:248
msgid ":doc:`pip:reference/build-system/pyproject-toml`"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:74
msgid "How to handle additional build-time dependencies?"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:76
msgid "On top of setuptools itself, if :file:`setup.py` depends on other third-party libraries (outside of Python's standard library), those must be listed in the ``requires`` list of the ``[build-system]`` table, so that the build frontend knows to install them when building the :term:`distributions <Distribution Package>`."
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:82
#: ../source/guides/modernize-setup-py-project.rst:139
#: ../source/guides/modernize-setup-py-project.rst:174
msgid "For example, a :file:`setup.py` file such as this:"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:99
msgid "requires a :file:`pyproject.toml` file like this (:file:`setup.py` stays unchanged):"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:117
msgid "What is the build isolation feature?"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:119
msgid "Build frontends typically create an ephemeral virtual environment where they install only the build dependencies (and their dependencies) that are listed under ``build-system.requires`` and trigger the build in that environment."
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:124
msgid "For some projects this isolation is unwanted and it can be deactivated as follows:"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:126
msgid "``python -m build --no-isolation``"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:127
msgid "``python -m install --no-build-isolation``"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:135
msgid "How to handle packaging metadata?"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:137
msgid "All static metadata can optionally be moved to a ``[project]`` table in :file:`pyproject.toml`."
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:151
msgid "can be entirely replaced by a :file:`pyproject.toml` file like this:"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:164
msgid "Read :ref:`declaring-project-metadata` for the full specification of the content allowed in the ``[project]`` table."
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:169
msgid "How to handle dynamic metadata?"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:171
msgid "If some packaging metadata fields are not static they need to be listed as ``dynamic`` in this ``[project]`` table."
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:191
msgid "can be modernized as follows:"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:223
msgid ":ref:`declaring-project-metadata-dynamic`"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:227
msgid "What if something that can not be changed expects a ``setup.py`` file?"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:229
msgid "For example, a process exists that can not be changed easily and it needs to execute a command such as ``python setup.py --name``."
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:232
msgid "It is perfectly fine to leave a :file:`setup.py` file in the project source tree even after all its content has been moved to :file:`pyproject.toml`. This file can be as minimalistic as this:"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:247
msgid ":ref:`declaring-project-metadata`"
msgstr ""

#: ../source/guides/modernize-setup-py-project.rst:249
msgid ":doc:`setuptools:build_meta`"
msgstr ""

#: ../source/guides/multi-version-installs.rst:6
msgid "Multi-version installs"
msgstr ""

#: ../source/guides/multi-version-installs.rst:11
msgid "easy_install allows simultaneous installation of different versions of the same project into a single environment shared by multiple programs which must ``require`` the appropriate version of the project at run time (using ``pkg_resources``)."
msgstr ""

#: ../source/guides/multi-version-installs.rst:16
msgid "For many use cases, virtual environments address this need without the complication of the ``require`` directive. However, the advantage of parallel installations within the same environment is that it works for an environment shared by multiple applications, such as the system Python in a Linux distribution."
msgstr ""

#: ../source/guides/multi-version-installs.rst:22
msgid "The major limitation of ``pkg_resources`` based parallel installation is that as soon as you import ``pkg_resources`` it locks in the *default* version of everything which is already available on sys.path. This can cause problems, since ``setuptools`` created command line scripts use ``pkg_resources`` to find the entry point to execute. This means that, for example, you can't use ``require`` tests invoked through ``nose`` or a WSGI application invoked through ``gunicorn`` if your application needs a non-default version of anything that is available on the standard ``sys.path`` - the script wrapper for the main application will lock in the version that is available by default, so the subsequent ``require`` call in your own code fails with a spurious version conflict."
msgstr ""

#: ../source/guides/multi-version-installs.rst:34
msgid "This can be worked around by setting all dependencies in ``__main__.__requires__`` before importing ``pkg_resources`` for the first time, but that approach does mean that standard command line invocations of the affected tools can't be used - it's necessary to write a custom wrapper script or use ``python3 -c '<command>'`` to invoke the application's main entry point directly."
msgstr ""

#: ../source/guides/multi-version-installs.rst:41
msgid "Refer to the `pkg_resources documentation <https://setuptools.readthedocs.io/en/latest/pkg_resources.html#workingset-objects>`__ for more details."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:5
msgid "Packaging binary extensions"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:8
msgid "2013-12-08"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:10
msgid "One of the features of the CPython reference interpreter is that, in addition to allowing the execution of Python code, it also exposes a rich C API for use by other software. One of the most common uses of this C API is to create importable C extensions that allow things which aren't always easy to achieve in pure Python code."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:18
msgid "An overview of binary extensions"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:21
msgid "Use cases"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:23
msgid "The typical use cases for binary extensions break down into just three conventional categories:"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:26
msgid "**accelerator modules**: these modules are completely self-contained, and are created solely to run faster than the equivalent pure Python code runs in CPython. Ideally, accelerator modules will always have a pure Python equivalent to use as a fallback if the accelerated version isn't available on a given system. The CPython standard library makes extensive use of accelerator modules. *Example*: When importing ``datetime``, Python falls back to the `datetime.py <https://github.com/python/cpython/blob/main/Lib/datetime.py>`_ module if the C implementation ( `_datetimemodule.c <https://github.com/python/cpython/blob/main/Modules/_datetimemodule.c>`_) is not available."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:37
msgid "**wrapper modules**: these modules are created to expose existing C interfaces to Python code. They may either expose the underlying C interface directly, or else expose a more \"Pythonic\" API that makes use of Python language features to make the API easier to use. The CPython standard library makes extensive use of wrapper modules. *Example*: `functools.py <https://github.com/python/cpython/blob/main/Lib/functools.py>`_ is a Python module wrapper for `_functoolsmodule.c <https://github.com/python/cpython/blob/main/Modules/_functoolsmodule.c>`_."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:45
msgid "**low-level system access**: these modules are created to access lower level features of the CPython runtime, the operating system, or the underlying hardware. Through platform specific code, extension modules may achieve things that aren't possible in pure Python code. A number of CPython standard library modules are written in C in order to access interpreter internals that aren't exposed at the language level. *Example*: ``sys``, which comes from `sysmodule.c <https://github.com/python/cpython/blob/main/Python/sysmodule.c>`_."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:54
msgid "One particularly notable feature of C extensions is that, when they don't need to call back into the interpreter runtime, they can release CPython's global interpreter lock around long-running operations (regardless of whether those operations are CPU or IO bound)."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:59
msgid "Not all extension modules will fit neatly into the above categories. The extension modules included with NumPy, for example, span all three use cases - they move inner loops to C for speed reasons, wrap external libraries written in C, FORTRAN and other languages, and use low level system interfaces for both CPython and the underlying operation system to support concurrent execution of vectorised operations and to tightly control the exact memory layout of created objects."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:69
msgid "Disadvantages"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:71
msgid "The main disadvantage of using binary extensions is the fact that it makes subsequent distribution of the software more difficult. One of the advantages of using Python is that it is largely cross platform, and the languages used to write extension modules (typically C or C++, but really any language that can bind to the CPython C API) typically require that custom binaries be created for different platforms."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:78
msgid "This means that binary extensions:"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:80
msgid "require that end users be able to either build them from source, or else that someone publish pre-built binaries for common platforms"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:83
msgid "may not be compatible with different builds of the CPython reference interpreter"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:86
msgid "often will not work correctly with alternative interpreters such as PyPy, IronPython or Jython"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:89
msgid "if handcoded, make maintenance more difficult by requiring that maintainers be familiar not only with Python, but also with the language used to create the binary extension, as well as with the details of the CPython C API."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:94
msgid "if a pure Python fallback implementation is provided, make maintenance more difficult by requiring that changes be implemented in two places, and introducing additional complexity in the test suite to ensure both versions are always executed."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:99
msgid "Another disadvantage of relying on binary extensions is that alternative import mechanisms (such as the ability to import modules directly from zipfiles) often won't work for extension modules (as the dynamic loading mechanisms on most platforms can only load libraries from disk)."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:106
msgid "Alternatives to handcoded accelerator modules"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:108
msgid "When extension modules are just being used to make code run faster (after profiling has identified the code where the speed increase is worth additional maintenance effort), a number of other alternatives should also be considered:"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:113
msgid "look for existing optimised alternatives. The CPython standard library includes a number of optimised data structures and algorithms (especially in the builtins and the ``collections`` and ``itertools`` modules). The Python Package Index also offers additional alternatives. Sometimes, the appropriate choice of standard library or third party module can avoid the need to create your own accelerator module."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:120
msgid "for long running applications, the JIT compiled `PyPy interpreter <https://www.pypy.org/>`__ may offer a suitable alternative to the standard CPython runtime. The main barrier to adopting PyPy is typically reliance on other binary extension modules - while PyPy does emulate the CPython C API, modules that rely on that cause problems for the PyPy JIT, and the emulation layer can often expose latent defects in extension modules that CPython currently tolerates (frequently around reference counting errors - an object having one live reference instead of two often won't break anything, but no references instead of one is a major problem)."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:130
msgid "`Cython <https://cython.org/>`__ is a mature static compiler that can compile most Python code to C extension modules. The initial compilation provides some speed increases (by bypassing the CPython interpreter layer), and Cython's optional static typing features can offer additional opportunities for speed increases. Using Cython still carries the `disadvantages`_ associated with using binary extensions, but has the benefit of having a reduced barrier to entry for Python programmers (relative to other languages like C or C++)."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:139
msgid "`Numba <http://numba.pydata.org/>`__ is a newer tool, created by members of the scientific Python community, that aims to leverage LLVM to allow selective compilation of pieces of a Python application to native machine code at runtime. It requires that LLVM be available on the system where the code is running, but can provide significant speed increases, especially for operations that are amenable to vectorisation."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:148
msgid "Alternatives to handcoded wrapper modules"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:150
msgid "The C ABI (Application Binary Interface) is a common standard for sharing functionality between multiple applications. One of the strengths of the CPython C API (Application Programming Interface) is allowing Python users to tap into that functionality. However, wrapping modules by hand is quite tedious, so a number of other alternative approaches should be considered."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:156
msgid "The approaches described below don't simplify the distribution case at all, but they *can* significantly reduce the maintenance burden of keeping wrapper modules up to date."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:160
msgid "In addition to being useful for the creation of accelerator modules, `Cython <https://cython.org/>`__ is also widely used for creating wrapper modules for C or C++ APIs. It involves wrapping the interfaces by hand, which gives a wide range of freedom in designing and optimising the wrapper code, but may not be a good choice for wrapping very large APIs quickly. See the `list of third-party tools <https://github.com/cython/cython/wiki/AutoPxd>`_ for automatic wrapping with Cython. It also supports performance-oriented Python implementations that provide a CPython-like C-API, such as PyPy and Pyston."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:171
msgid ":doc:`pybind11 <pybind11:index>` is a pure C++11 library that provides a clean C++ interface to the CPython (and PyPy) C API. It does not require a pre-processing step; it is written entirely in templated C++. Helpers are included for Setuptools or CMake builds. It was based on `Boost.Python <https://www.boost.org/doc/libs/1_76_0/libs/python/doc/html/index.html>`__, but doesn't require the Boost libraries or BJam."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:178
msgid ":doc:`cffi <cffi:index>` is a project created by some of the PyPy developers to make it straightforward for developers that already know both Python and C to expose their C modules to Python applications. It also makes it relatively straightforward to wrap a C module based on its header files, even if you don't know C yourself."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:184
msgid "One of the key advantages of ``cffi`` is that it is compatible with the PyPy JIT, allowing CFFI wrapper modules to participate fully in PyPy's tracing JIT optimisations."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:188
msgid "`SWIG <http://www.swig.org/>`__ is a wrapper interface generator that allows a variety of programming languages, including Python, to interface with C and C++ code."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:192
msgid "The standard library's ``ctypes`` module, while useful for getting access to C level interfaces when header information isn't available, suffers from the fact that it operates solely at the C ABI level, and thus has no automatic consistency checking between the interface actually being exported by the library and the one declared in the Python code. By contrast, the above alternatives are all able to operate at the C *API* level, using C header files to ensure consistency between the interface exported by the library being wrapped and the one expected by the Python wrapper module. While ``cffi`` *can* operate directly at the C ABI level, it suffers from the same interface inconsistency problems as ``ctypes`` when it is used that way."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:206
msgid "Alternatives for low level system access"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:208
msgid "For applications that need low level system access (regardless of the reason), a binary extension module often *is* the best way to go about it. This is particularly true for low level access to the CPython runtime itself, since some operations (like releasing the Global Interpreter Lock) are simply invalid when the interpreter is running code, even if a module like ``ctypes`` or ``cffi`` is used to obtain access to the relevant C API interfaces."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:216
msgid "For cases where the extension module is manipulating the underlying operating system or hardware (rather than the CPython runtime), it may sometimes be better to just write an ordinary C library (or a library in another systems programming language like C++ or Rust that can export a C compatible ABI), and then use one of the wrapping techniques described above to make the interface available as an importable Python module."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:225
msgid "Implementing binary extensions"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:227
msgid "The CPython :doc:`Extending and Embedding <python:extending/index>` guide includes an introduction to writing a :doc:`custom extension module in C <python:extending/extending>`."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:231
msgid "FIXME: Elaborate that all this is one of the reasons why you probably *don't* want to handcode your extension modules :)"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:236
msgid "Extension module lifecycle"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:238
#: ../source/guides/packaging-binary-extensions.rst:244
#: ../source/guides/packaging-binary-extensions.rst:250
#: ../source/guides/packaging-binary-extensions.rst:256
#: ../source/guides/packaging-binary-extensions.rst:376
msgid "FIXME: This section needs to be fleshed out."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:242
msgid "Implications of shared static state and subinterpreters"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:248
msgid "Implications of the GIL"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:254
msgid "Memory allocation APIs"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:262
msgid "ABI Compatibility"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:264
msgid "The CPython C API does not guarantee ABI stability between minor releases (3.2, 3.3, 3.4, etc.). This means that, typically, if you build an extension module against one version of Python, it is only guaranteed to work with the same minor version of Python and not with any other minor versions."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:270
msgid "Python 3.2 introduced the Limited API, with is a well-defined subset of Python's C API. The symbols needed for the Limited API form the \"Stable ABI\" which is guaranteed to be compatible across all Python 3.x versions. Wheels containing extensions built against the stable ABI use the ``abi3`` ABI tag, to reflect that they're compatible with all Python 3.x versions."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:277
msgid "CPython's :doc:`C API stability<python:c-api/stable>` page provides detailed information about the API / ABI stability guarantees, how to use the Limited API and the exact contents of the \"Limited API\"."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:283
msgid "Building binary extensions"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:285
msgid "FIXME: Cover the build-backends available for building extensions."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:288
msgid "Building extensions for multiple platforms"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:290
msgid "If you plan to distribute your extension, you should provide :term:`wheels <Wheel>` for all the platforms you intend to support. These are usually built on continuous integration (CI) systems. There are tools to help you build highly redistributable binaries from CI; these include :ref:`cibuildwheel` and :ref:`multibuild`."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:296
msgid "For most extensions, you will need to build wheels for all the platforms you intend to support. This means that the number of wheels you need to build is the product of::"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:302
msgid "Using CPython's :ref:`Stable ABI <cpython-stable-abi>` can help significantly reduce the number of wheels you need to provide, since a single wheel on a platform can be used with all Python minor versions; eliminating one dimension of the matrix. It also removes the need to generate new wheels for each new minor version of Python."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:309
msgid "Binary extensions for Windows"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:311
msgid "Before it is possible to build a binary extension, it is necessary to ensure that you have a suitable compiler available. On Windows, Visual C is used to build the official CPython interpreter, and should be used to build compatible binary extensions.  To set up a build environment for binary extensions, install `Visual Studio Community Edition <https://visualstudio.microsoft.com/downloads/>`__ - any recent version is fine."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:318
msgid "One caveat: if you use Visual Studio 2019 or later, your extension will depend on an \"extra\" file, ``VCRUNTIME140_1.dll``, in addition to the ``VCRUNTIME140.dll`` that all previous versions back to 2015 depend on. This will add an extra requirement to using your extension on versions of CPython that do not include this extra file. To avoid this, you can add the compile-time argument ``/d2FH4-``. Recent versions of Python may include this file."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:326
msgid "Building for Python prior to 3.5 is discouraged, because older versions of Visual Studio are no longer available from Microsoft. If you do need to build for older versions, you can set ``DISTUTILS_USE_SDK=1`` and ``MSSdk=1`` to force a the currently activated version of MSVC to be found, and you should exercise care when designing your extension not to malloc/free memory across different libraries, avoid relying on changed data structures, and so on. Tools for generating extension modules usually avoid these things for you."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:337
msgid "Binary extensions for Linux"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:339
msgid "Linux binaries must use a sufficiently old glibc to be compatible with older distributions. The `manylinux <https://github.com/pypa/manylinux>`_ Docker images provide a build environment with a glibc old enough to support most current Linux distributions on common architectures."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:345
msgid "Binary extensions for macOS"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:347
msgid "Binary compatibility on macOS is determined by the target minimum deployment system, e.g. *10.9*, which is often specified with the ``MACOSX_DEPLOYMENT_TARGET`` environmental variable when building binaries on macOS. When building with setuptools / distutils, the deployment target is specified with the flag ``--plat-name``, e.g. ``macosx-10.9-x86_64``. For common deployment targets for macOS Python distributions, see the `MacPython Spinning Wheels wiki <https://github.com/MacPython/wiki/wiki/Spinning-wheels>`_."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:357
msgid "Publishing binary extensions"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:359
msgid "Publishing binary extensions through PyPI uses the same upload mechanisms as publishing pure Python packages. You build a wheel file for your extension using the build-backend and upload it to PyPI using :doc:`twine <twine:index>`."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:365
msgid "Avoid binary-only releases"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:367
msgid "It is strongly recommended that you publish your binary extensions as well as the source code that was used to build them. This allows users to build the extension from source if they need to. Notably, this is required for certain Linux distributions that build from source within their own build systems for the distro package repositories."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:374
msgid "Weak linking"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:379
msgid "Additional resources"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:381
msgid "Cross-platform development and distribution of extension modules is a complex topic, so this guide focuses primarily on providing pointers to various tools that automate dealing with the underlying technical challenges. The additional resources in this section are instead intended for developers looking to understand more about the underlying binary interfaces that those systems rely on at runtime."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:388
msgid "Cross-platform wheel generation with scikit-build"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:390
msgid "The `scikit-build <https://scikit-build.readthedocs.io/en/latest/>`_ package helps abstract cross-platform build operations and provides additional capabilities when creating binary extension packages. Additional documentation is also available on the `C runtime, compiler, and build system generator <https://scikit-build.readthedocs.io/en/latest/generators.html>`_ for Python binary extension modules."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:398
msgid "Introduction to C/C++ extension modules"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:400
msgid "For a more in depth explanation of how extension modules are used by CPython on a Debian system, see the following articles:"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:403
msgid "`What are (c)python extension modules? <https://thomasnyberg.com/what_are_extension_modules.html>`_"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:404
msgid "`Releasing the gil <https://thomasnyberg.com/releasing_the_gil.html>`_"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:405
msgid "`Writing cpython extension modules using C++ <https://thomasnyberg.com/cpp_extension_modules.html>`_"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:3
msgid "Packaging namespace packages"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:5
msgid "Namespace packages allow you to split the sub-packages and modules within a single :term:`package <Import Package>` across multiple, separate :term:`distribution packages <Distribution Package>` (referred to as **distributions** in this document to avoid ambiguity). For example, if you have the following package structure:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:24
msgid "And you use this package in your code like so::"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:29
msgid "Then you can break these sub-packages into two separate distributions:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:48
msgid "Each sub-package can now be separately installed, used, and versioned."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:50
msgid "Namespace packages can be useful for a large collection of loosely-related packages (such as a large corpus of client libraries for multiple products from a single company). However, namespace packages come with several caveats and are not appropriate in all cases. A simple alternative is to use a prefix on all of your distributions such as ``import mynamespace_subpackage_a`` (you could even use ``import mynamespace_subpackage_a as subpackage_a`` to keep the import object short)."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:60
msgid "Creating a namespace package"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:62
msgid "There are currently two different approaches to creating namespace packages, from which the latter is discouraged:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:65
msgid "Use `native namespace packages`_. This type of namespace package is defined in :pep:`420` and is available in Python 3.3 and later. This is recommended if packages in your namespace only ever need to support Python 3 and installation via ``pip``."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:69
msgid "Use `legacy namespace packages`_. This comprises `pkgutil-style namespace packages`_ and `pkg_resources-style namespace packages`_."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:73
msgid "Native namespace packages"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:75
msgid "Python 3.3 added **implicit** namespace packages from :pep:`420`. All that is required to create a native namespace package is that you just omit :file:`__init__.py` from the namespace package directory. An example file structure (following :ref:`src-layout <setuptools:src-layout>`):"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:92
msgid "It is extremely important that every distribution that uses the namespace package omits the :file:`__init__.py` or uses a pkgutil-style :file:`__init__.py`. If any distribution does not, it will cause the namespace logic to fail and the other sub-packages will not be importable."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:97
msgid "The ``src-layout`` directory structure allows automatic discovery of packages by most :term:`build backends <Build Backend>`. See :ref:`src-layout-vs-flat-layout` for more information. If however you want to manage exclusions or inclusions of packages yourself, this is possible to be configured in the top-level :file:`pyproject.toml`:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:115
msgid "The same can be accomplished with a :file:`setup.cfg`:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:127
msgid "Or :file:`setup.py`:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:140
msgid ":ref:`setuptools` will search the directory structure for implicit namespace packages by default."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:143
msgid "A complete working example of two native namespace packages can be found in the `native namespace package example project`_."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:149
msgid "Because native and pkgutil-style namespace packages are largely compatible, you can use native namespace packages in the distributions that only support Python 3 and pkgutil-style namespace packages in the distributions that need to support Python 2 and 3."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:156
msgid "Legacy namespace packages"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:158
msgid "These two methods, that were used to create namespace packages prior to :pep:`420`, are now considered to be obsolete and should not be used unless you need compatibility with packages already using this method. Also, :doc:`pkg_resources <setuptools:pkg_resources>` has been deprecated."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:163
msgid "To migrate an existing package, all packages sharing the namespace must be migrated simultaneously."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:165
msgid "While native namespace packages and pkgutil-style namespace packages are largely compatible, pkg_resources-style namespace packages are not compatible with the other methods. It's inadvisable to use different methods in different distributions that provide packages to the same namespace."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:172
msgid "pkgutil-style namespace packages"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:174
msgid "Python 2.3 introduced the :doc:`pkgutil <python:library/pkgutil>` module and the :py:func:`python:pkgutil.extend_path` function. This can be used to declare namespace packages that need to be compatible with both Python 2.3+ and Python 3. This is the recommended approach for the highest level of compatibility."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:179
msgid "To create a pkgutil-style namespace package, you need to provide an :file:`__init__.py` file for the namespace package:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:193
#: ../source/guides/packaging-namespace-packages.rst:240
msgid "The :file:`__init__.py` file for the namespace package needs to contain the following:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:200
#: ../source/guides/packaging-namespace-packages.rst:247
msgid "**Every** distribution that uses the namespace package must include such an :file:`__init__.py`. If any distribution does not, it will cause the namespace logic to fail and the other sub-packages will not be importable.  Any additional code in :file:`__init__.py` will be inaccessible."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:205
msgid "A complete working example of two pkgutil-style namespace packages can be found in the `pkgutil namespace example project`_."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:215
msgid "pkg_resources-style namespace packages"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:217
msgid ":doc:`Setuptools <setuptools:index>` provides the `pkg_resources.declare_namespace`_ function and the ``namespace_packages`` argument to :func:`~setuptools.setup`. Together these can be used to declare namespace packages. While this approach is no longer recommended, it is widely present in most existing namespace packages. If you are creating a new distribution within an existing namespace package that uses this method then it's recommended to continue using this as the different methods are not cross-compatible and it's not advisable to try to migrate an existing package."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:226
msgid "To create a pkg_resources-style namespace package, you need to provide an :file:`__init__.py` file for the namespace package:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:252
msgid "Some older recommendations advise the following in the namespace package :file:`__init__.py`:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:262
msgid "The idea behind this was that in the rare case that setuptools isn't available packages would fall-back to the pkgutil-style packages. This isn't advisable because pkgutil and pkg_resources-style namespace packages are not cross-compatible. If the presence of setuptools is a concern then the package should just explicitly depend on setuptools via ``install_requires``."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:269
msgid "Finally, every distribution must provide the ``namespace_packages`` argument to :func:`~setuptools.setup` in :file:`setup.py`. For example:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:283
msgid "A complete working example of two pkg_resources-style namespace packages can be found in the `pkg_resources namespace example project`_."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:3
msgid "Publishing package distribution releases using GitHub Actions CI/CD workflows"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:5
msgid "`GitHub Actions CI/CD`_ allows you to run a series of commands whenever an event occurs on the GitHub platform. One popular choice is having a workflow that's triggered by a ``push`` event. This guide shows you how to publish a Python distribution whenever a tagged commit is pushed. It will use the `pypa/gh-action-pypi-publish GitHub Action`_ for publishing. It also uses GitHub's `upload-artifact`_ and `download-artifact`_ actions for temporarily storing and downloading the source packages."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:17
msgid "This guide *assumes* that you already have a project that you know how to build distributions for and *it lives on GitHub*.  This guide also avoids details of building platform specific projects. If you have binary components, check out :ref:`cibuildwheel`'s GitHub Action examples."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:23
msgid "Configuring trusted publishing"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:25
msgid "This guide relies on PyPI's `trusted publishing`_ implementation to connect to `GitHub Actions CI/CD`_. This is recommended for security reasons, since the generated tokens are created for each of your projects individually and expire automatically. Otherwise, you'll need to generate an `API token`_ for both PyPI and TestPyPI. In case of publishing to third-party indexes like :doc:`devpi <devpi:index>`, you may need to provide a username/password combination."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:33
msgid "Since this guide will demonstrate uploading to both PyPI and TestPyPI, we'll need two trusted publishers configured. The following steps will lead you through creating the \"pending\" publishers for your new :term:`PyPI project <Project>`. However it is also possible to add `trusted publishing`_ to any pre-existing project, if you are its owner."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:42
msgid "If you followed earlier versions of this guide, you have created the secrets ``PYPI_API_TOKEN`` and ``TEST_PYPI_API_TOKEN`` for direct PyPI and TestPyPI access. These are obsolete now and you should remove them from your GitHub repository and revoke them in your PyPI and TestPyPI account settings in case you are replacing your old setup with the new one."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:49
msgid "Let's begin! 🚀"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:51
msgid "Go to https://pypi.org/manage/account/publishing/."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:52
msgid "Fill in the name you wish to publish your new :term:`PyPI project <Project>` under (the ``name`` value in your ``setup.cfg`` or ``pyproject.toml``), the GitHub repository owner's name (org or user), and repository name, and the name of the release workflow file under the ``.github/`` folder, see :ref:`workflow-definition`. Finally, add the name of the GitHub Environment (``pypi``) we're going set up under your repository. Register the trusted publisher."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:61
msgid "Now, go to https://test.pypi.org/manage/account/publishing/ and repeat the second step, but this time, enter ``testpypi`` as the name of the GitHub Environment."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:64
msgid "Your \"pending\" publishers are now ready for their first use and will create your projects automatically once you use them for the first time."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:70
msgid "If you don't have a TestPyPI account, you'll need to create it. It's not the same as a regular PyPI account."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:76
msgid "For security reasons, you must require `manual approval <https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment#deployment-protection-rules>`_ on each run for the ``pypi`` environment."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:83
msgid "Creating a workflow definition"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:85
msgid "GitHub CI/CD workflows are declared in YAML files stored in the ``.github/workflows/`` directory of your repository."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:88
msgid "Let's create a ``.github/workflows/publish-to-test-pypi.yml`` file."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:91
msgid "Start it with a meaningful name and define the event that should make GitHub run this workflow:"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:99
msgid "Checking out the project and building distributions"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:101
msgid "We will have to define two jobs to publish to PyPI and TestPyPI respectively, and an additional job to build the distribution packages."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:105
msgid "First, we'll define the job for building the dist packages of your project and storing them for later use:"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:113
msgid "This will download your repository into the CI runner and then install and activate the newest available Python 3 release."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:116
msgid "And now we can build the dists from source and store them. In this example, we'll use the ``build`` package. So add this to the steps list:"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:126
msgid "Defining a workflow job environment"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:128
msgid "Now, let's add initial setup for our job that will publish to PyPI. It's a process that will execute commands that we'll define later. In this guide, we'll use the latest stable Ubuntu LTS version provided by GitHub Actions. This also defines a GitHub Environment for the job to run in its context and a URL to be displayed in GitHub's UI nicely. Additionally, it allows acquiring an OpenID Connect token that the ``pypi-publish`` actions needs to implement secretless trusted publishing to PyPI."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:142
msgid "This will also ensure that the PyPI publishing workflow is only triggered if the current commit is tagged."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:146
msgid "Publishing the distribution to PyPI"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:148
msgid "Finally, add the following steps at the end:"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:155
msgid "This step uses the `pypa/gh-action-pypi-publish`_ GitHub Action: after the stored distribution package has been downloaded by the `download-artifact`_ action, it uploads the contents of the ``dist/`` folder into PyPI unconditionally."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:161
msgid "Signing the distribution packages"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:163
msgid "The following job signs the distribution packages with `Sigstore`_, the same artifact signing system `used to sign CPython <https://www.python.org/download/sigstore/>`_."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:166
msgid "Firstly, it uses the `sigstore/gh-action-sigstore-python GitHub Action`_ to sign the distribution packages. In the next step, an empty GitHub Release from the current tag is created using the ``gh`` CLI. Note this step can be further customised. See the `gh release documentation <https://cli.github.com/manual/gh_release>`_ as a reference."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:172
msgid "Finally, the signed distributions are uploaded to the GitHub Release."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:182
msgid "This is a replacement for GPG signatures, for which support has been `removed from PyPI <https://blog.pypi.org/posts/2023-05-23-removing-pgp/>`_. However, this job is not mandatory for uploading to PyPI and can be omitted."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:188
msgid "Separate workflow for publishing to TestPyPI"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:190
msgid "Now, repeat these steps and create another job for publishing to the TestPyPI package index under the ``jobs`` section:"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:200
msgid "Requiring manual approvals in the ``testpypi`` GitHub Environment is typically unnecessary as it's designed to run on each commit to the main branch and is often used to indicate a healthy release publishing pipeline."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:204
msgid "The whole CI/CD workflow"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:206
msgid "This paragraph showcases the whole workflow after following the above guide."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:214
msgid "That's all, folks!"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:216
msgid "Now, whenever you push a tagged commit to your Git repository remote on GitHub, this workflow will publish it to PyPI. And it'll publish any push to TestPyPI which is useful for providing test builds to your alpha users as well as making sure that your release pipeline remains healthy!"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:224
msgid "If your repository has frequent commit activity and every push is uploaded to TestPyPI as described, the project might exceed the `PyPI project size limit <https://pypi.org/help/#project-size-limit>`_. The limit could be increased, but a better solution may constitute to use a PyPI-compatible server like :ref:`pypiserver` in the CI for testing purposes."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:232
msgid "It is recommended to keep the integrated GitHub Actions at their latest versions, updating them frequently."
msgstr ""

#: ../source/guides/section-build-and-publish.rst:3
msgid "Building and Publishing"
msgstr ""

#: ../source/guides/section-hosting.rst:3
msgid "Hosting"
msgstr ""

#: ../source/guides/section-install.rst:3
msgid "Installation"
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:5
msgid "Single-sourcing the package version"
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:8
msgid "There are many techniques to maintain a single source of truth for the version number of your project:"
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:11
msgid "Read the file in :file:`setup.py` and get the version. Example (from `pip setup.py <https://github.com/pypa/pip/blob/main/setup.py>`_)::"
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:38
msgid "As of the release of setuptools 46.4.0, one can accomplish the same thing by instead placing the following in the project's :file:`setup.cfg` file (replacing \"package\" with the import name of the package):"
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:48
msgid "As of the release of setuptools 61.0.0, one can specify the version dynamically in the project's :file:`pyproject.toml` file."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:60
msgid "Please be aware that declarative config indicators, including the ``attr:`` directive, are not supported in parameters to :file:`setup.py`."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:64
msgid "Use an external build tool that either manages updating both locations, or offers an API that both locations can use."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:67
msgid "Few tools you could use, in no particular order, and not necessarily complete: `bump2version <https://pypi.org/project/bump2version>`_, `changes <https://pypi.org/project/changes>`_, `commitizen <https://pypi.org/project/commitizen>`_, `zest.releaser <https://pypi.org/project/zest.releaser>`_."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:74
msgid "Set the value to a ``__version__`` global variable in a dedicated module in your project (e.g. :file:`version.py`), then have :file:`setup.py` read and ``exec`` the value into a variable."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:85
msgid "Example using this technique: `warehouse <https://github.com/pypa/warehouse/blob/64ca42e42d5613c8339b3ec5e1cb7765c6b23083/warehouse/__about__.py>`_."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:87
msgid "Place the value in a simple ``VERSION`` text file and have both :file:`setup.py` and the project code read it."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:95
msgid "An advantage with this technique is that it's not specific to Python.  Any tool can read the version."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:100
msgid "With this approach you must make sure that the ``VERSION`` file is included in all your source and binary distributions (e.g. add ``include VERSION`` to your :file:`MANIFEST.in`)."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:104
msgid "Set the value in :file:`setup.py`, and have the project code use the ``importlib.metadata`` API to fetch the value at runtime. (``importlib.metadata`` was introduced in Python 3.8 and is available to older versions as the ``importlib-metadata`` project.)  An installed project's version can be fetched with the API as follows::"
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:119
msgid "Be aware that the ``importlib.metadata`` API only knows about what's in the installation metadata, which is not necessarily the code that's currently imported."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:123
msgid "If a project uses this method to fetch its version at runtime, then its ``install_requires`` value needs to be edited to install ``importlib-metadata`` on pre-3.8 versions of Python like so::"
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:137
msgid "An older (and less efficient) alternative to ``importlib.metadata`` is the ``pkg_resources`` API provided by ``setuptools``::"
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:143
msgid "If a project uses ``pkg_resources`` to fetch its own version at runtime, then ``setuptools`` must be added to the project's ``install_requires`` list."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:147
msgid "Example using this technique: `setuptools <https://github.com/pypa/setuptools/blob/main/setuptools/version.py>`_."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:150
msgid "Set the value to ``__version__`` in ``sample/__init__.py`` and import ``sample`` in :file:`setup.py`."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:164
msgid "Although this technique is common, beware that it will fail if ``sample/__init__.py`` imports packages from ``install_requires`` dependencies, which will very likely not be installed yet when :file:`setup.py` is run."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:170
msgid "Keep the version number in the tags of a version control system (Git, Mercurial, etc) instead of in the code, and automatically extract it from there using `setuptools_scm <https://pypi.org/project/setuptools-scm/>`_."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:7
msgid "Supporting multiple Python versions"
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:36
msgid "In addition to the work required to create a Python package, it is often necessary that the package must be made available on different versions of Python.  Different Python versions may contain different (or renamed) standard library packages, and the changes between Python versions 2.x and 3.x include changes in the language syntax."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:42
msgid "Performed manually, all the testing required to ensure that the package works correctly on all the target Python versions (and OSs!) could be very time-consuming. Fortunately, several tools are available for dealing with this, and these will briefly be discussed here."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:48
msgid "Automated testing and continuous integration"
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:50
msgid "Several hosted services for automated testing are available. These services will typically monitor your source code repository (e.g. at `GitHub <https://github.com>`_ or `Bitbucket <https://bitbucket.org>`_) and run your project's test suite every time a new commit is made."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:55
msgid "These services also offer facilities to run your project's test suite on *multiple versions of Python*, giving rapid feedback about whether the code will work, without the developer having to perform such tests themselves."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:59
msgid "Wikipedia has an extensive `comparison <https://en.wikipedia.org/wiki/Comparison_of_continuous_integration_software>`_ of many continuous-integration systems. There are two hosted services which when used in conjunction provide automated testing across Linux, Mac and Windows:"
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:65
msgid "`Travis CI <https://travis-ci.org>`_ provides both a Linux and a macOS environment. The Linux environment is Ubuntu 12.04 LTS Server Edition 64 bit while the macOS is 10.9.2 at the time of writing."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:68
msgid "`Appveyor <https://www.appveyor.com/>`_ provides a Windows environment (Windows Server 2012)."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:79
msgid "Both `Travis CI`_ and Appveyor_ require a `YAML <https://yaml.org>`_-formatted file as specification for the instructions for testing. If any tests fail, the output log for that specific configuration can be inspected."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:84
msgid "For Python projects that are intended to be deployed on both Python 2 and 3 with a single-source strategy, there are a number of options."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:88
msgid "Tools for single-source Python packages"
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:90
msgid "`six <https://pypi.org/project/six/>`_ is a tool developed by Benjamin Peterson for wrapping over the differences between Python 2 and Python 3. The six_ package has enjoyed widespread use and may be regarded as a reliable way to write a single-source Python module that can be use in both Python 2 and 3. The six_ module can be used from as early as Python 2.5. A tool called `modernize <https://pypi.org/project/modernize>`_, developed by Armin Ronacher, can be used to automatically apply the code modifications provided by six_."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:99
msgid "Similar to six_, `python-future <http://python-future.org/overview.html>`_ is a package that provides a compatibility layer between Python 2 and Python 3 source code; however, unlike six_, this package aims to provide interoperability between Python 2 and Python 3 with a language syntax that matches one of the two Python versions: one may use"
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:106
msgid "a Python 2 (by syntax) module in a Python 3 project."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:107
msgid "a Python 3 (by syntax) module in a *Python 2* project."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:109
msgid "Because of the bi-directionality, python-future_ offers a pathway to converting a Python 2 package to Python 3 syntax module-by-module. However, in contrast to six_, python-future_ is supported only from Python 2.6. Similar to modernize_ for six_, python-future_ comes with two scripts called ``futurize`` and ``pasteurize`` that can be applied to either a Python 2 module or a Python 3 module respectively."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:116
msgid "Use of six_ or python-future_ adds an additional runtime dependency to your package: with python-future_, the ``futurize`` script can be called with the ``--stage1`` option to apply only the changes that Python 2.6+ already provides for forward-compatibility to Python 3. Any remaining compatibility problems would require manual changes."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:123
msgid "What's in which Python?"
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:125
msgid "Ned Batchelder provides a list of changes in each Python release for `Python 2 <https://nedbatchelder.com/blog/201109/whats_in_which_python.html>`__, `Python 3.0-3.3 <https://nedbatchelder.com/blog/201310/whats_in_which_python_3.html>`__ and `Python 3.4-3.6 <https://nedbatchelder.com/blog/201803/whats_in_which_python_3436.html>`__. These lists may be used to check whether any changes between Python versions may affect your package."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:5
msgid "Supporting Windows using Appveyor"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:8
msgid "2015-12-03"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:10
msgid "This section covers how to use the free `Appveyor`_ continuous integration service to provide Windows support for your project. This includes testing the code on Windows, and building Windows-targeted binaries for projects that use C extensions."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:19
msgid "Many projects are developed on Unix by default, and providing Windows support can be a challenge, because setting up a suitable Windows test environment is non-trivial, and may require buying software licenses."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:23
msgid "The Appveyor service is a continuous integration service, much like the better-known `Travis`_ service that is commonly used for testing by projects hosted on `GitHub`_. However, unlike Travis, the build workers on Appveyor are Windows hosts and have the necessary compilers installed to build Python extensions."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:29
msgid "Windows users typically do not have access to a C compiler, and therefore are reliant on projects that use C extensions distributing binary wheels on PyPI in order for the distribution to be installable via ``python -m pip install <dist>``. By using Appveyor as a build service (even if not using it for testing) it is possible for projects without a dedicated Windows environment to provide Windows-targeted binaries."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:37
msgid "Setting up"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:39
msgid "In order to use Appveyor to build Windows wheels for your project, you must have an account on the service. Instructions on setting up an account are given in `the Appveyor documentation <https://www.appveyor.com/docs/>`__. The free tier of account is perfectly adequate for open source projects."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:44
msgid "Appveyor provides integration with `GitHub`_ and `Bitbucket`_, so as long as your project is hosted on one of those two services, setting up Appveyor integration is straightforward."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:48
msgid "Once you have set up your Appveyor account and added your project, Appveyor will automatically build your project each time a commit occurs. This behaviour will be familiar to users of Travis."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:53
msgid "Adding Appveyor support to your project"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:55
msgid "In order to define how Appveyor should build your project, you need to add an :file:`appveyor.yml` file to your project. The full details of what can be included in the file are covered in the Appveyor documentation. This guide will provide the details necessary to set up wheel builds."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:60
msgid "Appveyor includes by default all of the compiler toolchains needed to build extensions for Python. For Python 2.7, 3.5+ and 32-bit versions of 3.3 and 3.4, the tools work out of the box. But for 64-bit versions of Python 3.3 and 3.4, there is a small amount of additional configuration needed to let distutils know where to find the 64-bit compilers. (From 3.5 onwards, the version of Visual Studio used includes 64-bit compilers with no additional setup)."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:68
msgid "appveyor.yml"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:74
msgid "This file can be downloaded from `here <https://raw.githubusercontent.com/pypa/python-packaging-user-guide/master/source/guides/appveyor-sample/appveyor.yml>`__."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:76
msgid "The :file:`appveyor.yml` file must be located in the root directory of your project. It is in ``YAML`` format, and consists of a number of sections."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:79
msgid "The ``environment`` section is the key to defining the Python versions for which your wheels will be created. Appveyor comes with Python 2.6, 2.7, 3.3, 3.4 and 3.5 installed, in both 32-bit and 64-bit builds. The example file builds for all of these environments except Python 2.6. Installing for Python 2.6 is more complex, as it does not come with pip included. We don't support 2.6 in this document (as Windows users still using Python 2 are generally able to move to Python 2.7 without too much difficulty)."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:87
msgid "The ``install`` section uses pip to install any additional software that the project may require. The only requirement for building wheels is the ``wheel`` project, but projects may wish to customise this code in certain circumstances (for example, to install additional build packages such as ``Cython``, or test tools such as ``tox``)."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:93
msgid "The ``build`` section simply switches off builds - there is no build step needed for Python, unlike languages like ``C#``."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:96
msgid "The main sections that will need to be tailored to your project are ``test_script`` and ``after_test``."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:99
msgid "The ``test_script`` section is where you will run your project's tests. The supplied file runs your test suite using ``setup.py test``. If you are only interested in building wheels, and not in running your tests on Windows, you can replace this section with a dummy command such as ``echo Skipped Tests``. You may wish to use another test tool, such as ``nose`` or :file:`py.test`.  Or you may wish to use a test driver like ``tox`` - however if you are using ``tox`` there are some additional configuration changes you will need to consider, which are described below."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:108
msgid "The ``after_test`` runs once your tests have completed, and so is where the wheels should be built. Assuming your project uses the recommended tools (specifically, ``setuptools``) then the ``setup.py bdist_wheel`` command will build your wheels."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:113
msgid "Note that wheels will only be built if your tests succeed. If you expect your tests to fail on Windows, you can skip them as described above."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:118
msgid "Support script"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:120
msgid "The :file:`appveyor.yml` file relies on a single support script, which sets up the environment to use the SDK compiler for 64-bit builds on Python 3.3 and 3.4.  For projects which do not need a compiler, or which don't support 3.3 or 3.4 on 64-bit Windows, only the :file:`appveyor.yml` file is needed."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:125
msgid "`build.cmd <https://raw.githubusercontent.com/pypa/python-packaging-user-guide/master/source/guides/appveyor-sample/build.cmd>`__ is a Windows batch script that runs a single command in an environment with the appropriate compiler for the selected Python version. All you need to do is to set the single environment variable ``DISTUTILS_USE_SDK`` to a value of ``1`` and the script does the rest. It sets up the SDK needed for 64-bit builds of Python 3.3 or 3.4, so don't set the environment variable for any other builds."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:132
msgid "You can simply download the batch file and include it in your project unchanged."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:136
msgid "Access to the built wheels"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:138
msgid "When your build completes, the built wheels will be available from the Appveyor control panel for your project. They can be found by going to the build status page for each build in turn. At the top of the build output there is a series of links, one of which is \"Artifacts\". That page will include a list of links to the wheels for that Python version / architecture. You can download those wheels and upload them to PyPI as part of your release process."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:146
msgid "Additional notes"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:149
msgid "Testing with tox"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:151
msgid "Many projects use the :doc:`Tox <tox:index>` tool to run their tests. It ensures that tests are run in an isolated environment using the exact files that will be distributed by the project."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:155
msgid "In order to use ``tox`` on Appveyor there are a couple of additional considerations (in actual fact, these issues are not specific to Appveyor, and may well affect other CI systems)."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:159
msgid "By default, ``tox`` only passes a chosen subset of environment variables to the test processes. Because ``distutils`` uses environment variables to control the compiler, this \"test isolation\" feature will cause the tests to use the wrong compiler by default."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:164
msgid "To force ``tox`` to pass the necessary environment variables to the subprocess, you need to set the ``tox`` configuration option ``passenv`` to list the additional environment variables to be passed to the subprocess. For the SDK compilers, you need"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:169
msgid "``DISTUTILS_USE_SDK``"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:170
msgid "``MSSdk``"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:171
msgid "``INCLUDE``"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:172
msgid "``LIB``"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:174
msgid "The ``passenv`` option can be set in your :file:`tox.ini`, or if you prefer to avoid adding Windows-specific settings to your general project files, it can be set by setting the ``TOX_TESTENV_PASSENV`` environment variable. The supplied :file:`build.cmd` script does this by default whenever ``DISTUTILS_USE_SDK`` is set."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:180
msgid "When used interactively, ``tox`` allows you to run your tests against multiple environments (often, this means multiple Python versions). This feature is not as useful in a CI environment like Travis or Appveyor, where all tests are run in isolated environments for each configuration. As a result, projects often supply an argument ``-e ENVNAME`` to ``tox`` to specify which environment to use (there are default environments for most versions of Python)."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:187
msgid "However, this does *not* work well with a Windows CI system like Appveyor, where there are (for example) two installations of Python 3.4 (32-bit and 64-bit) available, but only one ``py34`` environment in ``tox``."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:191
msgid "In order to run tests using ``tox``, therefore, projects should probably use the default ``py`` environment in ``tox``, which uses the Python interpreter that was used to run ``tox``. This will ensure that when Appveyor runs the tests, they will be run with the configured interpreter."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:196
msgid "In order to support running under the ``py`` environment, it is possible that projects with complex ``tox`` configurations might need to modify their :file:`tox.ini` file. Doing so is, however, outside the scope of this document."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:202
msgid "Automatically uploading wheels"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:204
msgid "It is possible to request Appveyor to automatically upload wheels. There is a ``deployment`` step available in :file:`appveyor.yml` that can be used to (for example) copy the built artifacts to a FTP site, or an Amazon S3 instance. Documentation on how to do this is included in the Appveyor guides."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:209
msgid "Alternatively, it would be possible to add a ``twine upload`` step to the build.  The supplied :file:`appveyor.yml` does not do this, as it is not clear that uploading new wheels after every commit is desirable (although some projects may wish to do this)."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:215
msgid "External dependencies"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:217
msgid "The supplied scripts will successfully build any distribution that does not rely on 3rd party external libraries for the build."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:220
msgid "It is possible to add steps to the :file:`appveyor.yml` configuration (typically in the \"install\" section) to download and/or build external libraries needed by the distribution. And if needed, it is possible to add extra configuration for the build to supply the location of these libraries to the compiler. However, this level of configuration is beyond the scope of this document."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:229
msgid "Support scripts"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:231
msgid "For reference, the SDK setup support script is listed here:"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:233
msgid "``appveyor-sample/build.cmd``"
msgstr ""

#: ../source/guides/tool-recommendations.rst:5
msgid "Tool recommendations"
msgstr ""

#: ../source/guides/tool-recommendations.rst:7
msgid "If you're familiar with Python packaging and installation, and just want to know what tools are currently recommended, then here it is."
msgstr ""

#: ../source/guides/tool-recommendations.rst:12
msgid "Application dependency management"
msgstr ""

#: ../source/guides/tool-recommendations.rst:14
msgid "Use :ref:`pip` in a `secure manner`_ to install a Python application and its dependencies during deployment."
msgstr ""

#: ../source/guides/tool-recommendations.rst:17
msgid "Use :ref:`virtualenv` or :doc:`venv <python:library/venv>` to isolate application-specific dependencies from a shared Python installation. [4]_"
msgstr ""

#: ../source/guides/tool-recommendations.rst:20
msgid "Use `pip-tools`_, :ref:`pipenv`, or `poetry`_ to generate the fully-specified application-specific dependencies, when developing Python applications."
msgstr ""

#: ../source/guides/tool-recommendations.rst:28
msgid "Installation tool recommendations"
msgstr ""

#: ../source/guides/tool-recommendations.rst:30
msgid "Use :ref:`pip` to install Python :term:`packages <Distribution Package>` from :term:`PyPI <Python Package Index (PyPI)>`. [1]_ [2]_ Depending on how :ref:`pip` is installed, you may need to also install :ref:`wheel` to get the benefit of wheel caching. [3]_"
msgstr ""

#: ../source/guides/tool-recommendations.rst:35
msgid "Use :ref:`virtualenv` or :doc:`venv <python:library/venv>` to isolate project-specific dependencies from a shared Python installation. [4]_"
msgstr ""

#: ../source/guides/tool-recommendations.rst:38
msgid "If you're looking for management of fully integrated cross-platform software stacks, consider:"
msgstr ""

#: ../source/guides/tool-recommendations.rst:41
msgid ":ref:`buildout`: primarily focused on the web development community"
msgstr ""

#: ../source/guides/tool-recommendations.rst:43
msgid ":ref:`spack`, :ref:`hashdist`, or :ref:`conda`: primarily focused on the scientific community."
msgstr ""

#: ../source/guides/tool-recommendations.rst:48
msgid "Packaging tool recommendations"
msgstr ""

#: ../source/guides/tool-recommendations.rst:50
msgid "Use :ref:`setuptools` to define projects. [5]_ [6]_"
msgstr ""

#: ../source/guides/tool-recommendations.rst:52
msgid "Use :ref:`build` to create :term:`Source Distributions <Source Distribution (or \"sdist\")>` and :term:`wheels <Wheel>`."
msgstr ""

#: ../source/guides/tool-recommendations.rst:55
msgid "If you have binary extensions and want to distribute wheels for multiple platforms, use :ref:`cibuildwheel` as part of your CI setup to build distributable wheels."
msgstr ""

#: ../source/guides/tool-recommendations.rst:59
msgid "Use `twine <https://pypi.org/project/twine>`_ for uploading distributions to :term:`PyPI <Python Package Index (PyPI)>`."
msgstr ""

#: ../source/guides/tool-recommendations.rst:64
msgid "Publishing platform migration"
msgstr ""

#: ../source/guides/tool-recommendations.rst:66
msgid "The original Python Package Index implementation (previously hosted at `pypi.python.org <https://pypi.python.org>`_) has been phased out in favour of an updated implementation hosted at `pypi.org <https://pypi.org>`_."
msgstr ""

#: ../source/guides/tool-recommendations.rst:70
msgid "See :ref:`Migrating to PyPI.org` for more information on the status of the migration, and what settings to change in your clients."
msgstr ""

#: ../source/guides/tool-recommendations.rst:75
msgid "There are some cases where you might choose to use ``easy_install`` (from :ref:`setuptools`), e.g. if you need to install from :term:`Eggs <Egg>` (which pip doesn't support).  For a detailed breakdown, see :ref:`pip vs easy_install`."
msgstr ""

#: ../source/guides/tool-recommendations.rst:80
msgid "The acceptance of :pep:`453` means that :ref:`pip` will be available by default in most installations of Python 3.4 or later.  See the :pep:`rationale section <453#rationale>` from :pep:`453` as for why pip was chosen."
msgstr ""

#: ../source/guides/tool-recommendations.rst:85
msgid "`get-pip.py <https://github.com/pypa/get-pip/#readme>`_ and :ref:`virtualenv` install :ref:`wheel`, whereas :ref:`ensurepip` and :ref:`venv <venv>` do not currently.  Also, the common \"python-pip\" package that's found in various linux distros, does not depend on \"python-wheel\" currently."
msgstr ""

#: ../source/guides/tool-recommendations.rst:91
msgid "Beginning with Python 3.4, ``venv`` will create virtualenv environments with ``pip`` installed, thereby making it an equal alternative to :ref:`virtualenv`. However, using :ref:`virtualenv` will still be recommended for users that need cross-version consistency."
msgstr ""

#: ../source/guides/tool-recommendations.rst:96
msgid "Although you can use pure :ref:`distutils` for many projects, it does not support defining dependencies on other projects and is missing several convenience utilities for automatically populating distribution metadata correctly that are provided by ``setuptools``. Being outside the standard library, ``setuptools`` also offers a more consistent feature set across different versions of Python, and (unlike ``distutils``), recent versions of ``setuptools`` support all of the modern metadata fields described in :ref:`core-metadata`."
msgstr ""

#: ../source/guides/tool-recommendations.rst:105
msgid "Even for projects that do choose to use ``distutils``, when :ref:`pip` installs such projects directly from source (rather than installing from a prebuilt :term:`wheel <Wheel>` file), it will actually build your project using :ref:`setuptools` instead."
msgstr ""

#: ../source/guides/tool-recommendations.rst:110
msgid "`distribute`_ (a fork of setuptools) was merged back into :ref:`setuptools` in June 2013, thereby making setuptools the default choice for packaging."
msgstr ""

#: ../source/guides/using-manifest-in.rst:5
msgid "Including files in source distributions with ``MANIFEST.in``"
msgstr ""

#: ../source/guides/using-manifest-in.rst:7
msgid "The information on this page has moved to :doc:`setuptools:userguide/miscellaneous` in the setuptools documentation."
msgstr ""

#: ../source/guides/using-testpypi.rst:7
msgid "``TestPyPI`` is a separate instance of the :term:`Python Package Index (PyPI)` that allows you to try out the distribution tools and process without worrying about affecting the real index. TestPyPI is hosted at `test.pypi.org <https://test.pypi.org>`_"
msgstr ""

#: ../source/guides/using-testpypi.rst:13
msgid "Registering your account"
msgstr ""

#: ../source/guides/using-testpypi.rst:15
msgid "Because TestPyPI has a separate database from the live PyPI, you'll need a separate user account specifically for TestPyPI. Go to https://test.pypi.org/account/register/ to register your account."
msgstr ""

#: ../source/guides/using-testpypi.rst:19
msgid "The database for TestPyPI may be periodically pruned, so it is not unusual for user accounts to be deleted."
msgstr ""

#: ../source/guides/using-testpypi.rst:24
msgid "Using TestPyPI with Twine"
msgstr ""

#: ../source/guides/using-testpypi.rst:26
msgid "You can upload your distributions to TestPyPI using :ref:`twine` by specifying the ``--repository`` flag:"
msgstr ""

#: ../source/guides/using-testpypi.rst:33
msgid "You can see if your package has successfully uploaded by navigating to the URL ``https://test.pypi.org/project/<sampleproject>`` where ``sampleproject`` is the name of your project that you uploaded. It may take a minute or two for your project to appear on the site."
msgstr ""

#: ../source/guides/using-testpypi.rst:39
msgid "Using TestPyPI with pip"
msgstr ""

#: ../source/guides/using-testpypi.rst:41
msgid "You can tell :ref:`pip` to download packages from TestPyPI instead of PyPI by specifying the ``--index-url`` flag:"
msgstr ""

#: ../source/guides/using-testpypi.rst:56
msgid "If you want to allow pip to also download packages from PyPI, you can specify ``--extra-index-url`` to point to PyPI. This is useful when the package you're testing has dependencies:"
msgstr ""

#: ../source/guides/using-testpypi.rst:73
msgid "Setting up TestPyPI in :file:`.pypirc`"
msgstr ""

#: ../source/guides/using-testpypi.rst:75
msgid "If you want to avoid entering your username, you can configure TestPyPI in your :file:`$HOME/.pypirc`:"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:5
msgid "Writing your ``pyproject.toml``"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:7
msgid "``pyproject.toml`` is a configuration file used by packaging tools, as well as other tools such as linters, type checkers, etc. There are three possible TOML tables in this file."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:11
msgid "The ``[build-system]`` table is **strongly recommended**. It allows you to declare which :term:`build backend` you use and which other dependencies are needed to build your project."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:15
msgid "The ``[project]`` table is the format that most build backends use to specify your project's basic metadata, such as the dependencies, your name, etc."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:18
msgid "The ``[tool]`` table has tool-specific subtables, e.g., ``[tool.hatch]``, ``[tool.black]``, ``[tool.mypy]``. We only touch upon this table here because its contents are defined by each tool. Consult the particular tool's documentation to know what it can contain."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:25
msgid "There is a significant difference between the ``[build-system]`` and ``[project]`` tables. The former should always be present, regardless of which build backend you use (since it *defines* the tool you use). The latter is understood by *most* build backends, but some build backends use a different format."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:31
msgid "At the time of writing this (November 2023), Poetry_ is a notable build backend that does not use the ``[project]`` table (it uses the ``[tool.poetry]`` table instead)."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:35
msgid "Also, the setuptools_ build backend supports both the ``[project]`` table, and the older format in ``setup.cfg`` or ``setup.py``. For new projects, it is recommended to use the ``[project]`` table, and keep ``setup.py`` only if some programmatic configuration is needed (such as building C extensions), but the ``setup.cfg`` and ``setup.py`` formats are still valid. See :ref:`setup-py-deprecated`."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:45
msgid "Declaring the build backend"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:47
msgid "The ``[build-system]`` table contains a ``build-backend`` key, which specifies the build backend to be used. It also contains a ``requires`` key, which is a list of dependencies needed to build the project -- this is typically just the build backend package, but it may also contain additional dependencies. You can also constrain the versions, e.g., ``requires = [\"setuptools >= 61.0\"]``."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:53
msgid "Usually, you'll just copy what your build backend's documentation suggests (after :ref:`choosing your build backend <choosing-build-backend>`). Here are the values for some common build backends:"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:92
msgid "Static vs. dynamic metadata"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:94
msgid "The rest of this guide is devoted to the ``[project]`` table."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:96
msgid "Most of the time, you will directly write the value of a ``[project]`` field. For example: ``requires-python = \">= 3.8\"``, or ``version = \"1.0\"``."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:100
msgid "However, in some cases, it is useful to let your build backend compute the metadata for you. For example: many build backends can read the version from a ``__version__`` attribute in your code, a Git tag, or similar. In such cases, you should mark the field as dynamic using, e.g.,"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:111
msgid "When a field is dynamic, it is the build backend's responsibility to fill it.  Consult your build backend's documentation to learn how it does it."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:117
msgid "Basic information"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:122
msgid "Put the name of your project on PyPI. This field is required and is the only field that cannot be marked as dynamic."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:134
msgid "Put the version of your project."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:141
msgid "Some more complicated version specifiers like ``2020.0.0a1`` (for an alpha release) are possible; see the :ref:`specification <version-specifiers>` for full details."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:145
msgid "This field is required, although it is often marked as dynamic using"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:155
msgid "Dependencies and requirements"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:158
#: ../source/specifications/declaring-project-metadata.rst:275
msgid "``dependencies``/``optional-dependencies``"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:160
msgid "If your project has dependencies, list them like this:"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:172
msgid "See :ref:`Dependency specifiers <dependency-specifiers>` for the full syntax you can use to constrain versions."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:175
msgid "You may want to make some of your dependencies optional, if they are only needed for a specific feature of your package. In that case, put them in ``optional-dependencies``."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:188
msgid "Each of the keys defines a \"packaging extra\". In the example above, one could use, e.g., ``pip install your-project-name[gui]`` to install your project with GUI support, adding the PyQt5 dependency."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:194
#: ../source/specifications/declaring-project-metadata.rst:66
#: ../source/specifications/declaring-project-metadata.rst:147
msgid "``requires-python``"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:196
msgid "This lets you declare the minimum version of Python that you support [#requires-python-upper-bounds]_."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:207
msgid "Creating executable scripts"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:209
msgid "To install a command as part of your package, declare it in the ``[project.scripts]`` table."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:217
msgid "In this example, after installing your project, a ``spam-cli`` command will be available. Executing this command will do the equivalent of ``from spam import main_cli; main_cli()``."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:221
msgid "On Windows, scripts packaged this way need a terminal, so if you launch them from within a graphical application, they will make a terminal pop up. To prevent this from happening, use the ``[project.gui-scripts]`` table instead of ``[project.scripts]``."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:231
msgid "In that case, launching your script from the command line will give back control immediately, leaving the script to run in the background."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:234
msgid "The difference between ``[project.scripts]`` and ``[project.gui-scripts]`` is only relevant on Windows."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:240
msgid "About your project"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:243
#: ../source/specifications/declaring-project-metadata.rst:172
msgid "``authors``/``maintainers``"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:245
msgid "Both of these fields contain lists of people identified by a name and/or an email address."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:265
msgid "This should be a one-line description of your project, to show as the \"headline\" of your project page on PyPI (`example <pypi-pip_>`_)."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:275
#: ../source/specifications/declaring-project-metadata.rst:65
#: ../source/specifications/declaring-project-metadata.rst:108
msgid "``readme``"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:277
msgid "This is a longer description of your project, to display on your project page on PyPI. Typically, your project will have a ``README.md`` or ``README.rst`` file and you just put its file name here."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:286
msgid "The README's format is auto-detected from the extension:"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:288
msgid "``README.md`` → Markdown,"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:289
msgid "``README.rst`` → reStructuredText (without Sphinx extensions)."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:291
msgid "You can also specify the format explicitly, like this:"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:304
msgid "This can take two forms. You can put your license in a file, typically ``LICENSE`` or ``LICENSE.txt``, and link that file here:"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:312
msgid "or you can write the name of the license:"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:325
msgid "This will help PyPI's search box to suggest your project when people search for these keywords."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:337
msgid "A list of PyPI classifiers that apply to your project. Check the `full list of possibilities <classifier-list_>`_."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:349
#: ../source/specifications/declaring-project-metadata.rst:68
#: ../source/specifications/declaring-project-metadata.rst:234
msgid "``urls``"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:351
msgid "A list of URLs associated with your project, displayed on the left sidebar of your PyPI project page."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:363
msgid "Note that if the key contains spaces, it needs to be quoted, e.g., ``Website = \"https://example.com\"`` but ``\"Official Website\" = \"https://example.com\"``."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:370
msgid "Advanced plugins"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:372
msgid "Some packages can be extended through plugins. Examples include Pytest_ and Pygments_. To create such a plugin, you need to declare it in a subtable of ``[project.entry-points]`` like this:"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:381
msgid "See the :ref:`Plugin guide <plugin-entry-points>` for more information."
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:386
msgid "A full example"
msgstr ""

#: ../source/guides/writing-pyproject-toml.rst:448
msgid "Think twice before applying an upper bound like ``requires-python = \"<= 3.10\"`` here. `This blog post <requires-python-blog-post_>`_ contains some information regarding possible problems."
msgstr ""

#: ../source/index.rst:-1
msgid "The Python Packaging User Guide (PyPUG) is a collection of tutorials and guides for packaging Python software."
msgstr ""

#: ../source/index.rst:-1
msgid "python, packaging, guide, tutorial"
msgstr ""

#: ../source/index.rst:3
#: ../source/key_projects.rst:245
msgid "Python Packaging User Guide"
msgstr ""

#: ../source/index.rst:25
msgid "Welcome to the *Python Packaging User Guide*, a collection of tutorials and references to help you distribute and install Python packages with modern tools."
msgstr ""

#: ../source/index.rst:29
msgid "This guide is maintained on `GitHub`_ by the :doc:`Python Packaging Authority <pypa:index>`. We happily accept :doc:`contributions and feedback <contribute>`. 😊"
msgstr ""

#: ../source/index.rst:36
msgid "Overview and Flow"
msgstr ""

#: ../source/index.rst:40
msgid "Building your understanding of Python packaging is a journey. Patience and continuous improvement are key to success. The overview and flow sections provide a starting point for understanding the Python packaging ecosystem."
msgstr ""

#: ../source/index.rst:44
msgid "The :doc:`overview` explains Python packaging and its use when preparing and distributing projects. This section helps you build understanding about selecting the tools and processes that are most suitable for your use case. It includes what packaging is, the problems that it solves, and key considerations."
msgstr ""

#: ../source/index.rst:51
msgid "To get an overview of the workflow used to publish your code, see :doc:`packaging flow <flow>`."
msgstr ""

#: ../source/index.rst:57
msgid "Tutorials walk through the steps needed to complete a project for the first time. Tutorials aim to help you succeed and provide a starting point for future exploration. The :doc:`tutorials/index` section includes:"
msgstr ""

#: ../source/index.rst:62
msgid "A :doc:`tutorial on installing packages <tutorials/installing-packages>`"
msgstr ""

#: ../source/index.rst:63
msgid "A :doc:`tutorial on managing application dependencies <tutorials/managing-dependencies>` in a version controlled project"
msgstr ""

#: ../source/index.rst:65
msgid "A :doc:`tutorial on packaging and distributing <tutorials/packaging-projects>` your project"
msgstr ""

#: ../source/index.rst:71
msgid "Guides provide steps to perform a specific task. Guides are more focused on users who are already familiar with Python packaging and are looking for specific information."
msgstr ""

#: ../source/index.rst:75
msgid "The :doc:`guides/index` section provides \"how to\" instructions in three major areas: package installation; building and distributing packages; miscellaneous topics."
msgstr ""

#: ../source/index.rst:80
msgid "Explanations and Discussions"
msgstr ""

#: ../source/index.rst:82
msgid "The :doc:`discussions/index` section for in-depth explanations and discussion about topics, such as:"
msgstr ""

#: ../source/index.rst:85
msgid ":doc:`discussions/deploying-python-applications`"
msgstr ""

#: ../source/index.rst:86
msgid ":doc:`discussions/pip-vs-easy-install`"
msgstr ""

#: ../source/index.rst:89
msgid "Reference"
msgstr ""

#: ../source/index.rst:91
msgid "The :doc:`specifications/index` section for packaging interoperability specifications."
msgstr ""

#: ../source/index.rst:92
msgid "The list of :doc:`other projects <key_projects>` maintained by members of the Python Packaging Authority."
msgstr ""

#: ../source/index.rst:93
msgid "The :doc:`glossary` for definitions of terms used in Python packaging."
msgstr ""

#: ../source/key_projects.rst:6
msgid "Project Summaries"
msgstr ""

#: ../source/key_projects.rst:8
msgid "Summaries and links for the most relevant projects in the space of Python installation and packaging."
msgstr ""

#: ../source/key_projects.rst:14
msgid "PyPA Projects"
msgstr ""

#: ../source/key_projects.rst:19
msgid "bandersnatch"
msgstr ""

#: ../source/key_projects.rst:21
msgid "`Issues <https://github.com/pypa/bandersnatch/issues>`__ | `GitHub <https://github.com/pypa/bandersnatch>`__ | `PyPI <https://pypi.org/project/bandersnatch>`__"
msgstr ""

#: ../source/key_projects.rst:25
msgid "``bandersnatch`` is a PyPI mirroring client designed to efficiently create a complete mirror of the contents of PyPI. Organizations thus save bandwidth and latency on package downloads (especially in the context of automated tests) and to prevent heavily loading PyPI's Content Delivery Network (CDN)."
msgstr ""

#: ../source/key_projects.rst:35
msgid "build"
msgstr ""

#: ../source/key_projects.rst:37
msgid ":any:`Docs <build:index>` | `Issues <https://github.com/pypa/build/issues>`__ | `GitHub <https://github.com/pypa/build>`__ | `PyPI <https://pypi.org/project/build>`__"
msgstr ""

#: ../source/key_projects.rst:42
msgid "``build`` is a :pep:`517` compatible Python package builder. It provides a CLI to build packages, as well as a Python API."
msgstr ""

#: ../source/key_projects.rst:49
msgid "cibuildwheel"
msgstr ""

#: ../source/key_projects.rst:51
msgid "`Docs <https://cibuildwheel.readthedocs.io/>`__ | `Issues <https://github.com/pypa/cibuildwheel/issues>`__ | `GitHub <https://github.com/pypa/cibuildwheel>`__ | `PyPI <https://pypi.org/project/cibuildwheel>`__ | `Discussions <https://github.com/pypa/cibuildwheel/discussions>`__ | `Discord #cibuildwheel <https://discord.com/invite/pypa>`__"
msgstr ""

#: ../source/key_projects.rst:58
msgid "``cibuildwheel`` is a Python package that builds :term:`wheels <Wheel>` for all common platforms and Python versions on most CI systems. Also see :ref:`multibuild`."
msgstr ""

#: ../source/key_projects.rst:64
msgid "distlib"
msgstr ""

#: ../source/key_projects.rst:66
msgid ":doc:`Docs <distlib:index>` | `Issues <https://github.com/pypa/distlib/issues>`__ | `GitHub <https://github.com/pypa/distlib>`__ | `PyPI <https://pypi.org/project/distlib>`__"
msgstr ""

#: ../source/key_projects.rst:71
msgid "``distlib`` is a library which implements low-level functions that relate to packaging and distribution of Python software.  ``distlib`` implements several relevant PEPs (Python Enhancement Proposal standards) and is useful for developers of third-party packaging tools to make and upload binary and source :term:`distributions <Distribution Package>`, achieve interoperability, resolve dependencies, manage package resources, and do other similar functions."
msgstr ""

#: ../source/key_projects.rst:80
msgid "Unlike the stricter :ref:`packaging` project (below), which specifically implements modern Python packaging interoperability standards, ``distlib`` also attempts to provide reasonable fallback behaviours when asked to handle legacy packages and metadata that predate the modern interoperability standards and fall into the subset of packages that are incompatible with those standards."
msgstr ""

#: ../source/key_projects.rst:91
msgid "distutils"
msgstr ""

#: ../source/key_projects.rst:93
msgid "The original Python packaging system, added to the standard library in Python 2.0 and removed in 3.12."
msgstr ""

#: ../source/key_projects.rst:96
msgid "Due to the challenges of maintaining a packaging system where feature updates are tightly coupled to language runtime updates, direct usage of :ref:`distutils` has been actively discouraged, with :ref:`Setuptools` being the preferred replacement. :ref:`Setuptools` not only provides features that plain :ref:`distutils` doesn't offer (such as dependency declarations and entry point declarations), it also provides a consistent build interface and feature set across all supported Python versions."
msgstr ""

#: ../source/key_projects.rst:105
msgid "Consequently, :ref:`distutils` was deprecated in Python 3.10 by :pep:`632` and has been :doc:`removed <python:whatsnew/3.12>` from the standard library in Python 3.12.  Setuptools bundles the standalone copy of distutils, and it is injected even on Python < 3.12 if you import setuptools first or use pip."
msgstr ""

#: ../source/key_projects.rst:114
msgid "flit"
msgstr ""

#: ../source/key_projects.rst:116
msgid "`Docs <https://flit.readthedocs.io/en/latest/>`__ | `Issues <https://github.com/pypa/flit/issues>`__ | `PyPI <https://pypi.org/project/flit>`__"
msgstr ""

#: ../source/key_projects.rst:120
msgid "Flit provides a simple way to create and upload pure Python packages and modules to PyPI.  It focuses on `making the easy things easy <flit-rationale_>`_ for packaging.  Flit can generate a configuration file to quickly set up a simple project, build source distributions and wheels, and upload them to PyPI."
msgstr ""

#: ../source/key_projects.rst:125
msgid "Flit uses ``pyproject.toml`` to configure a project. Flit does not rely on tools such as :ref:`setuptools` to build distributions, or :ref:`twine` to upload them to PyPI. Flit requires Python 3, but you can use it to distribute modules for Python 2, so long as they can be imported on Python 3."
msgstr ""

#: ../source/key_projects.rst:130
msgid "The flit package is lifted by `Matthias Bussonnier <https://github.com/Carreau>`__ since October 2023 on the `tidelift platform <https://tidelift.com/lifter/search/pypi/flit>`__, and funds sent to the PSF and earmarked for PyPA usage."
msgstr ""

#: ../source/key_projects.rst:140
msgid "hatch"
msgstr ""

#: ../source/key_projects.rst:142
msgid "`Docs <https://hatch.pypa.io/latest/>`__ | `GitHub <https://github.com/pypa/hatch>`__ | `PyPI <https://pypi.org/project/hatch>`__"
msgstr ""

#: ../source/key_projects.rst:146
msgid "Hatch is a unified command-line tool meant to conveniently manage dependencies and environment isolation for Python developers. Python package developers use Hatch and its :term:`build backend <Build Backend>` Hatchling to configure, version, specify dependencies for, and publish packages to PyPI. Its plugin system allows for easily extending functionality."
msgstr ""

#: ../source/key_projects.rst:155
msgid "packaging"
msgstr ""

#: ../source/key_projects.rst:157
msgid ":doc:`Docs <packaging:index>` | `Issues <https://github.com/pypa/packaging/issues>`__ | `GitHub <https://github.com/pypa/packaging>`__ | `PyPI <https://pypi.org/project/packaging>`__"
msgstr ""

#: ../source/key_projects.rst:162
msgid "Core utilities for Python packaging used by :ref:`pip` and :ref:`setuptools`."
msgstr ""

#: ../source/key_projects.rst:164
msgid "The core utilities in the packaging library handle version handling, specifiers, markers, requirements, tags, and similar attributes and tasks for Python packages. Most Python users rely on this library without needing to explicitly call it; developers of the other Python packaging, distribution, and installation tools listed here often use its functionality to parse, discover, and otherwise handle dependency attributes."
msgstr ""

#: ../source/key_projects.rst:172
msgid "This project specifically focuses on implementing the modern Python packaging interoperability standards defined at :ref:`packaging-specifications`, and will report errors for sufficiently old legacy packages that are incompatible with those standards. In contrast, the :ref:`distlib` project is a more permissive library that attempts to provide a plausible reading of ambiguous metadata in cases where :ref:`packaging` will instead report on error."
msgstr ""

#: ../source/key_projects.rst:184
#: ../source/specifications/platform-compatibility-tags.rst:163
msgid "pip"
msgstr ""

#: ../source/key_projects.rst:186
msgid "`Docs <https://pip.pypa.io/>`__ | `Issues <https://github.com/pypa/pip/issues>`__ | `GitHub <https://github.com/pypa/pip>`__ | `PyPI <https://pypi.org/project/pip/>`__"
msgstr ""

#: ../source/key_projects.rst:191
msgid "The most popular tool for installing Python packages, and the one included with modern versions of Python."
msgstr ""

#: ../source/key_projects.rst:194
msgid "It provides the essential core features for finding, downloading, and installing packages from PyPI and other Python package indexes, and can be incorporated into a wide range of development workflows via its command-line interface (CLI)."
msgstr ""

#: ../source/key_projects.rst:202
msgid "Pipenv"
msgstr ""

#: ../source/key_projects.rst:204
msgid ":doc:`Docs <pipenv:index>` | `Source <https://github.com/pypa/pipenv>`__ | `Issues <https://github.com/pypa/pipenv/issues>`__ | `PyPI <https://pypi.org/project/pipenv>`__"
msgstr ""

#: ../source/key_projects.rst:209
msgid "Pipenv is a project that aims to bring the best of all packaging worlds to the Python world. It harnesses :ref:`Pipfile`, :ref:`pip`, and :ref:`virtualenv` into one single toolchain. It can autoimport ``requirements.txt`` and also check for CVEs in `Pipfile`_ using `safety <https://pyup.io/safety>`_."
msgstr ""

#: ../source/key_projects.rst:214
msgid "Pipenv aims to help users manage environments, dependencies, and imported packages on the command line. It also works well on Windows (which other tools often underserve), makes and checks file hashes, to ensure compliance with hash-locked dependency specifiers, and eases uninstallation of packages and dependencies."
msgstr ""

#: ../source/key_projects.rst:223
msgid "Pipfile"
msgstr ""

#: ../source/key_projects.rst:225
msgid "`Source <https://github.com/pypa/pipfile>`__"
msgstr ""

#: ../source/key_projects.rst:227
msgid ":file:`Pipfile` and its sister :file:`Pipfile.lock` are a higher-level application-centric alternative to :ref:`pip`'s lower-level :file:`requirements.txt` file."
msgstr ""

#: ../source/key_projects.rst:234
msgid "pipx"
msgstr ""

#: ../source/key_projects.rst:236
msgid "`Docs <https://pypa.github.io/pipx/>`__ | `GitHub <https://github.com/pypa/pipx>`__ | `PyPI <https://pypi.org/project/pipx/>`__"
msgstr ""

#: ../source/key_projects.rst:240
msgid "pipx is a tool to install and run Python command-line applications without causing dependency conflicts with other packages installed on the system."
msgstr ""

#: ../source/key_projects.rst:247
msgid ":doc:`Docs <packaging.python.org:index>` | `Issues <https://github.com/pypa/packaging.python.org/issues>`__ | `GitHub <https://github.com/pypa/packaging.python.org>`__"
msgstr ""

#: ../source/key_projects.rst:251
msgid "This guide!"
msgstr ""

#: ../source/key_projects.rst:256
msgid "readme_renderer"
msgstr ""

#: ../source/key_projects.rst:258
msgid "`GitHub and docs <https://github.com/pypa/readme_renderer/>`__ | `PyPI <https://pypi.org/project/readme-renderer/>`__"
msgstr ""

#: ../source/key_projects.rst:261
msgid "``readme_renderer`` is a library that package developers use to render their user documentation (README) files into HTML from markup languages such as Markdown or reStructuredText. Developers call it on its own or via :ref:`twine`, as part of their release management process, to check that their package descriptions will properly display on PyPI."
msgstr ""

#: ../source/key_projects.rst:272
msgid "Setuptools"
msgstr ""

#: ../source/key_projects.rst:274
msgid "`Docs <https://setuptools.readthedocs.io/en/latest/>`__ | `Issues <https://github.com/pypa/setuptools/issues>`__ | `GitHub <https://github.com/pypa/setuptools>`__ | `PyPI <https://pypi.org/project/setuptools>`__"
msgstr ""

#: ../source/key_projects.rst:279
msgid "Setuptools (which includes ``easy_install``) is a collection of enhancements to the Python distutils that allow you to more easily build and distribute Python :term:`distributions <Distribution Package>`, especially ones that have dependencies on other packages."
msgstr ""

#: ../source/key_projects.rst:287
msgid "trove-classifiers"
msgstr ""

#: ../source/key_projects.rst:289
msgid "`Issues <https://github.com/pypa/trove-classifiers/issues>`__ | `GitHub <https://github.com/pypa/trove-classifiers>`__ | `PyPI <https://pypi.org/project/trove-classifiers/>`__"
msgstr ""

#: ../source/key_projects.rst:293
msgid "trove-classifiers is the canonical source for `classifiers on PyPI <https://pypi.org/classifiers/>`_, which project maintainers use to `systematically describe their projects <https://packaging.python.org/specifications/core-metadata/#classifier-multiple-use>`_ so that users can better find projects that match their needs on the PyPI."
msgstr ""

#: ../source/key_projects.rst:299
msgid "The trove-classifiers package contains a list of valid classifiers and deprecated classifiers (which are paired with the classifiers that replace them).  Use this package to validate classifiers used in packages intended for uploading to PyPI. As this list of classifiers is published as code, you can install and import it, giving you a more convenient workflow compared to referring to the `list published on PyPI <https://pypi.org/classifiers/>`_. The `issue tracker <https://github.com/pypa/trove-classifiers/issues>`_ for the project hosts discussions on proposed classifiers and requests for new classifiers."
msgstr ""

#: ../source/key_projects.rst:313
msgid "twine"
msgstr ""

#: ../source/key_projects.rst:315
msgid "`Docs <https://twine.readthedocs.io/en/latest/>`__ | `Issues <https://github.com/pypa/twine/issues>`__ | `GitHub <https://github.com/pypa/twine>`__ | `PyPI <https://pypi.org/project/twine>`__"
msgstr ""

#: ../source/key_projects.rst:320
msgid "Twine is the primary tool developers use to upload packages to the Python Package Index or other Python package indexes. It is a command-line program that passes program files and metadata to a web API. Developers use it because it's the official PyPI upload tool, it's fast and secure, it's maintained, and it reliably works."
msgstr ""

#: ../source/key_projects.rst:330
#: ../source/overview.rst:409
msgid "virtualenv"
msgstr ""

#: ../source/key_projects.rst:332
msgid "`Docs <https://virtualenv.pypa.io/en/stable/index.html>`__ | `Issues <https://github.com/pypa/virtualenv/issues>`__ | `GitHub <https://github.com/pypa/virtualenv>`__ | `PyPI <https://pypi.org/project/virtualenv/>`__"
msgstr ""

#: ../source/key_projects.rst:337
msgid "virtualenv is a tool for creating isolated Python :term:`Virtual Environments <Virtual Environment>`, like :ref:`venv`. Unlike :ref:`venv`, virtualenv can create virtual environments for other versions of Python, which it locates using the PATH environment variable. It also provides convenient features for configuring, maintaining, duplicating, and troubleshooting virtual environments. For more information, see the section on :ref:`Creating and using Virtual Environments`."
msgstr ""

#: ../source/key_projects.rst:349
msgid "Warehouse"
msgstr ""

#: ../source/key_projects.rst:351
msgid "`Docs <https://warehouse.pypa.io/>`__ | `Issues <https://github.com/pypa/warehouse/issues>`__ | `GitHub <https://github.com/pypa/warehouse>`__"
msgstr ""

#: ../source/key_projects.rst:355
msgid "The current codebase powering the :term:`Python Package Index (PyPI)`. It is hosted at `pypi.org <https://pypi.org/>`_. The default source for :ref:`pip` downloads."
msgstr ""

#: ../source/key_projects.rst:363
msgid "wheel"
msgstr ""

#: ../source/key_projects.rst:365
msgid "`Docs <https://wheel.readthedocs.io/en/latest/>`__ | `Issues <https://github.com/pypa/wheel/issues>`__ | `GitHub <https://github.com/pypa/wheel>`__ | `PyPI <https://pypi.org/project/wheel>`__"
msgstr ""

#: ../source/key_projects.rst:370
msgid "Primarily, the wheel project offers the ``bdist_wheel`` :ref:`setuptools` extension for creating :term:`wheel distributions <Wheel>`.  Additionally, it offers its own command line utility for creating and installing wheels."
msgstr ""

#: ../source/key_projects.rst:374
msgid "See also `auditwheel <https://github.com/pypa/auditwheel>`__, a tool that package developers use to check and fix Python packages they are making in the binary wheel format. It provides functionality to discover dependencies, check metadata for compliance, and repair the wheel and metadata to properly link and include external shared libraries in a package."
msgstr ""

#: ../source/key_projects.rst:383
msgid "Non-PyPA Projects"
msgstr ""

#: ../source/key_projects.rst:388
msgid "buildout"
msgstr ""

#: ../source/key_projects.rst:390
msgid "`Docs <http://www.buildout.org/en/latest/>`__ | `Issues <https://bugs.launchpad.net/zc.buildout>`__ | `PyPI <https://pypi.org/project/zc.buildout>`__ | `GitHub <https://github.com/buildout/buildout/>`__"
msgstr ""

#: ../source/key_projects.rst:395
msgid "Buildout is a Python-based build system for creating, assembling and deploying applications from multiple parts, some of which may be non-Python-based.  It lets you create a buildout configuration and reproduce the same software later."
msgstr ""

#: ../source/key_projects.rst:402
msgid "conda"
msgstr ""

#: ../source/key_projects.rst:404
msgid ":doc:`Docs <conda:index>`"
msgstr ""

#: ../source/key_projects.rst:406
msgid "conda is the package management tool for `Anaconda <https://docs.anaconda.com/anaconda/>`__ Python installations. Anaconda Python is a distribution from `Anaconda, Inc <https://www.anaconda.com/products/individual>`__ specifically aimed at the scientific community, and in particular on Windows where the installation of binary extensions is often difficult."
msgstr ""

#: ../source/key_projects.rst:413
msgid "Conda is a completely separate tool from :ref:`pip`, virtualenv and wheel, but provides many of their combined features in terms of package management, virtual environment management and deployment of binary extensions."
msgstr ""

#: ../source/key_projects.rst:417
msgid "Conda does not install packages from PyPI and can install only from the official Anaconda repositories, or anaconda.org (a place for user-contributed *conda* packages), or a local (e.g. intranet) package server.  However, note that :ref:`pip` can be installed into, and work side-by-side with conda for managing :term:`distributions <Distribution Package>` from PyPI. Also, `conda skeleton <https://docs.conda.io/projects/conda-build/en/latest/user-guide/tutorials/build-pkgs-skeleton.html>`__ is a tool to make Python packages installable by conda by first fetching them from PyPI and modifying their metadata."
msgstr ""

#: ../source/key_projects.rst:430
msgid "devpi"
msgstr ""

#: ../source/key_projects.rst:432
msgid "`Docs <http://doc.devpi.net/latest/>`__ | :gh:`Issues <devpi/devpi/issues>` | `PyPI <https://pypi.org/project/devpi>`__"
msgstr ""

#: ../source/key_projects.rst:436
msgid "devpi features a powerful PyPI-compatible server and PyPI proxy cache with a complementary command line tool to drive packaging, testing and release activities with Python. devpi also provides a browsable and searchable web interface."
msgstr ""

#: ../source/key_projects.rst:444
msgid "enscons"
msgstr ""

#: ../source/key_projects.rst:446
msgid ":gh:`Source <dholth/enscons>` | :gh:`Issues <dholth/enscons/issues>` | `PyPI <https://pypi.org/project/enscons>`__"
msgstr ""

#: ../source/key_projects.rst:450
msgid "Enscons is a Python packaging tool based on `SCons`_. It builds :ref:`pip`-compatible source distributions and wheels without using distutils or setuptools, including distributions with C extensions. Enscons has a different architecture and philosophy than :ref:`distutils`. Rather than adding build features to a Python packaging system, enscons adds Python packaging to a general purpose build system. Enscons helps you to build sdists that can be automatically built by :ref:`pip`, and wheels that are independent of enscons."
msgstr ""

#: ../source/key_projects.rst:465
msgid "Hashdist"
msgstr ""

#: ../source/key_projects.rst:467
msgid "`Docs <https://hashdist.readthedocs.io/en/latest/>`__ | `GitHub <https://github.com/hashdist/hashdist/>`__"
msgstr ""

#: ../source/key_projects.rst:470
msgid "Hashdist is a library for building non-root software distributions. Hashdist is trying to be “the Debian of choice for cases where Debian technology doesn’t work”. The best way for Pythonistas to think about Hashdist may be a more powerful hybrid of :ref:`virtualenv` and :ref:`buildout`. It is aimed at solving the problem of installing scientific software, and making package distribution stateless, cached, and branchable. It is used by some researchers but has been lacking in maintenance since 2016."
msgstr ""

#: ../source/key_projects.rst:482
msgid "Maturin"
msgstr ""

#: ../source/key_projects.rst:484
msgid "`Docs <https://www.maturin.rs>`__ | `GitHub <https://github.com/PyO3/maturin>`__"
msgstr ""

#: ../source/key_projects.rst:487
msgid "Maturin is a build backend for Rust extension modules, also written in Rust. It supports building wheels for python 3.7+ on Windows, Linux, macOS and FreeBSD, can upload them to PyPI and has basic PyPy and GraalPy support."
msgstr ""

#: ../source/key_projects.rst:495
msgid "meson-python"
msgstr ""

#: ../source/key_projects.rst:497
msgid "`Docs <https://meson-python.readthedocs.io/en/latest/>`__ | `GitHub <https://github.com/mesonbuild/meson-python>`__"
msgstr ""

#: ../source/key_projects.rst:500
msgid "``meson-python`` is a build backend that uses the Meson_ build system. It enables Python package authors to use Meson_ as the build system for their package. It supports a wide variety of languages, including C, and is able to fill the needs of most complex build configurations."
msgstr ""

#: ../source/key_projects.rst:510
msgid "multibuild"
msgstr ""

#: ../source/key_projects.rst:512
msgid "`GitHub <https://github.com/multi-build/multibuild>`__"
msgstr ""

#: ../source/key_projects.rst:514
msgid "Multibuild is a set of CI scripts for building and testing Python :term:`wheels <Wheel>` for Linux, macOS, and (less flexibly) Windows. Also see :ref:`cibuildwheel`."
msgstr ""

#: ../source/key_projects.rst:520
msgid "pdm"
msgstr ""

#: ../source/key_projects.rst:522
msgid "`Docs <https://pdm.fming.dev/>`__ | `GitHub <https://github.com/pdm-project/pdm/>`__ | `PyPI <https://pypi.org/project/pdm>`__"
msgstr ""

#: ../source/key_projects.rst:526
msgid "PDM is a modern Python package manager. It uses :term:`pyproject.toml` to store project metadata as defined in :pep:`621`."
msgstr ""

#: ../source/key_projects.rst:534
msgid "`Docs <https://pex.readthedocs.io/en/latest/>`__ | `GitHub <https://github.com/pantsbuild/pex/>`__ | `PyPI <https://pypi.org/project/pex>`__"
msgstr ""

#: ../source/key_projects.rst:538
msgid "pex is both a library and tool for generating :file:`.pex` (Python EXecutable) files, standalone Python environments in the spirit of :ref:`virtualenv`. :file:`.pex` files are just carefully constructed zip files with a ``#!/usr/bin/env python`` and special :file:`__main__.py`, and are designed to make deployment of Python applications as simple as ``cp``."
msgstr ""

#: ../source/key_projects.rst:547
msgid "pip-tools"
msgstr ""

#: ../source/key_projects.rst:549
msgid "`Docs <https://pip-tools.readthedocs.io/en/latest/>`__ | `GitHub <https://github.com/jazzband/pip-tools/>`__ | `PyPI <https://pypi.org/project/pip-tools/>`__"
msgstr ""

#: ../source/key_projects.rst:553
msgid "pip-tools is a suite of tools meant for Python system administrators and release managers who particularly want to keep their builds deterministic yet stay up to date with new versions of their dependencies. Users can specify particular release of their dependencies via hash, conveniently make a properly formatted list of requirements from information in other parts of their program, update all dependencies (a feature :ref:`pip` currently does not provide), and create layers of constraints for the program to obey."
msgstr ""

#: ../source/key_projects.rst:565
msgid "piwheels"
msgstr ""

#: ../source/key_projects.rst:567
msgid "`Website <https://www.piwheels.org/>`__ | :doc:`Docs <piwheels:index>` | `GitHub <https://github.com/piwheels/piwheels/>`__"
msgstr ""

#: ../source/key_projects.rst:571
msgid "piwheels is a website, and software underpinning it, that fetches source code distribution packages from PyPI and compiles them into binary wheels that are optimized for installation onto Raspberry Pi computers. Raspberry Pi OS pre-configures pip to use piwheels.org as an additional index to PyPI."
msgstr ""

#: ../source/key_projects.rst:580
msgid "poetry"
msgstr ""

#: ../source/key_projects.rst:582
msgid "`Docs <https://python-poetry.org/>`__ | `GitHub <https://github.com/python-poetry/poetry>`__ | `PyPI <https://pypi.org/project/poetry/>`__"
msgstr ""

#: ../source/key_projects.rst:586
msgid "poetry is a command-line tool to handle dependency installation and isolation as well as building and packaging of Python packages. It uses ``pyproject.toml`` and, instead of depending on the resolver functionality within :ref:`pip`, provides its own dependency resolver. It attempts to speed users' experience of installation and dependency resolution by locally caching metadata about dependencies."
msgstr ""

#: ../source/key_projects.rst:596
msgid "pypiserver"
msgstr ""

#: ../source/key_projects.rst:598
msgid "`GitHub <https://github.com/pypiserver/pypiserver>`__ | `PyPI <https://pypi.org/project/pypiserver/>`__"
msgstr ""

#: ../source/key_projects.rst:601
msgid "pypiserver is a minimalist application that serves as a private Python package index within organizations, implementing a simple API and browser interface. You can upload private packages using standard upload tools, and users can download and install them with :ref:`pip`, without publishing them publicly. Organizations who use pypiserver usually download packages both from pypiserver and from PyPI."
msgstr ""

#: ../source/key_projects.rst:611
msgid "PyScaffold"
msgstr ""

#: ../source/key_projects.rst:613
msgid "`Docs <https://pyscaffold.org>`__ | `GitHub <https://github.com/pyscaffold/pyscaffold>`__ | `PyPI <https://pypi.org/project/pyscaffold/>`__"
msgstr ""

#: ../source/key_projects.rst:617
msgid "PyScaffold is a project generator for bootstrapping Python packages, ready to be shared on PyPI and installable via :ref:`pip`. It relies on a set of sane default configurations for established tools (such as :ref:`setuptools`, pytest_ and Sphinx_) to provide a productive environment so developers can start coding right away. PyScaffold can also be used with existing projects to make packaging easier."
msgstr ""

#: ../source/key_projects.rst:629
msgid "scikit-build"
msgstr ""

#: ../source/key_projects.rst:631
msgid "`Docs <https://scikit-build.readthedocs.io/en/latest/>`__ | `GitHub <https://github.com/scikit-build/scikit-build/>`__ | `PyPI <https://pypi.org/project/scikit-build>`__"
msgstr ""

#: ../source/key_projects.rst:635
msgid "Scikit-build is a :ref:`setuptools` wrapper for CPython that builds C/C++/Fortran/Cython extensions It uses `cmake <https://pypi.org/project/cmake>`__ (available on PyPI) to provide better support for additional compilers, build systems, cross compilation, and locating dependencies and their associated build requirements. To speed up and parallelize the build of large projects, the user can install `ninja <https://pypi.org/project/ninja>`__ (also available on PyPI)."
msgstr ""

#: ../source/key_projects.rst:646
msgid "scikit-build-core"
msgstr ""

#: ../source/key_projects.rst:648
msgid "`Docs <https://scikit-build-core.readthedocs.io/en/latest/>`__ | `GitHub <https://github.com/scikit-build/scikit-build-core/>`__ | `PyPI <https://pypi.org/project/scikit-build-core>`__"
msgstr ""

#: ../source/key_projects.rst:652
msgid "Scikit-build-core is a build backend for CPython C/C++/Fortran/Cython extensions.  It enables users to write extensions with `cmake <https://pypi.org/project/cmake>`__ (available on PyPI) to provide better support for additional compilers, build systems, cross compilation, and locating dependencies and their associated build requirements. CMake/Ninja are automatically downloaded from PyPI if not available on the system."
msgstr ""

#: ../source/key_projects.rst:662
msgid "shiv"
msgstr ""

#: ../source/key_projects.rst:664
msgid "`Docs <https://shiv.readthedocs.io/en/latest/>`__ | `GitHub <https://github.com/linkedin/shiv>`__ | `PyPI <https://pypi.org/project/shiv/>`__"
msgstr ""

#: ../source/key_projects.rst:668
msgid "shiv is a command line utility for building fully self contained Python zipapps as outlined in :pep:`441`, but with all their dependencies included. Its primary goal is making distributing Python applications and command line tools fast & easy."
msgstr ""

#: ../source/key_projects.rst:678
msgid ":doc:`Docs <spack:index>` | `GitHub <https://github.com/spack/spack>`__ | `Paper <https://www.computer.org/csdl/proceedings-article/sc/2015/2807623/12OmNBf94Xq>`__ | `Slides <https://tgamblin.github.io/files/Gamblin-Spack-SC15-Talk.pdf>`__"
msgstr ""

#: ../source/key_projects.rst:683
msgid "A flexible package manager designed to support multiple versions, configurations, platforms, and compilers.  Spack is like Homebrew, but packages are written in Python and parameterized to allow easy swapping of compilers, library versions, build options, etc. Arbitrarily many versions of packages can coexist on the same system. Spack was designed for rapidly building high performance scientific applications on clusters and supercomputers."
msgstr ""

#: ../source/key_projects.rst:691
msgid "Spack is not in PyPI (yet), but it requires no installation and can be used immediately after cloning from GitHub."
msgstr ""

#: ../source/key_projects.rst:697
msgid "zest.releaser"
msgstr ""

#: ../source/key_projects.rst:699
msgid "`Docs <https://zestreleaser.readthedocs.io/en/latest/>`__ | `GitHub <https://github.com/zestsoftware/zest.releaser/>`__ | `PyPI <https://pypi.org/project/zest.releaser/>`__"
msgstr ""

#: ../source/key_projects.rst:703
msgid "``zest.releaser`` is a Python package release tool providing an abstraction layer on top of :ref:`twine`. Python developers use ``zest.releaser`` to automate incrementing package version numbers, updating changelogs, tagging releases in source control, and uploading new packages to PyPI."
msgstr ""

#: ../source/key_projects.rst:710
msgid "Standard Library Projects"
msgstr ""

#: ../source/key_projects.rst:715
msgid "ensurepip"
msgstr ""

#: ../source/key_projects.rst:717
msgid "`Docs <https://docs.python.org/3/library/ensurepip.html>`__ | `Issues <https://bugs.python.org/>`__"
msgstr ""

#: ../source/key_projects.rst:720
msgid "A package in the Python Standard Library that provides support for bootstrapping :ref:`pip` into an existing Python installation or virtual environment.  In most cases, end users won't use this module, but rather it will be used during the build of the Python distribution."
msgstr ""

#: ../source/key_projects.rst:729
msgid "venv"
msgstr ""

#: ../source/key_projects.rst:731
msgid "`Docs <https://docs.python.org/3/library/venv.html>`__ | `Issues <https://github.com/python/cpython/issues>`__"
msgstr ""

#: ../source/key_projects.rst:734
msgid "A package in the Python Standard Library (starting with Python 3.3) for creating :term:`Virtual Environments <Virtual Environment>`.  For more information, see the section on :ref:`Creating and using Virtual Environments`."
msgstr ""

#: ../source/news.rst:2
msgid "News"
msgstr ""

#: ../source/news.rst:4
msgid "This document is not currently updated. Previously, the document highlighted changes in Python packaging."
msgstr ""

#: ../source/news.rst:9
msgid "September 2019"
msgstr ""

#: ../source/news.rst:10
msgid "Added a guide about publishing dists via GitHub Actions. (:pr:`647`)"
msgstr ""

#: ../source/news.rst:13
msgid "August 2019"
msgstr ""

#: ../source/news.rst:14
msgid "Updated to use :file:`python3 -m` when installing pipx. (:pr:`631`)"
msgstr ""

#: ../source/news.rst:17
msgid "July 2019"
msgstr ""

#: ../source/news.rst:18
msgid "Marked all PEP numbers with the :pep: role. (:pr:`629`)"
msgstr ""

#: ../source/news.rst:19
msgid "Upgraded Sphinx version and removed pypa.io intersphinx. (:pr:`625`)"
msgstr ""

#: ../source/news.rst:20
msgid "Mentioned :file:`find_namespace_packages`. (:pr:`622`)"
msgstr ""

#: ../source/news.rst:21
msgid "Updated directory layout examples for consistency. (:pr:`611`)"
msgstr ""

#: ../source/news.rst:22
msgid "Updated Bandersnatch link to GitHub. (:pr:`623`)"
msgstr ""

#: ../source/news.rst:25
msgid "June 2019"
msgstr ""

#: ../source/news.rst:26
msgid "Fixed some typos. (:pr:`620`)"
msgstr ""

#: ../source/news.rst:29
msgid "May 2019"
msgstr ""

#: ../source/news.rst:30
msgid "Added :file:`python_requires` usage to packaging tutorial. (:pr:`613`)"
msgstr ""

#: ../source/news.rst:31
msgid "Added a MANIFEST.in guide page. (:pr:`609`)"
msgstr ""

#: ../source/news.rst:34
msgid "April 2019"
msgstr ""

#: ../source/news.rst:35
msgid "Added a mention for :file:`shiv` in the key projects section. (:pr:`608`)"
msgstr ""

#: ../source/news.rst:36
msgid "Reduced emphasis on virtualenv. (:pr:`606`)"
msgstr ""

#: ../source/news.rst:39
msgid "March 2019"
msgstr ""

#: ../source/news.rst:40
msgid "Moved single-sourcing guide version option to Python 3. (:pr:`605`)"
msgstr ""

#: ../source/news.rst:41
msgid "Covered RTD details for contributing. (:pr:`600`)"
msgstr ""

#: ../source/news.rst:44
msgid "February 2019"
msgstr ""

#: ../source/news.rst:45
msgid "Elaborate upon the differences between the tutorial and the real packaging process. (:pr:`602`)"
msgstr ""

#: ../source/news.rst:46
msgid "Added instructions to install Python CLI applications. (:pr:`594`)"
msgstr ""

#: ../source/news.rst:49
msgid "January 2019"
msgstr ""

#: ../source/news.rst:50
msgid "Added :file:`--no-deps` to the packaging tutorial. (:pr:`593`)"
msgstr ""

#: ../source/news.rst:51
msgid "Updated Sphinx and Nox. (:pr:`591`)"
msgstr ""

#: ../source/news.rst:52
msgid "Referenced Twine from Python3. (:pr:`581`)"
msgstr ""

#: ../source/news.rst:55
msgid "December 2018"
msgstr ""

#: ../source/news.rst:56
msgid "No programmers in the office!"
msgstr ""

#: ../source/news.rst:59
msgid "November 2018"
msgstr ""

#: ../source/news.rst:60
msgid "Removed landing page link to PyPI migration guide. (:pr:`575`)"
msgstr ""

#: ../source/news.rst:61
msgid "Changed bumpversion to bump2version. (:pr:`572`)"
msgstr ""

#: ../source/news.rst:62
msgid "Added single-sourcing package version example. (:pr:`573`)"
msgstr ""

#: ../source/news.rst:63
msgid "Added a guide for creating documentation. (:pr:`568`)"
msgstr ""

#: ../source/news.rst:66
msgid "October 2018"
msgstr ""

#: ../source/news.rst:67
msgid "Updated Nox package name. (:pr:`566`)"
msgstr ""

#: ../source/news.rst:68
msgid "Mentioned Sphinx extensions in guides. (:pr:`562`)"
msgstr ""

#: ../source/news.rst:71
msgid "September 2018"
msgstr ""

#: ../source/news.rst:72
msgid "Added a section on checking RST markup. (:pr:`554`)"
msgstr ""

#: ../source/news.rst:73
msgid "Updated user installs page. (:pr:`558`)"
msgstr ""

#: ../source/news.rst:74
msgid "Updated Google BigQuery urls. (:pr:`556`)"
msgstr ""

#: ../source/news.rst:75
msgid "Replaced tar command with working command. (:pr:`552`)"
msgstr ""

#: ../source/news.rst:76
msgid "Changed to double quotes in the pip install SomeProject==1.4. (:pr:`550`)"
msgstr ""

#: ../source/news.rst:79
msgid "August 2018"
msgstr ""

#: ../source/news.rst:80
msgid "Removed the recommendation to store passwords in cleartext. (:pr:`546`)"
msgstr ""

#: ../source/news.rst:81
msgid "Moved the Overview to a task based lead in along with the others. (:pr:`540`)"
msgstr ""

#: ../source/news.rst:82
msgid "Updated Python version supported by virtualenv. (:pr:`538`)"
msgstr ""

#: ../source/news.rst:83
msgid "Added outline/rough draft of new Overview page. (:pr:`519`)"
msgstr ""

#: ../source/news.rst:86
msgid "July 2018"
msgstr ""

#: ../source/news.rst:88
msgid "Improved binary extension docs. (:pr:`531`)"
msgstr ""

#: ../source/news.rst:89
msgid "Added scikit-build to key projects. (:pr:`530`)"
msgstr ""

#: ../source/news.rst:92
msgid "June 2018"
msgstr ""

#: ../source/news.rst:94
msgid "Fixed categories of interop PEP for pypa.io. (:pr:`527`)"
msgstr ""

#: ../source/news.rst:95
msgid "Updated Markdown descriptions explanation. (:pr:`522`)"
msgstr ""

#: ../source/news.rst:98
msgid "May 2018"
msgstr ""

#: ../source/news.rst:100
msgid "Noted issues with Provides-Dist and Obsoletes-Dist. (:pr:`513`)"
msgstr ""

#: ../source/news.rst:101
msgid "Removed outdated warning about Python version mixing with Pipenv. (:pr:`501`)"
msgstr ""

#: ../source/news.rst:102
msgid "Simplified packaging tutorial. (:pr:`498`)"
msgstr ""

#: ../source/news.rst:103
msgid "Updated Windows users instructions for clarity. (:pr:`493`)"
msgstr ""

#: ../source/news.rst:104
msgid "Updated the license section description for completeness. (:pr:`492`)"
msgstr ""

#: ../source/news.rst:105
msgid "Added specification-style document to contributing section. (:pr:`489`)"
msgstr ""

#: ../source/news.rst:106
msgid "Added documentation types to contributing guide. (:pr:`485`)"
msgstr ""

#: ../source/news.rst:109
msgid "April 2018"
msgstr ""

#: ../source/news.rst:111
msgid "Added README guide. (:pr:`461`)"
msgstr ""

#: ../source/news.rst:112
msgid "Updated instructions and status for PyPI launch. (:pr:`475`)"
msgstr ""

#: ../source/news.rst:113
msgid "Added instructions for Warehouse. (:pr:`471`)"
msgstr ""

#: ../source/news.rst:114
msgid "Removed GPG references from publishing tutorial. (:pr:`466`)"
msgstr ""

#: ../source/news.rst:115
msgid "Added 'What’s in which Python 3.4–3.6?'. (:pr:`468`)"
msgstr ""

#: ../source/news.rst:116
msgid "Added a guide for phasing out Python versions. (:pr:`459`)"
msgstr ""

#: ../source/news.rst:117
msgid "Made default Description-Content-Type variant GFM. (:pr:`462`)"
msgstr ""

#: ../source/news.rst:120
msgid "March 2018"
msgstr ""

#: ../source/news.rst:122
msgid "Updated \"installing scientific packages\". (:pr:`455`)"
msgstr ""

#: ../source/news.rst:123
msgid "Added :file:`long_description_content_type` to follow PEP 556. (:pr:`457`)"
msgstr ""

#: ../source/news.rst:124
msgid "Clarified a long description classifier on pypi.org. (:pr:`456`)"
msgstr ""

#: ../source/news.rst:125
msgid "Updated Core Metadata spec to follow PEP 556. (:pr:`412`)"
msgstr ""

#: ../source/news.rst:128
msgid "February 2018"
msgstr ""

#: ../source/news.rst:130
msgid "Added python3-venv and python3-pip to Debian installation instructions. (:pr:`445`)"
msgstr ""

#: ../source/news.rst:131
msgid "Updated PyPI migration info. (:pr:`439`)"
msgstr ""

#: ../source/news.rst:132
msgid "Added a warning about managing multiple versions with pipenv. (:pr:`430`)"
msgstr ""

#: ../source/news.rst:133
msgid "Added example of multiple emails to Core Metadata. (:pr:`429`)"
msgstr ""

#: ../source/news.rst:134
msgid "Added explanation of \"legacy\" in test.pypi.org/legacy. (:pr:`426`)"
msgstr ""

#: ../source/news.rst:137
msgid "January 2018"
msgstr ""

#: ../source/news.rst:139
msgid "Added a link to PyPI's list of classifiers. (:pr:`425`)"
msgstr ""

#: ../source/news.rst:140
msgid "Updated README.rst explanation. (:pr:`419`)"
msgstr ""

#: ../source/news.rst:143
msgid "December 2017"
msgstr ""

#: ../source/news.rst:145
msgid "Replaced :file:`~` with :file:`$HOME` in guides and tutorials.  (:pr:`418`)"
msgstr ""

#: ../source/news.rst:146
msgid "Noted which fields can be used with environment markers. (:pr:`416`)"
msgstr ""

#: ../source/news.rst:147
msgid "Updated Requires-Python section. (:pr:`414`)"
msgstr ""

#: ../source/news.rst:148
msgid "Added news page. (:pr:`404`)"
msgstr ""

#: ../source/news.rst:151
msgid "November 2017"
msgstr ""

#: ../source/news.rst:153
msgid "Introduced a new dependency management tutorial based on Pipenv. (:pr:`402`)"
msgstr ""

#: ../source/news.rst:154
msgid "Updated the *Single Sourcing Package Version* tutorial to reflect pip's current strategy. (:pr:`400`)"
msgstr ""

#: ../source/news.rst:156
msgid "Added documentation about the ``py_modules`` argument to ``setup``. (:pr:`398`)"
msgstr ""

#: ../source/news.rst:157
msgid "Simplified the wording for the :file:`manifest.in` section. (:pr:`395`)"
msgstr ""

#: ../source/news.rst:160
msgid "October 2017"
msgstr ""

#: ../source/news.rst:162
msgid "Added a specification for the :file:`entry_points.txt` file. (:pr:`398`)"
msgstr ""

#: ../source/news.rst:163
msgid "Created a new guide for managing packages using ``pip`` and ``virtualenv``. (:pr:`385`)"
msgstr ""

#: ../source/news.rst:164
msgid "Split the specifications page into multiple pages. (:pr:`386`)"
msgstr ""

#: ../source/news.rst:167
msgid "September 2017"
msgstr ""

#: ../source/news.rst:169
msgid "Encouraged using ``readme_renderer`` to validate :file:`README.rst`. (:pr:`379`)"
msgstr ""

#: ../source/news.rst:171
msgid "Recommended using the ``--user-base`` option. (:pr:`374`)"
msgstr ""

#: ../source/news.rst:174
msgid "August 2017"
msgstr ""

#: ../source/news.rst:176
msgid "Added a new, experimental tutorial on installing packages using ``Pipenv``. (:pr:`369`)"
msgstr ""

#: ../source/news.rst:177
msgid "Added a new guide on how to use ``TestPyPI``. (:pr:`366`)"
msgstr ""

#: ../source/news.rst:178
msgid "Added :file:`pypi.org` as a term. (:pr:`365`)"
msgstr ""

#: ../source/news.rst:181
msgid "July 2017"
msgstr ""

#: ../source/news.rst:183
msgid "Added ``flit`` to the key projects list. (:pr:`358`)"
msgstr ""

#: ../source/news.rst:184
msgid "Added ``enscons`` to the list of key projects. (:pr:`357`)"
msgstr ""

#: ../source/news.rst:185
msgid "Updated this guide's ``readme`` with instructions on how to build the guide locally. (:pr:`356`)"
msgstr ""

#: ../source/news.rst:186
msgid "Made the new ``TestPyPI`` URL more visible, adding note to homepage about pypi.org. (:pr:`354`)"
msgstr ""

#: ../source/news.rst:187
msgid "Added a note about the removal of the explicit registration API. (:pr:`347`)"
msgstr ""

#: ../source/news.rst:190
msgid "June 2017"
msgstr ""

#: ../source/news.rst:192
msgid "Added a document on migrating uploads to :file:`PyPI.org`. (:pr:`339`)"
msgstr ""

#: ../source/news.rst:193
msgid "Added documentation for ``python_requires``. (:pr:`338`)"
msgstr ""

#: ../source/news.rst:194
msgid "Added a note about PyPI migration in the *Tool Recommendations* tutorial. (:pr:`335`)"
msgstr ""

#: ../source/news.rst:195
msgid "Added a note that :file:`manifest.in` does not affect wheels. (:pr:`332`)"
msgstr ""

#: ../source/news.rst:196
msgid "Added a license section to the distributing guide. (:pr:`331`)"
msgstr ""

#: ../source/news.rst:197
msgid "Expanded the section on the ``name`` argument. (:pr:`329`)"
msgstr ""

#: ../source/news.rst:198
msgid "Adjusted the landing page. (:pr:`327`, :pr:`326`, :pr:`324`)"
msgstr ""

#: ../source/news.rst:199
msgid "Updated to Sphinx 1.6.2. (:pr:`323`)"
msgstr ""

#: ../source/news.rst:200
msgid "Switched to the PyPA theme. (:pr:`305`)"
msgstr ""

#: ../source/news.rst:201
msgid "Re-organized the documentation into the new structure. (:pr:`318`)"
msgstr ""

#: ../source/news.rst:204
msgid "May 2017"
msgstr ""

#: ../source/news.rst:206
msgid "Added documentation for the ``Description-Content-Type`` field. (:pr:`258`)"
msgstr ""

#: ../source/news.rst:207
msgid "Added contributor and style guide. (:pr:`307`)"
msgstr ""

#: ../source/news.rst:208
msgid "Documented ``pip`` and ``easy_install``'s differences for per-project indexes. (:pr:`233`)"
msgstr ""

#: ../source/news.rst:211
msgid "April 2017"
msgstr ""

#: ../source/news.rst:213
msgid "Added travis configuration for testing pull requests. (:pr:`300`)"
msgstr ""

#: ../source/news.rst:214
msgid "Mentioned the requirement of the ``wheel`` package for creating wheels (:pr:`299`)"
msgstr ""

#: ../source/news.rst:215
msgid "Removed the ``twine register`` reference in the *Distributing Packages* tutorial. (:pr:`271`)"
msgstr ""

#: ../source/news.rst:216
msgid "Added a topic on plugin discovery. (:pr:`294`, :pr:`296`)"
msgstr ""

#: ../source/news.rst:217
msgid "Added a topic on namespace packages. (:pr:`290`)"
msgstr ""

#: ../source/news.rst:218
msgid "Added documentation explaining prominently how to install ``pip`` in ``/usr/local``. (:pr:`230`)"
msgstr ""

#: ../source/news.rst:219
msgid "Updated development mode documentation to mention that order of local packages matters. (:pr:`208`)"
msgstr ""

#: ../source/news.rst:220
msgid "Convert readthedocs link for their ``.org`` -> ``.io`` migration for hosted projects (:pr:`239`)"
msgstr ""

#: ../source/news.rst:221
msgid "Swapped order of :file:`setup.py` arguments for the upload command, as order is significant. (:pr:`260`)"
msgstr ""

#: ../source/news.rst:223
msgid "Explained how to install from unsupported sources using a helper application. (:pr:`289`)"
msgstr ""

#: ../source/news.rst:227
msgid "March 2017"
msgstr ""

#: ../source/news.rst:229
msgid "Covered ``manylinux1`` in *Platform Wheels*. (:pr:`283`)"
msgstr ""

#: ../source/news.rst:232
msgid "February 2017"
msgstr ""

#: ../source/news.rst:234
msgid "Added :pep:`518`. (:pr:`281`)"
msgstr ""

#: ../source/overview.rst:3
msgid "Overview of Python Packaging"
msgstr ""

#: ../source/overview.rst:7
msgid "As a general-purpose programming language, Python is designed to be used in many ways. You can build web sites or industrial robots or a game for your friends to play, and much more, all using the same core technology."
msgstr ""

#: ../source/overview.rst:12
msgid "Python's flexibility is why the first step in every Python project must be to think about the project's audience and the corresponding environment where the project will run. It might seem strange to think about packaging before writing code, but this process does wonders for avoiding future headaches."
msgstr ""

#: ../source/overview.rst:18
msgid "This overview provides a general-purpose decision tree for reasoning about Python's plethora of packaging options. Read on to choose the best technology for your next project."
msgstr ""

#: ../source/overview.rst:23
msgid "Thinking about deployment"
msgstr ""

#: ../source/overview.rst:25
msgid "Packages exist to be installed (or *deployed*), so before you package anything, you'll want to have some answers to the deployment questions below:"
msgstr ""

#: ../source/overview.rst:29
msgid "Who are your software's users? Will your software be installed by other developers doing software development, operations people in a datacenter, or a less software-savvy group?"
msgstr ""

#: ../source/overview.rst:32
msgid "Is your software intended to run on servers, desktops, mobile clients (phones, tablets, etc.), or embedded in dedicated devices?"
msgstr ""

#: ../source/overview.rst:34
msgid "Is your software installed individually, or in large deployment batches?"
msgstr ""

#: ../source/overview.rst:36
msgid "Packaging is all about target environment and deployment experience. There are many answers to the questions above and each combination of circumstances has its own solutions. With this information, the following overview will guide you to the packaging technologies best suited to your project."
msgstr ""

#: ../source/overview.rst:43
msgid "Packaging Python libraries and tools"
msgstr ""

#: ../source/overview.rst:45
msgid "You may have heard about PyPI, ``setup.py``, and ``wheel`` files. These are just a few of the tools Python's ecosystem provides for distributing Python code to developers, which you can read about in :doc:`guides/distributing-packages-using-setuptools`."
msgstr ""

#: ../source/overview.rst:50
msgid "The following approaches to packaging are meant for libraries and tools used by technical audience in a development setting. If you're looking for ways to package Python for a non-technical audience and/or a production setting, skip ahead to :ref:`packaging-applications`."
msgstr ""

#: ../source/overview.rst:56
msgid "Python modules"
msgstr ""

#: ../source/overview.rst:58
msgid "A Python file, provided it only relies on the standard library, can be redistributed and reused. You will also need to ensure it's written for the right version of Python, and only relies on the standard library."
msgstr ""

#: ../source/overview.rst:63
msgid "This is great for sharing simple scripts and snippets between people who both have compatible Python versions (such as via email, StackOverflow, or GitHub gists). There are even some entire Python libraries that offer this as an option, such as :doc:`bottle.py<bottle:tutorial>` and :doc:`boltons <boltons:architecture>`."
msgstr ""

#: ../source/overview.rst:70
msgid "However, this pattern won't scale for projects that consist of multiple files, need additional libraries, or need a specific version of Python, hence the options below."
msgstr ""

#: ../source/overview.rst:75
msgid "Python source distributions"
msgstr ""

#: ../source/overview.rst:77
msgid "If your code consists of multiple Python files, it's usually organized into a directory structure. Any directory containing Python files can comprise an :term:`Import Package`."
msgstr ""

#: ../source/overview.rst:81
msgid "Because packages consist of multiple files, they are harder to distribute. Most protocols support transferring only one file at a time (when was the last time you clicked a link and it downloaded multiple files?). It's easier to get incomplete transfers, and harder to guarantee code integrity at the destination."
msgstr ""

#: ../source/overview.rst:87
msgid "So long as your code contains nothing but pure Python code, and you know your deployment environment supports your version of Python, then you can use Python's native packaging tools to create a *source* :term:`Distribution Package`, or *sdist* for short."
msgstr ""

#: ../source/overview.rst:92
msgid "Python's *sdists* are compressed archives (``.tar.gz`` files) containing one or more packages or modules. If your code is pure-Python, and you only depend on other Python packages, you can go to the :ref:`source-distribution-format` specification to learn more."
msgstr ""

#: ../source/overview.rst:97
msgid "If you rely on any non-Python code, or non-Python packages (such as `libxml2 <https://en.wikipedia.org/wiki/Libxml2>`_ in the case of `lxml <https://pypi.org/project/lxml/>`_, or BLAS libraries in the case of `numpy <https://pypi.org/project/numpy>`_), you will need to use the format detailed in the next section, which also has many advantages for pure-Python libraries."
msgstr ""

#: ../source/overview.rst:104
msgid "Python and PyPI support multiple distributions providing different implementations of the same package. For instance the unmaintained-but-seminal `PIL distribution <https://pypi.org/project/PIL/>`_ provides the PIL package, and so does `Pillow <https://pypi.org/project/Pillow/>`_, an actively-maintained fork of PIL!"
msgstr ""

#: ../source/overview.rst:111
msgid "This Python packaging superpower makes it possible for Pillow to be a drop-in replacement for PIL, just by changing your project's ``install_requires`` or ``requirements.txt``."
msgstr ""

#: ../source/overview.rst:116
msgid "Python binary distributions"
msgstr ""

#: ../source/overview.rst:118
msgid "So much of Python's practical power comes from its ability to integrate with the software ecosystem, in particular libraries written in C, C++, Fortran, Rust, and other languages."
msgstr ""

#: ../source/overview.rst:122
msgid "Not all developers have the right tools or experiences to build these components written in these compiled languages, so Python created the :term:`Wheel`, a package format designed to ship libraries with compiled artifacts. In fact, Python's package installer, ``pip``, always prefers wheels because installation is always faster, so even pure-Python packages work better with wheels."
msgstr ""

#: ../source/overview.rst:129
msgid "Binary distributions are best when they come with source distributions to match. Even if you don't upload wheels of your code for every operating system, by uploading the sdist, you're enabling users of other platforms to still build it for themselves. Default to publishing both sdist and wheel archives together, *unless* you're creating artifacts for a very specific use case where you know the recipient only needs one or the other."
msgstr ""

#: ../source/overview.rst:137
msgid "Python and PyPI make it easy to upload both wheels and sdists together. Just follow the :doc:`tutorials/packaging-projects` tutorial."
msgstr ""

#: ../source/overview.rst:145
msgid "A summary of Python's packaging capabilities for tools and libraries."
msgstr ""

#: ../source/overview.rst:145
msgid "Python's recommended built-in library and tool packaging technologies. Excerpted from `The Packaging Gradient (2017) <https://www.youtube.com/watch?v=iLVNWfPWAC8>`_."
msgstr ""

#: ../source/overview.rst:152
msgid "Packaging Python applications"
msgstr ""

#: ../source/overview.rst:154
msgid "So far we've only discussed Python's native distribution tools. Based on our introduction, you would be correct to infer these built-in approaches only target environments which have Python, and an audience who knows how to install Python packages."
msgstr ""

#: ../source/overview.rst:159
msgid "With the variety of operating systems, configurations, and people out there, this assumption is only safe when targeting a developer audience."
msgstr ""

#: ../source/overview.rst:163
msgid "Python's native packaging is mostly built for distributing reusable code, called libraries, between developers. You can piggyback **tools**, or basic applications for developers, on top of Python's library packaging, using technologies like :doc:`setuptools entry_points <setuptools:userguide/entry_point>`."
msgstr ""

#: ../source/overview.rst:169
msgid "Libraries are building blocks, not complete applications. For distributing applications, there's a whole new world of technologies out there."
msgstr ""

#: ../source/overview.rst:173
msgid "The next few sections organize these application packaging options according to their dependencies on the target environment, so you can choose the right one for your project."
msgstr ""

#: ../source/overview.rst:178
msgid "Depending on a framework"
msgstr ""

#: ../source/overview.rst:180
msgid "Some types of Python applications, like web site backends and other network services, are common enough that they have frameworks to enable their development and packaging. Other types of applications, like dynamic web frontends and mobile clients, are complex enough to target that a framework becomes more than a convenience."
msgstr ""

#: ../source/overview.rst:186
msgid "In all these cases, it makes sense to work backwards, from the framework's packaging and deployment story. Some frameworks include a deployment system which wraps the technologies outlined in the rest of the guide. In these cases, you'll want to defer to your framework's packaging guide for the easiest and most reliable production experience."
msgstr ""

#: ../source/overview.rst:192
msgid "If you ever wonder how these platforms and frameworks work under the hood, you can always read the sections beyond."
msgstr ""

#: ../source/overview.rst:196
msgid "Service platforms"
msgstr ""

#: ../source/overview.rst:198
msgid "If you're developing for a \"Platform-as-a-Service\" or \"PaaS\" like Heroku or Google App Engine, you are going to want to follow their respective packaging guides."
msgstr ""

#: ../source/overview.rst:202
msgid "`Heroku <https://devcenter.heroku.com/articles/getting-started-with-python>`_"
msgstr ""

#: ../source/overview.rst:203
msgid "`Google App Engine <https://cloud.google.com/appengine/docs/python/>`_"
msgstr ""

#: ../source/overview.rst:204
msgid "`PythonAnywhere <https://www.pythonanywhere.com/>`_"
msgstr ""

#: ../source/overview.rst:205
msgid "`OpenShift <https://blog.openshift.com/getting-started-python/>`_"
msgstr ""

#: ../source/overview.rst:206
msgid "\"Serverless\" frameworks like :gh:`Zappa <zappa/Zappa>`"
msgstr ""

#: ../source/overview.rst:208
msgid "In all these setups, the platform takes care of packaging and deployment, as long as you follow their patterns. Most software does not fit one of these templates, hence the existence of all the other options below."
msgstr ""

#: ../source/overview.rst:213
msgid "If you're developing software that will be deployed to machines you own, users' personal computers, or any other arrangement, read on."
msgstr ""

#: ../source/overview.rst:217
msgid "Web browsers and mobile applications"
msgstr ""

#: ../source/overview.rst:219
msgid "Python's steady advances are leading it into new spaces. These days you can write a mobile app or web application frontend in Python. While the language may be familiar, the packaging and deployment practices are brand new."
msgstr ""

#: ../source/overview.rst:224
msgid "If you're planning on releasing to these new frontiers, you'll want to check out the following frameworks, and refer to their packaging guides:"
msgstr ""

#: ../source/overview.rst:228
msgid "`Kivy <https://kivy.org/>`_"
msgstr ""

#: ../source/overview.rst:229
msgid "`Beeware <https://pybee.org/>`_"
msgstr ""

#: ../source/overview.rst:230
msgid "`Brython <https://brython.info/>`_"
msgstr ""

#: ../source/overview.rst:231
msgid "`Flexx <https://flexx.readthedocs.io/en/latest/>`_"
msgstr ""

#: ../source/overview.rst:233
msgid "If you are *not* interested in using a framework or platform, or just wonder about some of the technologies and techniques utilized by the frameworks above, continue reading below."
msgstr ""

#: ../source/overview.rst:238
msgid "Depending on a pre-installed Python"
msgstr ""

#: ../source/overview.rst:240
msgid "Pick an arbitrary computer, and depending on the context, there's a very good chance Python is already installed. Included by default in most Linux and Mac operating systems for many years now, you can reasonably depend on Python preexisting in your data centers or on the personal machines of developers and data scientists."
msgstr ""

#: ../source/overview.rst:246
msgid "Technologies which support this model:"
msgstr ""

#: ../source/overview.rst:248
msgid ":gh:`PEX <pantsbuild/pex#user-content-pex>` (Python EXecutable)"
msgstr ""

#: ../source/overview.rst:249
msgid ":doc:`zipapp <python:library/zipapp>` (does not help manage dependencies, requires Python 3.5+)"
msgstr ""

#: ../source/overview.rst:250
msgid ":gh:`shiv <linkedin/shiv#user-content-shiv>` (requires Python 3)"
msgstr ""

#: ../source/overview.rst:252
msgid "Of all the approaches here, depending on a pre-installed Python relies the most on the target environment. Of course, this also makes for the smallest package, as small as single-digit megabytes, or even kilobytes."
msgstr ""

#: ../source/overview.rst:257
msgid "In general, decreasing the dependency on the target system increases the size of our package, so the solutions here are roughly arranged by increasing size of output."
msgstr ""

#: ../source/overview.rst:264
msgid "Depending on a separate software distribution ecosystem"
msgstr ""

#: ../source/overview.rst:266
msgid "For a long time many operating systems, including Mac and Windows, lacked built-in package management. Only recently did these OSes gain so-called \"app stores\", but even those focus on consumer applications and offer little for developers."
msgstr ""

#: ../source/overview.rst:271
msgid "Developers long sought remedies, and in this struggle, emerged with their own package management solutions, such as `Homebrew <https://brew.sh/>`_. The most relevant alternative for Python developers is a package ecosystem called `Anaconda <https://en.wikipedia.org/wiki/Anaconda_(Python_distribution)>`_. Anaconda is built around Python and is increasingly common in academic, analytical, and other data-oriented environments, even making its way `into server-oriented environments <https://web.archive.org/web/20190403064038/https://www.paypal-engineering.com/2016/09/07/python-packaging-at-paypal/>`_."
msgstr ""

#: ../source/overview.rst:281
msgid "Instructions on building and publishing for the Anaconda ecosystem:"
msgstr ""

#: ../source/overview.rst:283
msgid "`Building libraries and applications with conda <https://conda.io/projects/conda-build/en/latest/user-guide/tutorials/index.html>`_"
msgstr ""

#: ../source/overview.rst:284
msgid "`Transitioning a native Python package to Anaconda <https://conda.io/projects/conda-build/en/latest/user-guide/tutorials/build-pkgs-skeleton.html>`_"
msgstr ""

#: ../source/overview.rst:286
msgid "A similar model involves installing an alternative Python distribution, but does not support arbitrary operating system-level packages:"
msgstr ""

#: ../source/overview.rst:290
msgid "`ActiveState ActivePython <https://www.activestate.com/products/python/>`_"
msgstr ""

#: ../source/overview.rst:291
msgid "`WinPython <http://winpython.github.io/>`_"
msgstr ""

#: ../source/overview.rst:296
msgid "Bringing your own Python executable"
msgstr ""

#: ../source/overview.rst:298
msgid "Computing as we know it is defined by the ability to execute programs. Every operating system natively supports one or more formats of programs they can natively execute."
msgstr ""

#: ../source/overview.rst:302
msgid "There are many techniques and technologies which turn your Python program into one of these formats, most of which involve embedding the Python interpreter and any other dependencies into a single executable file."
msgstr ""

#: ../source/overview.rst:307
msgid "This approach, called *freezing*, offers wide compatibility and seamless user experience, though often requires multiple technologies, and a good amount of effort."
msgstr ""

#: ../source/overview.rst:311
msgid "A selection of Python freezers:"
msgstr ""

#: ../source/overview.rst:313
msgid "`pyInstaller <https://pyinstaller.readthedocs.io/en/stable/>`_ - Cross-platform"
msgstr ""

#: ../source/overview.rst:314
msgid "`cx_Freeze <https://marcelotduarte.github.io/cx_Freeze/>`_ - Cross-platform"
msgstr ""

#: ../source/overview.rst:315
msgid "`constructor <https://github.com/conda/constructor>`_ - For command-line installers"
msgstr ""

#: ../source/overview.rst:316
msgid "`py2exe <http://www.py2exe.org/>`_ - Windows only"
msgstr ""

#: ../source/overview.rst:317
msgid "`py2app <https://py2app.readthedocs.io/en/latest/>`_ - Mac only"
msgstr ""

#: ../source/overview.rst:318
msgid "`osnap <https://github.com/jamesabel/osnap>`_ - Windows and Mac"
msgstr ""

#: ../source/overview.rst:319
msgid "`pynsist <https://pypi.org/project/pynsist/>`_ - Windows only"
msgstr ""

#: ../source/overview.rst:321
msgid "Most of the above imply single-user deployments. For multi-component server applications, see :gh:`Chef Omnibus <chef/omnibus#user-content--omnibus>`."
msgstr ""

#: ../source/overview.rst:327
msgid "Bringing your own userspace"
msgstr ""

#: ../source/overview.rst:329
msgid "An increasing number of operating systems -- including Linux, Mac OS, and Windows -- can be set up to run applications packaged as lightweight images, using a relatively modern arrangement often referred to as `operating-system-level virtualization <https://en.wikipedia.org/wiki/Operating-system-level_virtualization>`_, or *containerization*."
msgstr ""

#: ../source/overview.rst:336
msgid "These techniques are mostly Python agnostic, because they package whole OS filesystems, not just Python or Python packages."
msgstr ""

#: ../source/overview.rst:339
msgid "Adoption is most extensive among Linux servers, where the technology originated and where the technologies below work best:"
msgstr ""

#: ../source/overview.rst:342
msgid "`AppImage <https://appimage.org/>`_"
msgstr ""

#: ../source/overview.rst:343
msgid "`Docker <https://www.fullstackpython.com/docker.html>`_"
msgstr ""

#: ../source/overview.rst:344
msgid "`Flatpak <https://flatpak.org/>`_"
msgstr ""

#: ../source/overview.rst:345
msgid "`Snapcraft <https://snapcraft.io/>`_"
msgstr ""

#: ../source/overview.rst:348
msgid "Bringing your own kernel"
msgstr ""

#: ../source/overview.rst:350
msgid "Most operating systems support some form of classical virtualization, running applications packaged as images containing a full operating system of their own. Running these virtual machines, or VMs, is a mature approach, widespread in data center environments."
msgstr ""

#: ../source/overview.rst:355
msgid "These techniques are mostly reserved for larger scale deployments in data centers, though certain complex applications can benefit from this packaging. The technologies are Python agnostic, and include:"
msgstr ""

#: ../source/overview.rst:359
msgid "`Vagrant <https://www.vagrantup.com/>`_"
msgstr ""

#: ../source/overview.rst:360
msgid "`VHD <https://en.wikipedia.org/wiki/VHD_(file_format)>`_, `AMI <https://en.wikipedia.org/wiki/Amazon_Machine_Image>`_, and :doc:`other formats <openstack:user/formats>`"
msgstr ""

#: ../source/overview.rst:361
msgid "`OpenStack <https://www.redhat.com/en/topics/openstack>`_ - A cloud management system in Python, with extensive VM support"
msgstr ""

#: ../source/overview.rst:364
msgid "Bringing your own hardware"
msgstr ""

#: ../source/overview.rst:366
msgid "The most all-encompassing way to ship your software would be to ship it already-installed on some hardware. This way, your software's user would require only electricity."
msgstr ""

#: ../source/overview.rst:370
msgid "Whereas the virtual machines described above are primarily reserved for the tech-savvy, you can find hardware appliances being used by everyone from the most advanced data centers to the youngest children."
msgstr ""

#: ../source/overview.rst:374
msgid "Embed your code on an :gh:`Adafruit <adafruit/circuitpython>`, `MicroPython <https://micropython.org/>`_, or more-powerful hardware running Python, then ship it to the datacenter or your users' homes. They plug and play, and you can call it a day."
msgstr ""

#: ../source/overview.rst:383
msgid "A summary of technologies used to package Python applications."
msgstr ""

#: ../source/overview.rst:383
msgid "The simplified gamut of technologies used to package Python applications."
msgstr ""

#: ../source/overview.rst:386
msgid "What about..."
msgstr ""

#: ../source/overview.rst:388
msgid "The sections above can only summarize so much, and you might be wondering about some of the more conspicuous gaps."
msgstr ""

#: ../source/overview.rst:392
msgid "Operating system packages"
msgstr ""

#: ../source/overview.rst:394
msgid "As mentioned in :ref:`depending-on-a-separate-ecosystem` above, some operating systems have package managers of their own. If you're very sure of the operating system you're targeting, you can depend directly on a format like `deb <https://en.wikipedia.org/wiki/Deb_(file_format)>`_ (for Debian, Ubuntu, etc.) or `RPM <https://en.wikipedia.org/wiki/RPM_Package_Manager>`_ (for Red Hat, Fedora, etc.), and use that built-in package manager to take care of installation, and even deployment. You can even use `FPM <https://fpm.readthedocs.io/en/latest/cli-reference.html#virtualenv>`_ to generate both deb and RPMs from the same source."
msgstr ""

#: ../source/overview.rst:405
msgid "In most deployment pipelines, the OS package manager is just one piece of the puzzle."
msgstr ""

#: ../source/overview.rst:411
msgid ":doc:`Virtualenvs <python-guide:dev/virtualenvs>` have been an indispensable tool for multiple generations of Python developer, but are slowly fading from view, as they are being wrapped by higher-level tools. With packaging in particular, virtualenvs are used as a primitive in :doc:`the dh-virtualenv tool <dh-virtualenv:tutorial>` and `osnap <https://github.com/jamesabel/osnap>`_, both of which wrap virtualenvs in a self-contained way."
msgstr ""

#: ../source/overview.rst:420
msgid "For production deployments, do not rely on running ``python -m pip install`` from the Internet into a virtualenv, as one might do in a development environment. The overview above is full of much better solutions."
msgstr ""

#: ../source/overview.rst:425
msgid "Security"
msgstr ""

#: ../source/overview.rst:427
msgid "The further down the gradient you come, the harder it gets to update components of your package. Everything is more tightly bound together."
msgstr ""

#: ../source/overview.rst:430
msgid "For example, if a kernel security issue emerges, and you're deploying containers, the host system's kernel can be updated without requiring a new build on behalf of the application. If you deploy VM images, you'll need a new build. Whether or not this dynamic makes one option more secure is still a bit of an old debate, going back to the still-unsettled matter of `static versus dynamic linking <https://www.google.com/search?channel=fs&q=static+vs+dynamic+linking>`_."
msgstr ""

#: ../source/overview.rst:439
msgid "Wrap up"
msgstr ""

#: ../source/overview.rst:441
msgid "Packaging in Python has a bit of a reputation for being a bumpy ride. This impression is mostly a byproduct of Python's versatility. Once you understand the natural boundaries between each packaging solution, you begin to realize that the varied landscape is a small price Python programmers pay for using one of the most balanced, flexible languages available."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:6
msgid "Binary distribution format"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:8
msgid "The binary distribution format (:term:`wheel <Wheel>`) was originally defined in :pep:`427`. The current version of the specification is here."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:13
msgid "Abstract"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:15
msgid "This PEP describes a built-package format for Python called \"wheel\"."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:17
msgid "A wheel is a ZIP-format archive with a specially formatted file name and the ``.whl`` extension.  It contains a single distribution nearly as it would be installed according to PEP 376 with a particular installation scheme.  Although a specialized installer is recommended, a wheel file may be installed by simply unpacking into site-packages with the standard 'unzip' tool while preserving enough information to spread its contents out onto their final paths at any later time."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:27
msgid "PEP Acceptance"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:29
msgid "This PEP was accepted, and the defined wheel version updated to 1.0, by Nick Coghlan on 16th February, 2013 [1]_"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:34
msgid "Rationale"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:36
msgid "Python needs a package format that is easier to install than sdist. Python's sdist packages are defined by and require the distutils and setuptools build systems, running arbitrary code to build-and-install, and re-compile, code just so it can be installed into a new virtualenv.  This system of conflating build-install is slow, hard to maintain, and hinders innovation in both build systems and installers."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:43
msgid "Wheel attempts to remedy these problems by providing a simpler interface between the build system and the installer.  The wheel binary package format frees installers from having to know about the build system, saves time by amortizing compile time over many installations, and removes the need to install a build system in the target environment."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:52
#: ../source/specifications/platform-compatibility-tags.rst:46
msgid "Details"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:55
msgid "Installing a wheel 'distribution-1.0-py32-none-any.whl'"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:57
msgid "Wheel installation notionally consists of two phases:"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:59
msgid "Unpack."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:61
msgid "Parse ``distribution-1.0.dist-info/WHEEL``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:62
msgid "Check that installer is compatible with Wheel-Version.  Warn if minor version is greater, abort if major version is greater."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:64
msgid "If Root-Is-Purelib == 'true', unpack archive into purelib (site-packages)."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:66
msgid "Else unpack archive into platlib (site-packages)."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:68
msgid "Spread."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:70
msgid "Unpacked archive includes ``distribution-1.0.dist-info/`` and (if there is data) ``distribution-1.0.data/``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:72
msgid "Move each subtree of ``distribution-1.0.data/`` onto its destination path. Each subdirectory of ``distribution-1.0.data/`` is a key into a dict of destination directories, such as ``distribution-1.0.data/(purelib|platlib|headers|scripts|data)``. The initially supported paths are taken from ``distutils.command.install``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:78
msgid "If applicable, update scripts starting with ``#!python`` to point to the correct interpreter."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:80
msgid "Update ``distribution-1.0.dist-info/RECORD`` with the installed paths."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:82
msgid "Remove empty ``distribution-1.0.data`` directory."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:83
msgid "Compile any installed .py to .pyc. (Uninstallers should be smart enough to remove .pyc even if it is not mentioned in RECORD.)"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:87
msgid "Recommended installer features"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:97
msgid "Rewrite ``#!python``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:90
msgid "In wheel, scripts are packaged in ``{distribution}-{version}.data/scripts/``.  If the first line of a file in ``scripts/`` starts with exactly ``b'#!python'``, rewrite to point to the correct interpreter.  Unix installers may need to add the +x bit to these files if the archive was created on Windows."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:96
msgid "The ``b'#!pythonw'`` convention is allowed. ``b'#!pythonw'`` indicates a GUI script instead of a console script."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:102
msgid "Generate script wrappers."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:100
msgid "In wheel, scripts packaged on Unix systems will certainly not have accompanying .exe wrappers.  Windows installers may want to add them during install."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:105
msgid "Recommended archiver features"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:112
msgid "Place ``.dist-info`` at the end of the archive."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:108
msgid "Archivers are encouraged to place the ``.dist-info`` files physically at the end of the archive.  This enables some potentially interesting ZIP tricks including the ability to amend the metadata without rewriting the entire archive."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:115
msgid "File Format"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:118
msgid "File name convention"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:120
msgid "The wheel filename is ``{distribution}-{version}(-{build tag})?-{python tag}-{abi tag}-{platform tag}.whl``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:124
msgid "distribution"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:124
msgid "Distribution name, e.g. 'django', 'pyramid'."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:127
msgid "version"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:127
msgid "Distribution version, e.g. 1.0."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:152
msgid "build tag"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:130
msgid "Optional build number.  Must start with a digit.  Acts as a tie-breaker if two wheel file names are the same in all other respects (i.e. name, version, and other tags).  Sort as an empty tuple if unspecified, else sort as a two-item tuple with the first item being the initial digits as an ``int``, and the second item being the remainder of the tag as a ``str``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:137
msgid "A common use-case for build numbers is rebuilding a binary distribution due to a change in the build environment, like when using the manylinux image to build distributions using pre-release CPython versions."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:144
msgid "Build numbers are not a part of the distribution version and thus are difficult to reference externally, especially so outside the Python ecosystem of tools and standards. A common case where a distribution would need to referenced externally is when resolving a security vulnerability."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:149
msgid "Due to this limitation, new distributions which need to be referenced externally **should not** use build numbers when building the new distribution. Instead a **new distribution version** should be created for such cases."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:155
msgid "language implementation and version tag"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:155
msgid "E.g. 'py27', 'py2', 'py3'."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:158
#: ../source/specifications/platform-compatibility-tags.rst:27
msgid "abi tag"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:158
msgid "E.g. 'cp33m', 'abi3', 'none'."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:161
#: ../source/specifications/platform-compatibility-tags.rst:30
msgid "platform tag"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:161
msgid "E.g. 'linux_x86_64', 'any'."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:163
msgid "For example, ``distribution-1.0-1-py27-none-any.whl`` is the first build of a package called 'distribution', and is compatible with Python 2.7 (any Python 2.7 implementation), with no ABI (pure Python), on any CPU architecture."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:168
msgid "The last three components of the filename before the extension are called \"compatibility tags.\"  The compatibility tags express the package's basic interpreter requirements and are detailed in PEP 425."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:173
msgid "Escaping and Unicode"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:175
msgid "As the components of the filename are separated by a dash (``-``, HYPHEN-MINUS), this character cannot appear within any component. This is handled as follows:"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:178
msgid "In distribution names, any run of ``-_.`` characters (HYPHEN-MINUS, LOW LINE and FULL STOP) should be replaced with ``_`` (LOW LINE), and uppercase characters should be replaced with corresponding lowercase ones. This is equivalent to regular :ref:`name normalization <name-normalization>` followed by replacing ``-`` with ``_``. Tools consuming wheels must be prepared to accept ``.`` (FULL STOP) and uppercase letters, however, as these were allowed by an earlier version of this specification."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:185
msgid "Version numbers should be normalised according to the :ref:`Version specifier specification <version-specifiers>`. Normalised version numbers cannot contain ``-``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:187
msgid "The remaining components may not contain ``-`` characters, so no escaping is necessary."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:190
msgid "Tools producing wheels should verify that the filename components do not contain ``-``, as the resulting file may not be processed correctly if they do."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:193
msgid "The archive filename is Unicode.  It will be some time before the tools are updated to support non-ASCII filenames, but they are supported in this specification."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:197
msgid "The filenames *inside* the archive are encoded as UTF-8.  Although some ZIP clients in common use do not properly display UTF-8 filenames, the encoding is supported by both the ZIP specification and Python's ``zipfile``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:203
msgid "File contents"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:205
msgid "The contents of a wheel file, where {distribution} is replaced with the name of the package, e.g. ``beaglevote`` and {version} is replaced with its version, e.g. ``1.0.0``, consist of:"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:209
msgid "``/``, the root of the archive, contains all files to be installed in ``purelib`` or ``platlib`` as specified in ``WHEEL``.  ``purelib`` and ``platlib`` are usually both ``site-packages``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:212
msgid "``{distribution}-{version}.dist-info/`` contains metadata."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:213
msgid "``{distribution}-{version}.data/`` contains one subdirectory for each non-empty install scheme key not already covered, where the subdirectory name is an index into a dictionary of install paths (e.g. ``data``, ``scripts``, ``headers``, ``purelib``, ``platlib``)."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:217
msgid "Python scripts must appear in ``scripts`` and begin with exactly ``b'#!python'`` in order to enjoy script wrapper generation and ``#!python`` rewriting at install time.  They may have any or no extension."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:221
msgid "``{distribution}-{version}.dist-info/METADATA`` is Metadata version 1.1 or greater format metadata."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:223
msgid "``{distribution}-{version}.dist-info/WHEEL`` is metadata about the archive itself in the same basic key: value format::"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:233
msgid "``Wheel-Version`` is the version number of the Wheel specification."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:234
msgid "``Generator`` is the name and optionally the version of the software that produced the archive."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:236
msgid "``Root-Is-Purelib`` is true if the top level directory of the archive should be installed into purelib; otherwise the root should be installed into platlib."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:239
msgid "``Tag`` is the wheel's expanded compatibility tags; in the example the filename would contain ``py2.py3-none-any``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:241
msgid "``Build`` is the build number and is omitted if there is no build number."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:242
msgid "A wheel installer should warn if Wheel-Version is greater than the version it supports, and must fail if Wheel-Version has a greater major version than the version it supports."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:245
msgid "Wheel, being an installation format that is intended to work across multiple versions of Python, does not generally include .pyc files."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:247
msgid "Wheel does not contain setup.py or setup.cfg."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:249
msgid "This version of the wheel specification is based on the distutils install schemes and does not define how to install files to other locations. The layout offers a superset of the functionality provided by the existing wininst and egg binary formats."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:256
#: ../source/specifications/recording-installed-packages.rst:37
msgid "The .dist-info directory"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:258
msgid "Wheel .dist-info directories include at a minimum METADATA, WHEEL, and RECORD."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:260
msgid "METADATA is the package metadata, the same format as PKG-INFO as found at the root of sdists."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:262
msgid "WHEEL is the wheel metadata specific to a build of the package."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:263
msgid "RECORD is a list of (almost) all the files in the wheel and their secure hashes.  Unlike PEP 376, every file except RECORD, which cannot contain a hash of itself, must include its hash.  The hash algorithm must be sha256 or better; specifically, md5 and sha1 are not permitted, as signed wheel files rely on the strong hashes in RECORD to validate the integrity of the archive."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:269
msgid "PEP 376's INSTALLER and REQUESTED are not included in the archive."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:270
msgid "RECORD.jws is used for digital signatures.  It is not mentioned in RECORD."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:272
msgid "RECORD.p7s is allowed as a courtesy to anyone who would prefer to use S/MIME signatures to secure their wheel files.  It is not mentioned in RECORD."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:275
msgid "During extraction, wheel installers verify all the hashes in RECORD against the file contents.  Apart from RECORD and its signatures, installation will fail if any file in the archive is not both mentioned and correctly hashed in RECORD."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:282
msgid "The .data directory"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:284
msgid "Any file that is not normally installed inside site-packages goes into the .data directory, named as the .dist-info directory but with the .data/ extension::"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:292
msgid "The .data directory contains subdirectories with the scripts, headers, documentation and so forth from the distribution.  During installation the contents of these subdirectories are moved onto their destination paths."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:298
msgid "Signed wheel files"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:300
msgid "Wheel files include an extended RECORD that enables digital signatures.  PEP 376's RECORD is altered to include a secure hash ``digestname=urlsafe_b64encode_nopad(digest)`` (urlsafe base64 encoding with no trailing = characters) as the second column instead of an md5sum.  All possible entries are hashed, including any generated files such as .pyc files, but not RECORD which cannot contain its own hash. For example::"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:311
msgid "The signature file(s) RECORD.jws and RECORD.p7s are not mentioned in RECORD at all since they can only be added after RECORD is generated. Every other file in the archive must have a correct hash in RECORD or the installation will fail."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:316
msgid "If JSON web signatures are used, one or more JSON Web Signature JSON Serialization (JWS-JS) signatures is stored in a file RECORD.jws adjacent to RECORD.  JWS is used to sign RECORD by including the SHA-256 hash of RECORD as the signature's JSON payload::"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:323
msgid "(The hash value is the same format used in RECORD.)"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:325
msgid "If RECORD.p7s is used, it must contain a detached S/MIME format signature of RECORD."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:328
msgid "A wheel installer is not required to understand digital signatures but MUST verify the hashes in RECORD against the extracted file contents. When the installer checks file hashes against RECORD, a separate signature checker only needs to establish that RECORD matches the signature."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:333
msgid "See"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:335
msgid "https://datatracker.ietf.org/doc/html/rfc7515"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:336
msgid "https://datatracker.ietf.org/doc/html/draft-jones-json-web-signature-json-serialization-01"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:337
msgid "https://datatracker.ietf.org/doc/html/rfc7517"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:338
msgid "https://datatracker.ietf.org/doc/html/draft-jones-jose-json-private-key-01"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:342
msgid "Comparison to .egg"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:344
msgid "Wheel is an installation format; egg is importable.  Wheel archives do not need to include .pyc and are less tied to a specific Python version or implementation. Wheel can install (pure Python) packages built with previous versions of Python so you don't always have to wait for the packager to catch up."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:349
msgid "Wheel uses .dist-info directories; egg uses .egg-info.  Wheel is compatible with the new world of Python packaging and the new concepts it brings."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:352
msgid "Wheel has a richer file naming convention for today's multi-implementation world.  A single wheel archive can indicate its compatibility with a number of Python language versions and implementations, ABIs, and system architectures.  Historically the ABI has been specific to a CPython release, wheel is ready for the stable ABI."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:358
msgid "Wheel is lossless.  The first wheel implementation bdist_wheel always generates egg-info, and then converts it to a .whl.  It is also possible to convert existing eggs and bdist_wininst distributions."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:362
msgid "Wheel is versioned.  Every wheel file contains the version of the wheel specification and the implementation that packaged it. Hopefully the next migration can simply be to Wheel 2.0."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:365
msgid "Wheel is a reference to the other Python."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:369
#: ../source/specifications/platform-compatibility-tags.rst:244
msgid "FAQ"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:373
msgid "Wheel defines a .data directory.  Should I put all my data there?"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:375
msgid "This specification does not have an opinion on how you should organize your code.  The .data directory is just a place for any files that are not normally installed inside ``site-packages`` or on the PYTHONPATH. In other words, you may continue to use ``pkgutil.get_data(package, resource)`` even though *those* files will usually not be distributed in *wheel's* ``.data`` directory."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:384
msgid "Why does wheel include attached signatures?"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:386
msgid "Attached signatures are more convenient than detached signatures because they travel with the archive.  Since only the individual files are signed, the archive can be recompressed without invalidating the signature or individual files can be verified without having to download the whole archive."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:394
msgid "Why does wheel allow JWS signatures?"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:396
msgid "The JOSE specifications of which JWS is a part are designed to be easy to implement, a feature that is also one of wheel's primary design goals.  JWS yields a useful, concise pure-Python implementation."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:402
msgid "Why does wheel also allow S/MIME signatures?"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:404
msgid "S/MIME signatures are allowed for users who need or want to use existing public key infrastructure with wheel."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:407
msgid "Signed packages are only a basic building block in a secure package update system.  Wheel only provides the building block."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:412
msgid "What's the deal with \"purelib\" vs. \"platlib\"?"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:414
msgid "Wheel preserves the \"purelib\" vs. \"platlib\" distinction, which is significant on some platforms. For example, Fedora installs pure Python packages to '/usr/lib/pythonX.Y/site-packages' and platform dependent packages to '/usr/lib64/pythonX.Y/site-packages'."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:419
msgid "A wheel with \"Root-Is-Purelib: false\" with all its files in ``{name}-{version}.data/purelib`` is equivalent to a wheel with \"Root-Is-Purelib: true\" with those same files in the root, and it is legal to have files in both the \"purelib\" and \"platlib\" categories."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:424
msgid "In practice a wheel should have only one of \"purelib\" or \"platlib\" depending on whether it is pure Python or not and those files should be at the root with the appropriate setting given for \"Root-is-purelib\"."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:432
msgid "Is it possible to import Python code directly from a wheel file?"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:434
msgid "Technically, due to the combination of supporting installation via simple extraction and using an archive format that is compatible with ``zipimport``, a subset of wheel files *do* support being placed directly on ``sys.path``. However, while this behaviour is a natural consequence of the format design, actually relying on it is generally discouraged."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:440
msgid "Firstly, wheel *is* designed primarily as a distribution format, so skipping the installation step also means deliberately avoiding any reliance on features that assume full installation (such as being able to use standard tools like ``pip`` and ``virtualenv`` to capture and manage dependencies in a way that can be properly tracked for auditing and security update purposes, or integrating fully with the standard build machinery for C extensions by publishing header files in the appropriate place)."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:449
msgid "Secondly, while some Python software is written to support running directly from a zip archive, it is still common for code to be written assuming it has been fully installed. When that assumption is broken by trying to run the software from a zip archive, the failures can often be obscure and hard to diagnose (especially when they occur in third party libraries). The two most common sources of problems with this are the fact that importing C extensions from a zip archive is *not* supported by CPython (since doing so is not supported directly by the dynamic loading machinery on any platform) and that when running from a zip archive the ``__file__`` attribute no longer refers to an ordinary filesystem path, but to a combination path that includes both the location of the zip archive on the filesystem and the relative path to the module inside the archive. Even when software correctly uses the abstract resource APIs internally, interfacing with external components may still require the availability of an actual on-disk file."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:466
msgid "Like metaclasses, monkeypatching and metapath importers, if you're not already sure you need to take advantage of this feature, you almost certainly don't need it. If you *do* decide to use it anyway, be aware that many projects will require a failure to be reproduced with a fully installed package before accepting it as a genuine bug."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:473
msgid "Changes"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:475
msgid "Since :pep:`427`, this specification has changed as follows:"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:477
msgid "The rules on escaping in wheel filenames were revised, to bring them into line with what popular tools actually do (February 2021)."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:484
msgid "PEP acceptance (https://mail.python.org/pipermail/python-dev/2013-February/124103.html)"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:489
msgid "Appendix"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:491
msgid "Example urlsafe-base64-nopad implementation::"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:505
#: ../source/specifications/externally-managed-environments.rst:464
msgid "Copyright"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:507
msgid "This document has been placed into the public domain."
msgstr ""

#: ../source/specifications/core-metadata.rst:5
msgid "Core metadata specifications"
msgstr ""

#: ../source/specifications/core-metadata.rst:7
msgid "Fields defined in the following specification should be considered valid, complete and not subject to change. The required fields are:"
msgstr ""

#: ../source/specifications/core-metadata.rst:10
msgid "``Metadata-Version``"
msgstr ""

#: ../source/specifications/core-metadata.rst:11
msgid "``Name``"
msgstr ""

#: ../source/specifications/core-metadata.rst:12
msgid "``Version``"
msgstr ""

#: ../source/specifications/core-metadata.rst:14
msgid "All the other fields are optional."
msgstr ""

#: ../source/specifications/core-metadata.rst:16
msgid "The standard file format for metadata (including in :doc:`wheels <binary-distribution-format>` and :doc:`installed projects <recording-installed-packages>`) is based on the format of email headers. However, email formats have been revised several times, and exactly which email RFC applies to packaging metadata is not specified. In the absence of a precise definition, the practical standard is set by what the standard library :mod:`python:email.parser` module can parse using the :data:`~.python:email.policy.compat32` policy."
msgstr ""

#: ../source/specifications/core-metadata.rst:25
msgid "Whenever metadata is serialised to a byte stream (for example, to save to a file), strings must be serialised using the UTF-8 encoding."
msgstr ""

#: ../source/specifications/core-metadata.rst:28
msgid "Although :pep:`566` defined a way to transform metadata into a JSON-compatible dictionary, this is not yet used as a standard interchange format. The need for tools to work with years worth of existing packages makes it difficult to shift to a new format."
msgstr ""

#: ../source/specifications/core-metadata.rst:33
msgid "*Interpreting old metadata:* In :pep:`566`, the version specifier field format specification was relaxed to accept the syntax used by popular publishing tools (namely to remove the requirement that version specifiers must be surrounded by parentheses). Metadata consumers may want to use the more relaxed formatting rules even for metadata files that are nominally less than version 2.1."
msgstr ""

#: ../source/specifications/core-metadata.rst:44
msgid "Metadata-Version"
msgstr ""

#: ../source/specifications/core-metadata.rst:48
msgid "Version of the file format; legal values are \"1.0\", \"1.1\", \"1.2\", \"2.1\", \"2.2\", and \"2.3\"."
msgstr ""

#: ../source/specifications/core-metadata.rst:51
msgid "Automated tools consuming metadata SHOULD warn if ``metadata_version`` is greater than the highest version they support, and MUST fail if ``metadata_version`` has a greater major version than the highest version they support (as described in the :ref:`Version specifier specification <version-specifiers>`, the major version is the value before the first dot)."
msgstr ""

#: ../source/specifications/core-metadata.rst:58
msgid "For broader compatibility, build tools MAY choose to produce distribution metadata using the lowest metadata version that includes all of the needed fields."
msgstr ""

#: ../source/specifications/core-metadata.rst:62
#: ../source/specifications/core-metadata.rst:84
#: ../source/specifications/core-metadata.rst:101
#: ../source/specifications/core-metadata.rst:166
#: ../source/specifications/core-metadata.rst:181
#: ../source/specifications/core-metadata.rst:219
#: ../source/specifications/core-metadata.rst:291
#: ../source/specifications/core-metadata.rst:295
#: ../source/specifications/core-metadata.rst:299
#: ../source/specifications/core-metadata.rst:303
#: ../source/specifications/core-metadata.rst:335
#: ../source/specifications/core-metadata.rst:356
#: ../source/specifications/core-metadata.rst:383
#: ../source/specifications/core-metadata.rst:401
#: ../source/specifications/core-metadata.rst:426
#: ../source/specifications/core-metadata.rst:448
#: ../source/specifications/core-metadata.rst:611
#: ../source/specifications/core-metadata.rst:642
#: ../source/specifications/core-metadata.rst:652
#: ../source/specifications/core-metadata.rst:844
msgid "Example::"
msgstr ""

#: ../source/specifications/core-metadata.rst:70
msgid "Name"
msgstr ""

#: ../source/specifications/core-metadata.rst:73
msgid "Added additional restrictions on format from :pep:`508`"
msgstr ""

#: ../source/specifications/core-metadata.rst:76
msgid "The name of the distribution. The name field is the primary identifier for a distribution. A valid name consists only of ASCII letters and numbers, period, underscore and hyphen. It must start and end with a letter or number. Distribution names are limited to those which match the following regex (run with ``re.IGNORECASE``)::"
msgstr ""

#: ../source/specifications/core-metadata.rst:88
msgid "For comparison purposes, the names should be :ref:`normalized <name-normalization>` before comparing."
msgstr ""

#: ../source/specifications/core-metadata.rst:93
msgid "Version"
msgstr ""

#: ../source/specifications/core-metadata.rst:97
msgid "A string containing the distribution's version number.  This field  must be in the format specified in the :ref:`Version specifier specification <version-specifiers>`."
msgstr ""

#: ../source/specifications/core-metadata.rst:109
msgid "Dynamic (multiple use)"
msgstr ""

#: ../source/specifications/core-metadata.rst:113
msgid "A string containing the name of another core metadata field. The field names ``Name``, ``Version``, and ``Metadata-Version`` may not be specified in this field."
msgstr ""

#: ../source/specifications/core-metadata.rst:117
msgid "When found in the metadata of a source distribution, the following rules apply:"
msgstr ""

#: ../source/specifications/core-metadata.rst:120
msgid "If a field is *not* marked as ``Dynamic``, then the value of the field in any wheel built from the sdist MUST match the value in the sdist. If the field is not in the sdist, and not marked as ``Dynamic``, then it MUST NOT be present in the wheel."
msgstr ""

#: ../source/specifications/core-metadata.rst:124
msgid "If a field is marked as ``Dynamic``, it may contain any valid value in a wheel built from the sdist (including not being present at all)."
msgstr ""

#: ../source/specifications/core-metadata.rst:127
msgid "If the sdist metadata version is older than version 2.2, then all fields should be treated as if they were specified with ``Dynamic`` (i.e. there are no special restrictions on the metadata of wheels built from the sdist)."
msgstr ""

#: ../source/specifications/core-metadata.rst:131
msgid "In any context other than a source distribution, ``Dynamic`` is for information only, and indicates that the field value was calculated at wheel build time, and may not be the same as the value in the sdist or in other wheels for the project."
msgstr ""

#: ../source/specifications/core-metadata.rst:136
msgid "Full details of the semantics of ``Dynamic`` are described in :pep:`643`."
msgstr ""

#: ../source/specifications/core-metadata.rst:141
msgid "Platform (multiple use)"
msgstr ""

#: ../source/specifications/core-metadata.rst:145
msgid "A Platform specification describing an operating system supported by the distribution which is not listed in the \"Operating System\" Trove classifiers. See \"Classifier\" below."
msgstr ""

#: ../source/specifications/core-metadata.rst:157
msgid "Supported-Platform (multiple use)"
msgstr ""

#: ../source/specifications/core-metadata.rst:161
msgid "Binary distributions containing a PKG-INFO file will use the Supported-Platform field in their metadata to specify the OS and CPU for which the binary distribution was compiled.  The semantics of the Supported-Platform field are not specified in this PEP."
msgstr ""

#: ../source/specifications/core-metadata.rst:175
msgid "Summary"
msgstr ""

#: ../source/specifications/core-metadata.rst:179
msgid "A one-line summary of what the distribution does."
msgstr ""

#: ../source/specifications/core-metadata.rst:199
msgid "This field may be specified in the message body instead."
msgstr ""

#: ../source/specifications/core-metadata.rst:202
msgid "A longer description of the distribution that can run to several paragraphs.  Software that deals with metadata should not assume any maximum size for this field, though people shouldn't include their instruction manual as the description."
msgstr ""

#: ../source/specifications/core-metadata.rst:207
msgid "The contents of this field can be written using reStructuredText markup [1]_.  For programs that work with the metadata, supporting markup is optional; programs can also display the contents of the field as-is.  This means that authors should be conservative in the markup they use."
msgstr ""

#: ../source/specifications/core-metadata.rst:213
msgid "To support empty lines and lines with indentation with respect to the RFC 822 format, any CRLF character has to be suffixed by 7 spaces followed by a pipe (\"|\") char. As a result, the Description field is encoded into a folded field that can be interpreted by RFC822 parser [2]_."
msgstr ""

#: ../source/specifications/core-metadata.rst:230
msgid "This encoding implies that any occurrences of a CRLF followed by 7 spaces and a pipe char have to be replaced by a single CRLF when the field is unfolded using a RFC822 reader."
msgstr ""

#: ../source/specifications/core-metadata.rst:234
msgid "Alternatively, the distribution's description may instead be provided in the message body (i.e., after a completely blank line following the headers, with no indentation or other special formatting necessary)."
msgstr ""

#: ../source/specifications/core-metadata.rst:243
msgid "Description-Content-Type"
msgstr ""

#: ../source/specifications/core-metadata.rst:247
msgid "A string stating the markup syntax (if any) used in the distribution's description, so that tools can intelligently render the description."
msgstr ""

#: ../source/specifications/core-metadata.rst:250
msgid "Historically, PyPI supported descriptions in plain text and `reStructuredText (reST) <https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html>`_, and could render reST into HTML. However, it is common for distribution authors to write the description in `Markdown <https://daringfireball.net/projects/markdown/>`_ (:rfc:`7763`) as many code hosting sites render Markdown READMEs, and authors would reuse the file for the description. PyPI didn't recognize the format and so could not render the description correctly. This resulted in many packages on PyPI with poorly-rendered descriptions when Markdown is left as plain text, or worse, was attempted to be rendered as reST. This field allows the distribution author to specify the format of their description, opening up the possibility for PyPI and other tools to be able to render Markdown and other formats."
msgstr ""

#: ../source/specifications/core-metadata.rst:263
msgid "The format of this field is the same as the ``Content-Type`` header in HTTP (i.e.: `RFC 1341 <https://www.w3.org/Protocols/rfc1341/4_Content-Type.html>`_). Briefly, this means that it has a ``type/subtype`` part and then it can optionally have a number of parameters:"
msgstr ""

#: ../source/specifications/core-metadata.rst:269
msgid "Format::"
msgstr ""

#: ../source/specifications/core-metadata.rst:273
msgid "The ``type/subtype`` part has only a few legal values:"
msgstr ""

#: ../source/specifications/core-metadata.rst:275
msgid "``text/plain``"
msgstr ""

#: ../source/specifications/core-metadata.rst:276
msgid "``text/x-rst``"
msgstr ""

#: ../source/specifications/core-metadata.rst:277
msgid "``text/markdown``"
msgstr ""

#: ../source/specifications/core-metadata.rst:279
msgid "The ``charset`` parameter can be used to specify the character encoding of the description. The only legal value is ``UTF-8``. If omitted, it is assumed to be ``UTF-8``."
msgstr ""

#: ../source/specifications/core-metadata.rst:283
msgid "Other parameters might be specific to the chosen subtype. For example, for the ``markdown`` subtype, there is an optional ``variant`` parameter that allows specifying the variant of Markdown in use (defaults to ``GFM`` if not specified). Currently, two variants are recognized:"
msgstr ""

#: ../source/specifications/core-metadata.rst:288
msgid "``GFM`` for :rfc:`GitHub-flavored Markdown <7764#section-3.2>`"
msgstr ""

#: ../source/specifications/core-metadata.rst:289
msgid "``CommonMark`` for :rfc:`CommonMark <7764#section-3.5>`"
msgstr ""

#: ../source/specifications/core-metadata.rst:307
msgid "If a ``Description-Content-Type`` is not specified, then applications should attempt to render it as ``text/x-rst; charset=UTF-8`` and fall back to ``text/plain`` if it is not valid rst."
msgstr ""

#: ../source/specifications/core-metadata.rst:311
msgid "If a ``Description-Content-Type`` is an unrecognized value, then the assumed content type is ``text/plain`` (Although PyPI will probably reject anything with an unrecognized value)."
msgstr ""

#: ../source/specifications/core-metadata.rst:315
msgid "If the ``Description-Content-Type`` is ``text/markdown`` and ``variant`` is not specified or is set to an unrecognized value, then the assumed ``variant`` is ``GFM``."
msgstr ""

#: ../source/specifications/core-metadata.rst:319
msgid "So for the last example above, the ``charset`` defaults to ``UTF-8`` and the ``variant`` defaults to ``GFM`` and thus it is equivalent to the example before it."
msgstr ""

#: ../source/specifications/core-metadata.rst:328
msgid "Keywords"
msgstr ""

#: ../source/specifications/core-metadata.rst:332
msgid "A list of additional keywords, separated by commas, to be used to assist searching for the distribution in a larger catalog."
msgstr ""

#: ../source/specifications/core-metadata.rst:341
msgid "The specification previously showed keywords separated by spaces, but distutils and setuptools implemented it with commas. These tools have been very widely used for many years, so it was easier to update the specification to match the de facto standard."
msgstr ""

#: ../source/specifications/core-metadata.rst:350
msgid "Home-page"
msgstr ""

#: ../source/specifications/core-metadata.rst:354
msgid "A string containing the URL for the distribution's home page."
msgstr ""

#: ../source/specifications/core-metadata.rst:363
msgid "Download-URL"
msgstr ""

#: ../source/specifications/core-metadata.rst:367
msgid "A string containing the URL from which this version of the distribution can be downloaded.  (This means that the URL can't be something like \".../BeagleVote-latest.tgz\", but instead must be \".../BeagleVote-0.45.tgz\".)"
msgstr ""

#: ../source/specifications/core-metadata.rst:376
msgid "Author"
msgstr ""

#: ../source/specifications/core-metadata.rst:380
msgid "A string containing the author's name at a minimum; additional contact information may be provided."
msgstr ""

#: ../source/specifications/core-metadata.rst:393
msgid "Author-email"
msgstr ""

#: ../source/specifications/core-metadata.rst:397
msgid "A string containing the author's e-mail address.  It can contain a name and e-mail address in the legal forms for a RFC-822 ``From:`` header."
msgstr ""

#: ../source/specifications/core-metadata.rst:405
#: ../source/specifications/core-metadata.rst:452
msgid "Per RFC-822, this field may contain multiple comma-separated e-mail addresses::"
msgstr ""

#: ../source/specifications/core-metadata.rst:415
msgid "Maintainer"
msgstr ""

#: ../source/specifications/core-metadata.rst:419
msgid "A string containing the maintainer's name at a minimum; additional contact information may be provided."
msgstr ""

#: ../source/specifications/core-metadata.rst:422
msgid "Note that this field is intended for use when a project is being maintained by someone other than the original author:  it should be omitted if it is identical to ``Author``."
msgstr ""

#: ../source/specifications/core-metadata.rst:436
msgid "Maintainer-email"
msgstr ""

#: ../source/specifications/core-metadata.rst:440
msgid "A string containing the maintainer's e-mail address.  It can contain a name and e-mail address in the legal forms for a RFC-822 ``From:`` header."
msgstr ""

#: ../source/specifications/core-metadata.rst:444
msgid "Note that this field is intended for use when a project is being maintained by someone other than the original author:  it should be omitted if it is identical to ``Author-email``."
msgstr ""

#: ../source/specifications/core-metadata.rst:462
msgid "License"
msgstr ""

#: ../source/specifications/core-metadata.rst:466
msgid "Text indicating the license covering the distribution where the license is not a selection from the \"License\" Trove classifiers. See :ref:`\"Classifier\" <metadata-classifier>` below. This field may also be used to specify a particular version of a license which is named via the ``Classifier`` field, or to indicate a variation or exception to such a license."
msgstr ""

#: ../source/specifications/core-metadata.rst:486
msgid "Classifier (multiple use)"
msgstr ""

#: ../source/specifications/core-metadata.rst:490
msgid "Each entry is a string giving a single classification value for the distribution.  Classifiers are described in :pep:`301`, and the Python Package Index publishes a dynamic list of `currently defined classifiers <https://pypi.org/classifiers/>`__."
msgstr ""

#: ../source/specifications/core-metadata.rst:495
#: ../source/specifications/core-metadata.rst:585
#: ../source/specifications/core-metadata.rst:725
#: ../source/specifications/core-metadata.rst:750
msgid "This field may be followed by an environment marker after a semicolon."
msgstr ""

#: ../source/specifications/core-metadata.rst:506
msgid "Requires-Dist (multiple use)"
msgstr ""

#: ../source/specifications/core-metadata.rst:509
#: ../source/specifications/core-metadata.rst:572
#: ../source/specifications/core-metadata.rst:697
#: ../source/specifications/core-metadata.rst:739
msgid "The field format specification was relaxed to accept the syntax used by popular publishing tools."
msgstr ""

#: ../source/specifications/core-metadata.rst:513
msgid "Each entry contains a string naming some other distutils project required by this distribution."
msgstr ""

#: ../source/specifications/core-metadata.rst:516
msgid "The format of a requirement string contains from one to four parts:"
msgstr ""

#: ../source/specifications/core-metadata.rst:518
msgid "A project name, in the same format as the ``Name:`` field. The only mandatory part."
msgstr ""

#: ../source/specifications/core-metadata.rst:520
msgid "A comma-separated list of 'extra' names. These are defined by the required project, referring to specific features which may need extra dependencies. The names MUST conform to the restrictions specified by the ``Provides-Extra:`` field."
msgstr ""

#: ../source/specifications/core-metadata.rst:524
msgid "A version specifier. Tools parsing the format should accept optional parentheses around this, but tools generating it should not use parentheses."
msgstr ""

#: ../source/specifications/core-metadata.rst:527
msgid "An environment marker after a semicolon. This means that the requirement is only needed in the specified conditions."
msgstr ""

#: ../source/specifications/core-metadata.rst:530
msgid "See :pep:`508` for full details of the allowed format."
msgstr ""

#: ../source/specifications/core-metadata.rst:532
msgid "The project names should correspond to names as found on the `Python Package Index`_."
msgstr ""

#: ../source/specifications/core-metadata.rst:535
msgid "Version specifiers must follow the rules described in :doc:`version-specifiers`."
msgstr ""

#: ../source/specifications/core-metadata.rst:549
msgid "Requires-Python"
msgstr ""

#: ../source/specifications/core-metadata.rst:553
msgid "This field specifies the Python version(s) that the distribution is compatible with. Installation tools may look at this when picking which version of a project to install."
msgstr ""

#: ../source/specifications/core-metadata.rst:557
msgid "The value must be in the format specified in :doc:`version-specifiers`."
msgstr ""

#: ../source/specifications/core-metadata.rst:559
msgid "For example, if a distribution uses :ref:`f-strings <whatsnew36-pep498>` then it may prevent installation on Python < 3.6 by specifying::"
msgstr ""

#: ../source/specifications/core-metadata.rst:564
msgid "This field cannot be followed by an environment marker."
msgstr ""

#: ../source/specifications/core-metadata.rst:569
msgid "Requires-External (multiple use)"
msgstr ""

#: ../source/specifications/core-metadata.rst:576
msgid "Each entry contains a string describing some dependency in the system that the distribution is to be used.  This field is intended to serve as a hint to downstream project maintainers, and has no semantics which are meaningful to the ``distutils`` distribution."
msgstr ""

#: ../source/specifications/core-metadata.rst:581
msgid "The format of a requirement string is a name of an external dependency, optionally followed by a version declaration within parentheses."
msgstr ""

#: ../source/specifications/core-metadata.rst:587
msgid "Because they refer to non-Python software releases, version numbers for this field are **not** required to conform to the format specified in the :ref:`Version specifier specification <version-specifiers>`: they should correspond to the version scheme used by the external dependency."
msgstr ""

#: ../source/specifications/core-metadata.rst:592
msgid "Notice that there is no particular rule on the strings to be used."
msgstr ""

#: ../source/specifications/core-metadata.rst:604
msgid "Project-URL (multiple-use)"
msgstr ""

#: ../source/specifications/core-metadata.rst:608
msgid "A string containing a browsable URL for the project and a label for it, separated by a comma."
msgstr ""

#: ../source/specifications/core-metadata.rst:615
msgid "The label is free text limited to 32 characters."
msgstr ""

#: ../source/specifications/core-metadata.rst:623
msgid "Provides-Extra (multiple use)"
msgstr ""

#: ../source/specifications/core-metadata.rst:626
msgid ":pep:`685` restricted valid values to be unambiguous (i.e. no normalization required). For older metadata versions, value restrictions were brought into line with ``Name:`` and normalization rules were introduced."
msgstr ""

#: ../source/specifications/core-metadata.rst:631
msgid "A string containing the name of an optional feature. A valid name consists only of lowercase ASCII letters, ASCII numbers, and hyphen. It must start and end with a letter or number. Hyphens cannot be followed by another hyphen. Names are limited to those which match the following regex (which guarantees unambiguity)::"
msgstr ""

#: ../source/specifications/core-metadata.rst:639
msgid "The specified name may be used to make a dependency conditional on whether the optional feature has been requested."
msgstr ""

#: ../source/specifications/core-metadata.rst:647
msgid "A second distribution requires an optional dependency by placing it inside square brackets, and can request multiple features by separating them with a comma (,). The requirements are evaluated for each requested feature and added to the set of requirements for the distribution."
msgstr ""

#: ../source/specifications/core-metadata.rst:657
msgid "Two feature names ``test`` and ``doc`` are reserved to mark dependencies that are needed for running automated tests and generating documentation, respectively."
msgstr ""

#: ../source/specifications/core-metadata.rst:661
msgid "It is legal to specify ``Provides-Extra:`` without referencing it in any ``Requires-Dist:``."
msgstr ""

#: ../source/specifications/core-metadata.rst:664
msgid "When writing data for older metadata versions, names MUST be normalized following the same rules used for the ``Name:`` field when performing comparisons. Tools writing metadata MUST raise an error if two ``Provides-Extra:`` entries would clash after being normalized."
msgstr ""

#: ../source/specifications/core-metadata.rst:669
msgid "When reading data for older metadata versions, tools SHOULD warn when values for this field would be invalid under newer metadata versions. If a value would be invalid following the rules for ``Name:`` in any core metadata version, the user SHOULD be warned and the value ignored to avoid ambiguity. Tools MAY choose to raise an error when reading an invalid name for older metadata versions."
msgstr ""

#: ../source/specifications/core-metadata.rst:677
msgid "Rarely Used Fields"
msgstr ""

#: ../source/specifications/core-metadata.rst:679
msgid "The fields in this section are currently rarely used, as their design was inspired by comparable mechanisms in Linux package management systems, and it isn't at all clear how tools should interpret them in the context of an open index server such as `PyPI <https://pypi.org>`__."
msgstr ""

#: ../source/specifications/core-metadata.rst:684
msgid "As a result, popular installation tools ignore them completely, which in turn means there is little incentive for package publishers to set them appropriately. However, they're retained in the metadata specification, as they're still potentially useful for informational purposes, and can also be used for their originally intended purpose in combination with a curated package repository."
msgstr ""

#: ../source/specifications/core-metadata.rst:694
msgid "Provides-Dist (multiple use)"
msgstr ""

#: ../source/specifications/core-metadata.rst:701
msgid "Each entry contains a string naming a Distutils project which is contained within this distribution.  This field *must* include the project identified in the ``Name`` field, followed by the version : Name (Version)."
msgstr ""

#: ../source/specifications/core-metadata.rst:706
msgid "A distribution may provide additional names, e.g. to indicate that multiple projects have been bundled together.  For instance, source distributions of the ``ZODB`` project have historically included the ``transaction`` project, which is now available as a separate distribution.  Installing such a source distribution satisfies requirements for both ``ZODB`` and ``transaction``."
msgstr ""

#: ../source/specifications/core-metadata.rst:713
msgid "A distribution may also provide a \"virtual\" project name, which does not correspond to any separately-distributed project:  such a name might be used to indicate an abstract capability which could be supplied by one of multiple projects.  E.g., multiple projects might supply RDBMS bindings for use by a given ORM:  each project might declare that it provides ``ORM-bindings``, allowing other projects to depend only on having at most one of them installed."
msgstr ""

#: ../source/specifications/core-metadata.rst:721
msgid "A version declaration may be supplied and must follow the rules described in :doc:`version-specifiers`. The distribution's version number will be implied if none is specified."
msgstr ""

#: ../source/specifications/core-metadata.rst:736
msgid "Obsoletes-Dist (multiple use)"
msgstr ""

#: ../source/specifications/core-metadata.rst:743
msgid "Each entry contains a string describing a distutils project's distribution which this distribution renders obsolete, meaning that the two projects should not be installed at the same time."
msgstr ""

#: ../source/specifications/core-metadata.rst:747
msgid "Version declarations can be supplied.  Version numbers must be in the format specified in :doc:`version-specifiers`."
msgstr ""

#: ../source/specifications/core-metadata.rst:752
msgid "The most common use of this field will be in case a project name changes, e.g. Gorgon 2.3 gets subsumed into Torqued Python 1.0. When you install Torqued Python, the Gorgon distribution should be removed."
msgstr ""

#: ../source/specifications/core-metadata.rst:765
msgid "Deprecated Fields"
msgstr ""

#: ../source/specifications/core-metadata.rst:768
msgid "Requires"
msgstr ""

#: ../source/specifications/core-metadata.rst:771
msgid "in favour of ``Requires-Dist``"
msgstr ""

#: ../source/specifications/core-metadata.rst:774
msgid "Each entry contains a string describing some other module or package required by this package."
msgstr ""

#: ../source/specifications/core-metadata.rst:777
msgid "The format of a requirement string is identical to that of a module or package name usable with the ``import`` statement, optionally followed by a version declaration within parentheses."
msgstr ""

#: ../source/specifications/core-metadata.rst:781
msgid "A version declaration is a series of conditional operators and version numbers, separated by commas. Conditional operators must be one of \"<\", \">\"', \"<=\", \">=\", \"==\", and \"!=\". Version numbers must be in the format accepted by the ``distutils.version.StrictVersion`` class: two or three dot-separated numeric components, with an optional \"pre-release\" tag on the end consisting of the letter 'a' or 'b' followed by a number. Example version numbers are \"1.0\", \"2.3a2\", \"1.3.99\","
msgstr ""

#: ../source/specifications/core-metadata.rst:789
msgid "Any number of conditional operators can be specified, e.g. the string \">1.0, !=1.3.4, <2.0\" is a legal version declaration."
msgstr ""

#: ../source/specifications/core-metadata.rst:792
msgid "All of the following are possible requirement strings: \"rfc822\", \"zlib (>=1.1.4)\", \"zope\"."
msgstr ""

#: ../source/specifications/core-metadata.rst:795
msgid "There’s no canonical list of what strings should be used; the Python community is left to choose its own standards."
msgstr ""

#: ../source/specifications/core-metadata.rst:808
msgid "Provides"
msgstr ""

#: ../source/specifications/core-metadata.rst:811
msgid "in favour of ``Provides-Dist``"
msgstr ""

#: ../source/specifications/core-metadata.rst:814
msgid "Each entry contains a string describing a package or module that will be provided by this package once it is installed. These strings should match the ones used in Requirements fields. A version declaration may be supplied (without a comparison operator); the package’s version number will be implied if none is specified."
msgstr ""

#: ../source/specifications/core-metadata.rst:830
msgid "Obsoletes"
msgstr ""

#: ../source/specifications/core-metadata.rst:833
msgid "in favour of ``Obsoletes-Dist``"
msgstr ""

#: ../source/specifications/core-metadata.rst:836
msgid "Each entry contains a string describing a package or module that this package renders obsolete, meaning that the two packages should not be installed at the same time. Version declarations can be supplied."
msgstr ""

#: ../source/specifications/core-metadata.rst:840
msgid "The most common use of this field will be in case a package name changes, e.g. Gorgon 2.3 gets subsumed into Torqued Python 1.0. When you install Torqued Python, the Gorgon package should be removed."
msgstr ""

#: ../source/specifications/core-metadata.rst:851
msgid "reStructuredText markup: https://docutils.sourceforge.io/"
msgstr ""

#: ../source/specifications/core-metadata.rst:856
msgid "RFC 822 Long Header Fields: :rfc:`822#section-3.1.1`"
msgstr ""

#: ../source/specifications/declaring-build-dependencies.rst:6
msgid "Declaring build system dependencies"
msgstr ""

#: ../source/specifications/declaring-build-dependencies.rst:8
msgid "The ``pyproject.toml`` file is written in `TOML <https://toml.io>`_. Among other metadata (such as :ref:`project metadata <declaring-project-metadata>`), it declares any Python level dependencies that must be installed in order to run the project's build system successfully."
msgstr ""

#: ../source/specifications/declaring-build-dependencies.rst:15
msgid "Tables not defined by PyPA specifications are reserved for future use."
msgstr ""

#: ../source/specifications/declaring-build-dependencies.rst:19
msgid "build-system table"
msgstr ""

#: ../source/specifications/declaring-build-dependencies.rst:23
msgid "The ``[build-system]`` table is used to store build-related data. Initially,  only one key of the table is valid and is mandatory for the table: ``requires``. This key must have a value of a list of strings representing dependencies required to execute the build system. The strings in this list follow the :ref:`version specifier specification <version-specifiers>`."
msgstr ""

#: ../source/specifications/declaring-build-dependencies.rst:30
msgid "An example ``build-system`` table for a project built with ``setuptools`` is:"
msgstr ""

#: ../source/specifications/declaring-build-dependencies.rst:39
msgid "Build tools are expected to use the example configuration file above as their default semantics when a ``pyproject.toml`` file is not present."
msgstr ""

#: ../source/specifications/declaring-build-dependencies.rst:42
msgid "Tools should not require the existence of the ``[build-system]`` table. A ``pyproject.toml`` file may be used to store configuration details other than build-related data and thus lack a ``[build-system]`` table legitimately. If the file exists but is lacking the ``[build-system]`` table then the default values as specified above should be used. If the table is specified but is missing required fields then the tool should consider it an error."
msgstr ""

#: ../source/specifications/declaring-build-dependencies.rst:56
msgid "tool table"
msgstr ""

#: ../source/specifications/declaring-build-dependencies.rst:58
msgid "The ``[tool]`` table is where any tool related to your Python project, not just build tools, can have users specify configuration data as long as they use a sub-table within ``[tool]``, e.g. the `flit <https://pypi.python.org/pypi/flit>`_ tool would store its configuration in ``[tool.flit]``."
msgstr ""

#: ../source/specifications/declaring-build-dependencies.rst:64
msgid "A mechanism is needed to allocate names within the ``tool.*`` namespace, to make sure that different projects do not attempt to use the same sub-table and collide. Our rule is that a project can use the subtable ``tool.$NAME`` if, and only if, they own the entry for ``$NAME`` in the Cheeseshop/PyPI."
msgstr ""

#: ../source/specifications/declaring-build-dependencies.rst:71
msgid "JSON Schema"
msgstr ""

#: ../source/specifications/declaring-build-dependencies.rst:73
msgid "To provide a type-specific representation of the resulting data from the TOML file for illustrative purposes only, the following `JSON Schema <https://json-schema.org>`_ would match the data format:"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:5
msgid "Declaring project metadata"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:7
msgid ":pep:`621` specifies how to write a project's :ref:`core metadata <core-metadata>` in a ``pyproject.toml`` file for packaging-related tools to consume. It defines the following specification as the canonical source for the format used."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:14
msgid "This is a **technical, formal specification**. For a gentle, user-friendly guide to ``pyproject.toml``, see :ref:`writing-pyproject-toml`."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:20
#: ../source/specifications/dependency-specifiers.rst:24
#: ../source/specifications/direct-url-data-structure.rst:18
#: ../source/specifications/direct-url.rst:15
#: ../source/specifications/inline-script-metadata.rst:18
msgid "Specification"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:22
msgid "There are two kinds of metadata: *static* and *dynamic*. Static metadata is specified in the ``pyproject.toml`` file directly and cannot be specified or changed by a tool (this includes data *referred* to by the metadata, e.g. the contents of files referenced by the metadata). Dynamic metadata is listed via the ``dynamic`` key (defined later in this specification) and represents metadata that a tool will later provide."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:30
msgid "The keys defined in this specification MUST be in a table named ``[project]`` in ``pyproject.toml``. No tools may add keys to this table which are not defined by this specification. For tools wishing to store their own settings in ``pyproject.toml``, they may use the ``[tool]`` table as defined in the :ref:`build dependency declaration specification <declaring-build-dependencies>`. The lack of a ``[project]`` table implicitly means the :term:`build backend <Build Backend>` will dynamically provide all keys."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:39
msgid "The only keys required to be statically defined are:"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:43
msgid "The keys which are required but may be specified *either* statically or listed as dynamic are:"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:48
msgid "All other keys are considered optional and may be specified statically, listed as dynamic, or left unspecified."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:51
msgid "The complete list of keys allowed in the ``[project]`` table are:"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:53
msgid "``authors``"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:55
msgid "``dependencies``"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:57
#: ../source/specifications/declaring-project-metadata.rst:305
msgid "``dynamic``"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:58
msgid "``entry-points``"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:59
msgid "``gui-scripts``"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:62
msgid "``maintainers``"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:64
msgid "``optional-dependencies``"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:75
#: ../source/specifications/declaring-project-metadata.rst:87
#: ../source/specifications/declaring-project-metadata.rst:100
#: ../source/specifications/declaring-project-metadata.rst:149
msgid "TOML_ type: string"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:76
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Name <core-metadata-name>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:79
msgid "The name of the project."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:81
msgid "Tools SHOULD :ref:`normalize <name-normalization>` this name, as soon as it is read for internal consistency."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:88
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Version <core-metadata-version>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:91
msgid "The version of the project, as defined in the :ref:`Version specifier specification <version-specifiers>`."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:94
msgid "Users SHOULD prefer to specify already-normalized versions."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:101
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Summary <core-metadata-summary>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:104
msgid "The summary description of the project."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:110
msgid "TOML_ type: string or table"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:111
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Description <core-metadata-description>` and :ref:`Description-Content-Type <core-metadata-description-content-type>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:115
msgid "The full description of the project (i.e. the README)."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:117
msgid "The key accepts either a string or a table. If it is a string then it is a path relative to ``pyproject.toml`` to a text file containing the full description. Tools MUST assume the file's encoding is UTF-8. If the file path ends in a case-insensitive ``.md`` suffix, then tools MUST assume the content-type is ``text/markdown``. If the file path ends in a case-insensitive ``.rst``, then tools MUST assume the content-type is ``text/x-rst``. If a tool recognizes more extensions than this PEP, they MAY infer the content-type for the user without specifying this key as ``dynamic``. For all unrecognized suffixes when a content-type is not provided, tools MUST raise an error."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:128
msgid "The ``readme`` key may also take a table. The ``file`` key has a string value representing a path relative to ``pyproject.toml`` to a file containing the full description. The ``text`` key has a string value which is the full description. These keys are mutually-exclusive, thus tools MUST raise an error if the metadata specifies both keys."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:135
msgid "A table specified in the ``readme`` key also has a ``content-type`` key which takes a string specifying the content-type of the full description. A tool MUST raise an error if the metadata does not specify this key in the table. If the metadata does not specify the ``charset`` parameter, then it is assumed to be UTF-8. Tools MAY support other encodings if they choose to. Tools MAY support alternative content-types which they can transform to a content-type as supported by the :ref:`core metadata <core-metadata>`. Otherwise tools MUST raise an error for unsupported content-types."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:150
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Requires-Python <core-metadata-requires-python>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:153
msgid "The Python version requirements of the project."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:159
msgid "TOML_ type: table"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:160
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`License <core-metadata-license>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:163
msgid "The table may have one of two keys. The ``file`` key has a string value that is a file path relative to ``pyproject.toml`` to the file which contains the license for the project. Tools MUST assume the file's encoding is UTF-8. The ``text`` key has a string value which is the license of the project.  These keys are mutually exclusive, so a tool MUST raise an error if the metadata specifies both keys."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:174
msgid "TOML_ type: Array of inline tables with string keys and values"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:175
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Author <core-metadata-author>`, :ref:`Author-email <core-metadata-author-email>`, :ref:`Maintainer <core-metadata-maintainer>`, and :ref:`Maintainer-email <core-metadata-maintainer-email>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:181
msgid "The people or organizations considered to be the \"authors\" of the project. The exact meaning is open to interpretation — it may list the original or primary authors, current maintainers, or owners of the package."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:186
msgid "The \"maintainers\" key is similar to \"authors\" in that its exact meaning is open to interpretation."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:189
msgid "These keys accept an array of tables with 2 keys: ``name`` and ``email``. Both values must be strings. The ``name`` value MUST be a valid email name (i.e. whatever can be put as a name, before an email, in :rfc:`822`) and not contain commas. The ``email`` value MUST be a valid email address. Both keys are optional, but at least one of the keys must be specified in the table."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:196
msgid "Using the data to fill in :ref:`core metadata <core-metadata>` is as follows:"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:199
msgid "If only ``name`` is provided, the value goes in :ref:`Author <core-metadata-author>` or :ref:`Maintainer <core-metadata-maintainer>` as appropriate."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:202
msgid "If only ``email`` is provided, the value goes in :ref:`Author-email <core-metadata-author-email>` or :ref:`Maintainer-email <core-metadata-maintainer-email>` as appropriate."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:206
msgid "If both ``email`` and ``name`` are provided, the value goes in :ref:`Author-email <core-metadata-author-email>` or :ref:`Maintainer-email <core-metadata-maintainer-email>` as appropriate, with the format ``{name} <{email}>``."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:210
msgid "Multiple values should be separated by commas."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:216
#: ../source/specifications/declaring-project-metadata.rst:226
msgid "TOML_ type: array of strings"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:217
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Keywords <core-metadata-keywords>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:220
msgid "The keywords for the project."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:227
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Classifier <core-metadata-classifier>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:230
msgid "Trove classifiers which apply to the project."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:236
msgid "TOML_ type: table with keys and values of strings"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:237
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Project-URL <core-metadata-project-url>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:240
msgid "A table of URLs where the key is the URL label and the value is the URL itself."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:245
msgid "Entry points"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:247
msgid "TOML_ type: table (``[project.scripts]``, ``[project.gui-scripts]``, and ``[project.entry-points]``)"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:249
msgid ":ref:`Entry points specification <entry-points>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:251
msgid "There are three tables related to entry points. The ``[project.scripts]`` table corresponds to the ``console_scripts`` group in the :ref:`entry points specification <entry-points>`. The key of the table is the name of the entry point and the value is the object reference."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:257
msgid "The ``[project.gui-scripts]`` table corresponds to the ``gui_scripts`` group in the :ref:`entry points specification <entry-points>`. Its format is the same as ``[project.scripts]``."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:261
msgid "The ``[project.entry-points]`` table is a collection of tables. Each sub-table's name is an entry point group. The key and value semantics are the same as ``[project.scripts]``. Users MUST NOT create nested sub-tables but instead keep the entry point groups to only one level deep."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:267
msgid "Build back-ends MUST raise an error if the metadata defines a ``[project.entry-points.console_scripts]`` or ``[project.entry-points.gui_scripts]`` table, as they would be ambiguous in the face of ``[project.scripts]`` and ``[project.gui-scripts]``, respectively."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:277
msgid "TOML_ type: Array of :pep:`508` strings (``dependencies``), and a table with values of arrays of :pep:`508` strings (``optional-dependencies``)"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:280
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Requires-Dist <core-metadata-requires-dist>` and :ref:`Provides-Extra <core-metadata-provides-extra>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:284
msgid "The (optional) dependencies of the project."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:286
msgid "For ``dependencies``, it is a key whose value is an array of strings. Each string represents a dependency of the project and MUST be formatted as a valid :pep:`508` string. Each string maps directly to a :ref:`Requires-Dist <core-metadata-requires-dist>` entry."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:291
msgid "For ``optional-dependencies``, it is a table where each key specifies an extra and whose value is an array of strings. The strings of the arrays must be valid :pep:`508` strings. The keys MUST be valid values for :ref:`Provides-Extra <core-metadata-provides-extra>`. Each value in the array thus becomes a corresponding :ref:`Requires-Dist <core-metadata-requires-dist>` entry for the matching :ref:`Provides-Extra <core-metadata-provides-extra>` metadata."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:307
msgid "TOML_ type: array of string"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:308
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Dynamic <core-metadata-dynamic>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:311
msgid "Specifies which keys listed by this PEP were intentionally unspecified so another tool can/will provide such metadata dynamically. This clearly delineates which metadata is purposefully unspecified and expected to stay unspecified compared to being provided via tooling later on."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:317
msgid "A build back-end MUST honour statically-specified metadata (which means the metadata did not list the key in ``dynamic``)."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:319
msgid "A build back-end MUST raise an error if the metadata specifies ``name`` in ``dynamic``."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:321
msgid "If the :ref:`core metadata <core-metadata>` specification lists a field as \"Required\", then the metadata MUST specify the key statically or list it in ``dynamic`` (build back-ends MUST raise an error otherwise, i.e. it should not be possible for a required key to not be listed somehow in the ``[project]`` table)."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:326
msgid "If the :ref:`core metadata <core-metadata>` specification lists a field as \"Optional\", the metadata MAY list it in ``dynamic`` if the expectation is a build back-end will provide the data for the key later."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:330
msgid "Build back-ends MUST raise an error if the metadata specifies a key statically as well as being listed in ``dynamic``."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:332
msgid "If the metadata does not list a key in ``dynamic``, then a build back-end CANNOT fill in the requisite metadata on behalf of the user (i.e. ``dynamic`` is the only way to allow a tool to fill in metadata and the user must opt into the filling in)."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:336
msgid "Build back-ends MUST raise an error if the metadata specifies a key in ``dynamic`` but the build back-end was unable to determine the data for it (omitting the data, if determined to be the accurate value, is acceptable)."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:5
msgid "Dependency specifiers"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:7
msgid "This document describes the dependency specifiers format as originally specified in :pep:`508`."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:10
msgid "The job of a dependency is to enable tools like pip [#pip]_ to find the right package to install. Sometimes this is very loose - just specifying a name, and sometimes very specific - referring to a specific file to install. Sometimes dependencies are only relevant in one platform, or only some versions are acceptable, so the language permits describing all these cases."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:16
msgid "The language defined is a compact line based format which is already in widespread use in pip requirements files, though we do not specify the command line option handling that those files permit. There is one caveat - the URL reference form, specified in :ref:`Versioning specifier specification <version-specifiers>` is not actually implemented in pip, but we use that format rather than pip's current native format."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:29
msgid "All features of the language shown with a name based lookup::"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:33
msgid "A minimal URL based lookup::"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:38
msgid "Concepts"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:40
msgid "A dependency specification always specifies a distribution name. It may include extras, which expand the dependencies of the named distribution to enable optional features. The version installed can be controlled using version limits, or giving the URL to a specific artifact to install. Finally the dependency can be made conditional using environment markers."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:47
msgid "Grammar"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:49
msgid "We first cover the grammar briefly and then drill into the semantics of each section later."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:52
msgid "A distribution specification is written in ASCII text. We use a parsley [#parsley]_ grammar to provide a precise grammar. It is expected that the specification will be embedded into a larger system which offers framing such as comments, multiple line support via continuations, or other such features."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:57
msgid "The full grammar including annotations to build a useful parse tree is included at the end of this document."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:60
msgid "Versions may be specified according to the rules of the :ref:`Version specifier specification <version-specifiers>`. (Note: URI is defined in :rfc:`std-66 <3986>`)::"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:71
msgid "Environment markers allow making a specification only take effect in some environments::"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:100
msgid "Optional components of a distribution may be specified using the extras field::"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:109
msgid "Restrictions on names for extras is defined in :pep:`685`."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:111
msgid "Giving us a rule for name based requirements::"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:115
msgid "And a rule for direct reference specifications::"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:119
msgid "Leading to the unified rule that can specify a dependency.::"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:124
msgid "Whitespace"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:126
msgid "Non line-breaking whitespace is mostly optional with no semantic meaning. The sole exception is detecting the end of a URL requirement."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:130
msgid "Names"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:132
msgid "Python distribution names are currently defined in :pep:`345`. Names act as the primary identifier for distributions. They are present in all dependency specifications, and are sufficient to be a specification on their own. However, PyPI places strict restrictions on names - they must match a case insensitive regex or they won't be accepted. Accordingly, in this document we limit the acceptable values for identifiers to that regex. A full redefinition of name may take place in a future metadata PEP. The regex (run with re.IGNORECASE) is::"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:144
msgid "Extras"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:146
msgid "An extra is an optional part of a distribution. Distributions can specify as many extras as they wish, and each extra results in the declaration of additional dependencies of the distribution **when** the extra is used in a dependency specification. For instance::"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:153
msgid "Extras union in the dependencies they define with the dependencies of the distribution they are attached to. The example above would result in requests being installed, and requests own dependencies, and also any dependencies that are listed in the \"security\" extra of requests."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:158
msgid "If multiple extras are listed, all the dependencies are unioned together."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:161
msgid "Versions"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:163
msgid "See the :ref:`Version specifier specification <version-specifiers>` for more detail on both version numbers and version comparisons. Version specifications limit the versions of a distribution that can be used. They only apply to distributions looked up by name, rather than via a URL. Version comparison are also used in the markers feature. The optional brackets around a version are present for compatibility with :pep:`345` but should not be generated, only accepted."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:172
msgid "Environment Markers"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:174
msgid "Environment markers allow a dependency specification to provide a rule that describes when the dependency should be used. For instance, consider a package that needs argparse. In Python 2.7 argparse is always present. On older Python versions it has to be installed as a dependency. This can be expressed as so::"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:181
msgid "A marker expression evaluates to either True or False. When it evaluates to False, the dependency specification should be ignored."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:184
msgid "The marker language is inspired by Python itself, chosen for the ability to safely evaluate it without running arbitrary code that could become a security vulnerability. Markers were first standardised in :pep:`345`. This document fixes some issues that were observed in the design described in :pep:`426`."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:189
msgid "Comparisons in marker expressions are typed by the comparison operator.  The <marker_op> operators that are not in <version_cmp> perform the same as they do for strings in Python. The <version_cmp> operators use the version comparison rules of the :ref:`Version specifier specification <version-specifiers>` when those are defined (that is when both sides have a valid version specifier). If there is no defined behaviour of this specification and the operator exists in Python, then the operator falls back to the Python behaviour. Otherwise an error should be raised. e.g. the following will result in  errors::"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:202
msgid "User supplied constants are always encoded as strings with either ``'`` or ``\"`` quote marks. Note that backslash escapes are not defined, but existing implementations do support them. They are not included in this specification because they add complexity and there is no observable need for them today. Similarly we do not define non-ASCII character support: all the runtime variables we are referencing are expected to be ASCII-only."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:209
msgid "The variables in the marker grammar such as \"os_name\" resolve to values looked up in the Python runtime. With the exception of \"extra\" all values are defined on all Python versions today - it is an error in the implementation of markers if a value is not defined."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:214
msgid "Unknown variables must raise an error rather than resulting in a comparison that evaluates to True or False."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:217
msgid "Variables whose value cannot be calculated on a given Python implementation should evaluate to ``0`` for versions, and an empty string for all other variables."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:221
msgid "The \"extra\" variable is special. It is used by wheels to signal which specifications apply to a given extra in the wheel ``METADATA`` file, but since the ``METADATA`` file is based on a draft version of :pep:`426`, there is no current specification for this. Regardless, outside of a context where this special handling is taking place, the \"extra\" variable should result in an error like all other unknown variables."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:231
msgid "Marker"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:232
msgid "Python equivalent"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:233
msgid "Sample values"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:234
msgid "``os_name``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:235
msgid "``os.name``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:236
msgid "``posix``, ``java``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:237
msgid "``sys_platform``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:238
msgid "``sys.platform``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:239
msgid "``linux``, ``linux2``, ``darwin``, ``java1.8.0_51`` (note that \"linux\" is from Python3 and \"linux2\" from Python2)"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:241
msgid "``platform_machine``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:242
msgid "``platform.machine()``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:243
msgid "``x86_64``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:244
msgid "``platform_python_implementation``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:245
msgid "``platform.python_implementation()``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:246
msgid "``CPython``, ``Jython``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:247
msgid "``platform_release``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:248
msgid "``platform.release()``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:249
msgid "``3.14.1-x86_64-linode39``, ``14.5.0``, ``1.8.0_51``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:250
msgid "``platform_system``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:251
msgid "``platform.system()``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:252
msgid "``Linux``, ``Windows``, ``Java``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:253
msgid "``platform_version``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:254
msgid "``platform.version()``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:255
msgid "``#1 SMP Fri Apr 25 13:07:35 EDT 2014`` ``Java HotSpot(TM) 64-Bit Server VM, 25.51-b03, Oracle Corporation`` ``Darwin Kernel Version 14.5.0: Wed Jul 29 02:18:53 PDT 2015; root:xnu-2782.40.9~2/RELEASE_X86_64``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:258
msgid "``python_version``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:259
msgid "``'.'.join(platform.python_version_tuple()[:2])``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:260
msgid "``3.4``, ``2.7``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:261
msgid "``python_full_version``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:262
msgid "``platform.python_version()``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:263
#: ../source/specifications/dependency-specifiers.rst:269
msgid "``3.4.0``, ``3.5.0b1``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:264
msgid "``implementation_name``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:265
msgid "``sys.implementation.name``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:266
msgid "``cpython``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:267
msgid "``implementation_version``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:268
msgid "see definition below"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:270
msgid "``extra``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:271
msgid "An error except when defined by the context interpreting the specification."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:273
msgid "``test``"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:275
msgid "The ``implementation_version`` marker variable is derived from ``sys.implementation.version``::"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:290
msgid "This environment markers section, initially defined through :pep:`508`, supersedes the environment markers section in :pep:`345`."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:294
msgid "Complete Grammar"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:296
msgid "The complete parsley grammar::"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:403
msgid "A test program - if the grammar is in a string ``grammar``::"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:470
msgid "Summary of changes to PEP 508"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:472
msgid "The following changes were made based on feedback after its initial implementation:"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:475
msgid "The definition of ``python_version`` was changed from ``platform.python_version()[:3]`` to ``'.'.join(platform.python_version_tuple()[:2])``, to accommodate potential future versions of Python with 2-digit major and minor versions (e.g. 3.10). [#future_versions]_"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:485
msgid "pip, the recommended installer for Python packages (http://pip.readthedocs.org/en/stable/)"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:488
msgid "The parsley PEG library. (https://pypi.python.org/pypi/parsley/)"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:491
msgid "Future Python versions might be problematic with the definition of Environment Marker Variable ``python_version`` (https://github.com/python/peps/issues/560)"
msgstr ""

#: ../source/specifications/direct-url.rst:6
msgid "Recording the Direct URL Origin of installed distributions"
msgstr ""

#: ../source/specifications/direct-url.rst:8
msgid "This document specifies a :file:`direct_url.json` file in the ``*.dist-info`` directory of an installed distribution, to record the Direct URL Origin of the distribution. The general structure and usage of ``*.dist-info`` directories is described in :ref:`recording-installed-packages`."
msgstr ""

#: ../source/specifications/direct-url.rst:17
msgid "The :file:`direct_url.json` file MUST be created in the :file:`*.dist-info` directory by installers when installing a distribution from a requirement specifying a direct URL reference (including a VCS URL)."
msgstr ""

#: ../source/specifications/direct-url.rst:21
#: ../source/specifications/recording-installed-packages.rst:221
msgid "This file MUST NOT be created when installing a distribution from an other type of requirement (i.e. name plus version specifier)."
msgstr ""

#: ../source/specifications/direct-url.rst:24
msgid "This JSON file MUST be a UTF-8 encoded, :rfc:`8259` compliant, serialization of the :doc:`direct-url-data-structure`."
msgstr ""

#: ../source/specifications/direct-url.rst:29
msgid "When the requested URL has the file:// scheme and points to a local directory that happens to contain a VCS checkout, installers MUST NOT attempt to infer any VCS information and therefore MUST NOT output any VCS related information (such as ``vcs_info``) in :file:`direct_url.json`."
msgstr ""

#: ../source/specifications/direct-url.rst:36
msgid "As a general rule, installers should as much as possible preserve the information that was provided in the requested URL when generating :file:`direct_url.json`. For example user:password environment variables should be preserved and ``requested_revision`` should reflect the revision that was provided in the requested URL as faithfully as possible. This information is however *enriched* with more precise data, such as ``commit_id``."
msgstr ""

#: ../source/specifications/direct-url.rst:45
msgid "Example pip commands and their effect on direct_url.json"
msgstr ""

#: ../source/specifications/direct-url.rst:47
msgid "Commands that generate a ``direct_url.json``:"
msgstr ""

#: ../source/specifications/direct-url.rst:49
msgid "``pip install https://example.com/app-1.0.tgz``"
msgstr ""

#: ../source/specifications/direct-url.rst:50
msgid "``pip install https://example.com/app-1.0.whl``"
msgstr ""

#: ../source/specifications/direct-url.rst:51
msgid "``pip install \"app @ git+https://example.com/repo/app.git#subdirectory=setup\"``"
msgstr ""

#: ../source/specifications/direct-url.rst:52
msgid "``pip install ./app``"
msgstr ""

#: ../source/specifications/direct-url.rst:53
msgid "``pip install file:///home/user/app``"
msgstr ""

#: ../source/specifications/direct-url.rst:54
msgid "``pip install --editable \"app @ git+https://example.com/repo/app.git#subdirectory=setup\"`` (in which case, ``url`` will be the local directory where the git repository has been cloned to, and ``dir_info`` will be present with ``\"editable\": true`` and no ``vcs_info`` will be set)"
msgstr ""

#: ../source/specifications/direct-url.rst:58
msgid "``pip install -e ./app``"
msgstr ""

#: ../source/specifications/direct-url.rst:60
msgid "Commands that *do not* generate a ``direct_url.json``"
msgstr ""

#: ../source/specifications/direct-url.rst:62
msgid "``pip install app``"
msgstr ""

#: ../source/specifications/direct-url.rst:63
msgid "``pip install app --no-index --find-links https://example.com/``"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:283
#: ../source/specifications/direct-url.rst:66
#: ../source/specifications/externally-managed-environments.rst:472
#: ../source/specifications/inline-script-metadata.rst:239
#: ../source/specifications/name-normalization.rst:42
#: ../source/specifications/source-distribution-format.rst:144
#: ../source/specifications/version-specifiers.rst:1256
msgid "History"
msgstr ""

#: ../source/specifications/direct-url.rst:68
msgid "March 2020: the ``direct_url.json`` metadata file was originally specified in :pep:`610` and is formally documented here."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:6
msgid "Direct URL Data Structure"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:8
msgid "This document specifies a JSON-serializable abstract data structure that can represent URLs to python projects and distribution artifacts such as VCS source trees, local source trees, source distributions and wheels."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:12
msgid "The representation of the components of this data structure as a :rfc:`1738` URL is not formally specified at time of writing. A common representation is the pip URL format. Other examples are provided in the :ref:`Version specifier specification <version-specifiers>`."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:20
msgid "The Direct URL Data Structure MUST be a dictionary, serializable to JSON according to :rfc:`8259`."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:23
msgid "It MUST contain at least two fields. The first one is ``url``, with type ``string``. Depending on what ``url`` refers to, the second field MUST be one of ``vcs_info`` (if ``url`` is a VCS reference), ``archive_info`` (if ``url`` is a source archives or a wheel), or ``dir_info`` (if ``url``  is a local directory). These info fields have a (possibly empty) subdictionary as value, with the possible keys defined below."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:30
msgid "When persisted, ``url`` MUST be stripped of any sensitive authentication information, for security reasons."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:33
msgid "The user:password section of the URL MAY however be composed of environment variables, matching the following regular expression::"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:39
msgid "Additionally, the user:password section of the URL MAY be a well-known, non security sensitive string. A typical example is ``git`` in the case of an URL such as ``ssh://git@gitlab.com/user/repo``."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:44
msgid "VCS URLs"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:46
msgid "When ``url`` refers to a VCS repository, the ``vcs_info`` key MUST be present as a dictionary with the following keys:"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:49
msgid "A ``vcs`` key (type ``string``) MUST be present, containing the name of the VCS (i.e. one of ``git``, ``hg``, ``bzr``, ``svn``). Other VCS's SHOULD be registered by writing a PEP to amend this specification. The ``url`` value MUST be compatible with the corresponding VCS, so an installer can hand it off without transformation to a checkout/download command of the VCS."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:55
msgid "A ``requested_revision`` key (type ``string``) MAY be present naming a branch/tag/ref/commit/revision/etc (in a format compatible with the VCS)."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:57
msgid "A ``commit_id`` key (type ``string``) MUST be present, containing the exact commit/revision number that was/is to be installed. If the VCS supports commit-hash based revision identifiers, such commit-hash MUST be used as ``commit_id`` in order to reference an immutable version of the source code."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:65
msgid "Archive URLs"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:67
msgid "When ``url`` refers to a source archive or a wheel, the ``archive_info`` key MUST be present as a dictionary with the following keys:"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:70
msgid "A ``hashes`` key SHOULD be present as a dictionary mapping a hash name to a hex encoded digest of the file."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:73
msgid "Multiple hashes can be included, and it is up to the consumer to decide what to do with multiple hashes (it may validate all of them or a subset of them, or nothing at all)."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:77
msgid "These hash names SHOULD always be normalized to be lowercase."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:79
msgid "Any hash algorithm available via ``hashlib`` (specifically any that can be passed to ``hashlib.new()`` and do not require additional parameters) can be used as a key for the hashes dictionary. At least one secure algorithm from ``hashlib.algorithms_guaranteed`` SHOULD always be included. At time of writing, ``sha256`` specifically is recommended."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:85
msgid "A deprecated ``hash`` key (type ``string``) MAY be present for backwards compatibility purposes, with value ``<hash-algorithm>=<expected-hash>``."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:88
msgid "Producers of the data structure SHOULD emit the ``hashes`` key whether one or multiple hashes are available. Producers SHOULD continue to emit the ``hash`` key in contexts where they did so before, so as to keep backwards compatibility for existing clients."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:92
msgid "When both the ``hash`` and ``hashes`` keys are present, the hash represented in the ``hash`` key MUST also be present in the ``hashes`` dictionary, so consumers can consider the ``hashes`` key only if it is present, and fall back to ``hash`` otherwise."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:97
msgid "Local directories"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:99
msgid "When ``url`` refers to a local directory, the ``dir_info`` key MUST be present as a dictionary with the following key:"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:102
msgid "``editable`` (type: ``boolean``): ``true`` if the distribution was/is to be installed in editable mode, ``false`` otherwise. If absent, default to ``false``."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:105
msgid "When ``url`` refers to a local directory, it MUST have the ``file`` scheme and be compliant with :rfc:`8089`. In particular, the path component must be absolute. Symbolic links SHOULD be preserved when making relative paths absolute."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:111
msgid "Projects in subdirectories"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:113
msgid "A top-level ``subdirectory`` field MAY be present containing a directory path, relative to the root of the VCS repository, source archive or local directory, to specify where ``pyproject.toml`` or ``setup.py`` is located."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:118
msgid "Registered VCS"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:120
msgid "This section lists the registered VCS's; expanded, VCS-specific information on how to use the ``vcs``, ``requested_revision``, and other fields of ``vcs_info``; and in some cases additional VCS-specific fields. Tools MAY support other VCS's although it is RECOMMENDED to register them by writing a PEP to amend this specification. The ``vcs`` field SHOULD be the command name (lowercased). Additional fields that would be necessary to support such VCS SHOULD be prefixed with the VCS command name."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:130
msgid "Git"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:132
#: ../source/specifications/direct-url-data-structure.rst:164
#: ../source/specifications/direct-url-data-structure.rst:187
#: ../source/specifications/direct-url-data-structure.rst:210
msgid "Home page"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:134
msgid "https://git-scm.com/"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:136
#: ../source/specifications/direct-url-data-structure.rst:168
#: ../source/specifications/direct-url-data-structure.rst:191
#: ../source/specifications/direct-url-data-structure.rst:214
msgid "vcs command"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:138
#: ../source/specifications/direct-url-data-structure.rst:142
msgid "git"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:140
#: ../source/specifications/direct-url-data-structure.rst:172
#: ../source/specifications/direct-url-data-structure.rst:195
#: ../source/specifications/direct-url-data-structure.rst:218
msgid "``vcs`` field"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:144
#: ../source/specifications/direct-url-data-structure.rst:176
#: ../source/specifications/direct-url-data-structure.rst:199
#: ../source/specifications/direct-url-data-structure.rst:222
msgid "``requested_revision`` field"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:146
msgid "A tag name, branch name, Git ref, commit hash, shortened commit hash, or other commit-ish."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:149
#: ../source/specifications/direct-url-data-structure.rst:180
#: ../source/specifications/direct-url-data-structure.rst:203
#: ../source/specifications/direct-url-data-structure.rst:227
msgid "``commit_id`` field"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:151
msgid "A commit hash (40 hexadecimal characters sha1)."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:155
msgid "Tools can use the ``git show-ref`` and ``git symbolic-ref`` commands to determine if the ``requested_revision`` corresponds to a Git ref. In turn, a ref beginning with ``refs/tags/`` corresponds to a tag, and a ref beginning with ``refs/remotes/origin/`` after cloning corresponds to a branch."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:162
msgid "Mercurial"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:166
msgid "https://www.mercurial-scm.org/"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:170
#: ../source/specifications/direct-url-data-structure.rst:174
msgid "hg"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:178
msgid "A tag name, branch name, changeset ID, shortened changeset ID."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:182
msgid "A changeset ID (40 hexadecimal characters)."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:185
msgid "Bazaar"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:189
msgid "https://www.breezy-vcs.org/"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:193
#: ../source/specifications/direct-url-data-structure.rst:197
msgid "bzr"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:201
msgid "A tag name, branch name, revision id."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:205
msgid "A revision id."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:208
msgid "Subversion"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:212
msgid "https://subversion.apache.org/"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:216
#: ../source/specifications/direct-url-data-structure.rst:220
msgid "svn"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:224
msgid "``requested_revision`` must be compatible with ``svn checkout`` ``--revision`` option. In Subversion, branch or tag is part of ``url``."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:229
msgid "Since Subversion does not support globally unique identifiers, this field is the Subversion revision number in the corresponding repository."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:236
msgid "Source archive:"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:249
msgid "Git URL with tag and commit-hash:"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:262
msgid "Local directory:"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:271
msgid "Local directory in editable mode:"
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:285
msgid "March 2020: this data structure was originally specified as part of the ``direct_url.json`` metadata file in :pep:`610` and is formally documented here."
msgstr ""

#: ../source/specifications/direct-url-data-structure.rst:287
msgid "January 2023: Added the ``archive_info.hashes`` key ([discussion](https://discuss.python.org/t/22299))."
msgstr ""

#: ../source/specifications/entry-points.rst:5
msgid "Entry points specification"
msgstr ""

#: ../source/specifications/entry-points.rst:7
msgid "*Entry points* are a mechanism for an installed distribution to advertise components it provides to be discovered and used by other code. For example:"
msgstr ""

#: ../source/specifications/entry-points.rst:11
msgid "Distributions can specify ``console_scripts`` entry points, each referring to a function. When *pip* (or another console_scripts aware installer) installs the distribution, it will create a command-line wrapper for each entry point."
msgstr ""

#: ../source/specifications/entry-points.rst:14
msgid "Applications can use entry points to load plugins; e.g. Pygments (a syntax highlighting tool) can use additional lexers and styles from separately installed packages. For more about this, see :doc:`/guides/creating-and-discovering-plugins`."
msgstr ""

#: ../source/specifications/entry-points.rst:19
msgid "The entry point file format was originally developed to allow packages built with setuptools to provide integration point metadata that would be read at runtime with ``importlib.metadata``. It is now defined as a PyPA interoperability specification in order to allow build tools other than setuptools to publish ``importlib.metadata`` compatible entry point metadata, and runtime libraries other than ``importlib.metadata`` to portably read published entry point metadata (potentially with different caching and conflict resolution strategies)."
msgstr ""

#: ../source/specifications/entry-points.rst:28
msgid "Data model"
msgstr ""

#: ../source/specifications/entry-points.rst:30
msgid "Conceptually, an entry point is defined by three required properties:"
msgstr ""

#: ../source/specifications/entry-points.rst:32
msgid "The **group** that an entry point belongs to indicates what sort of object it provides. For instance, the group ``console_scripts`` is for entry points referring to functions which can be used as a command, while ``pygments.styles`` is the group for classes defining pygments styles. The consumer typically defines the expected interface. To avoid clashes, consumers defining a new group should use names starting with a PyPI name owned by the consumer project, followed by ``.``. Group names must be one or more groups of letters, numbers and underscores, separated by dots (regex ``^\\w+(\\.\\w+)*$``)."
msgstr ""

#: ../source/specifications/entry-points.rst:42
msgid "The **name** identifies this entry point within its group. The precise meaning of this is up to the consumer. For console scripts, the name of the entry point is the command that will be used to launch it. Within a distribution, entry point names should be unique. If different distributions provide the same name, the consumer decides how to handle such conflicts. The name may contain any characters except ``=``, but it cannot start or end with any whitespace character, or start with ``[``. For new entry points, it is recommended to use only letters, numbers, underscores, dots and dashes (regex ``[\\w.-]+``)."
msgstr ""

#: ../source/specifications/entry-points.rst:51
msgid "The **object reference** points to a Python object. It is either in the form ``importable.module``, or ``importable.module:object.attr``. Each of the parts delimited by dots and the colon is a valid Python identifier. It is intended to be looked up like this::"
msgstr ""

#: ../source/specifications/entry-points.rst:64
msgid "Some tools call this kind of object reference by itself an 'entry point', for want of a better term, especially where it points to a function to launch a program."
msgstr ""

#: ../source/specifications/entry-points.rst:68
msgid "There is also an optional property: the **extras** are a set of strings identifying optional features of the distribution providing the entry point. If these are specified, the entry point requires the dependencies of those 'extras'. See the metadata field :ref:`metadata_provides_extra`."
msgstr ""

#: ../source/specifications/entry-points.rst:73
msgid "Using extras for an entry point is no longer recommended. Consumers should support parsing them from existing distributions, but may then ignore them. New publishing tools need not support specifying extras. The functionality of handling extras was tied to setuptools' model of managing 'egg' packages, but newer tools such as pip and virtualenv use a different model."
msgstr ""

#: ../source/specifications/entry-points.rst:80
msgid "File format"
msgstr ""

#: ../source/specifications/entry-points.rst:82
msgid "Entry points are defined in a file called :file:`entry_points.txt` in the :file:`*.dist-info` directory of the distribution. This is the directory described in :ref:`recording-installed-packages` for installed distributions, and in :ref:`binary-distribution-format` for wheels. The file uses the UTF-8 character encoding."
msgstr ""

#: ../source/specifications/entry-points.rst:88
msgid "The file contents are in INI format, as read by Python's :mod:`configparser` module. However, configparser treats names as case-insensitive by default, whereas entry point names are case sensitive. A case-sensitive config parser can be made like this::"
msgstr ""

#: ../source/specifications/entry-points.rst:98
msgid "The entry points file must always use ``=`` to delimit names from values (whereas configparser also allows using ``:``)."
msgstr ""

#: ../source/specifications/entry-points.rst:101
msgid "The sections of the config file represent entry point groups, the names are names, and the values encode both the object reference and the optional extras. If extras are used, they are a comma-separated list inside square brackets."
msgstr ""

#: ../source/specifications/entry-points.rst:105
msgid "Within a value, readers must accept and ignore spaces (including multiple consecutive spaces) before or after the colon, between the object reference and the left square bracket, between the extra names and the square brackets and colons delimiting them, and after the right square bracket. The syntax for extras is formally specified as part of :pep:`508` (as ``extras``) and restrictions on values specified in :pep:`685`. For tools writing the file, it is recommended only to insert a space between the object reference and the left square bracket."
msgstr ""

#: ../source/specifications/entry-points.rst:114
#: ../source/specifications/version-specifiers.rst:199
msgid "For example::"
msgstr ""

#: ../source/specifications/entry-points.rst:126
msgid "Use for scripts"
msgstr ""

#: ../source/specifications/entry-points.rst:128
msgid "Two groups of entry points have special significance in packaging: ``console_scripts`` and ``gui_scripts``. In both groups, the name of the entry point should be usable as a command in a system shell after the package is installed. The object reference points to a function which will be called with no arguments when this command is run. The function may return an integer to be used as a process exit code, and returning ``None`` is equivalent to returning ``0``."
msgstr ""

#: ../source/specifications/entry-points.rst:136
msgid "For instance, the entry point ``mycmd = mymod:main`` would create a command ``mycmd`` launching a script like this::"
msgstr ""

#: ../source/specifications/entry-points.rst:143
msgid "The difference between ``console_scripts`` and ``gui_scripts`` only affects Windows systems. ``console_scripts`` are wrapped in a console executable, so they are attached to a console and can use ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` for input and output. ``gui_scripts`` are wrapped in a GUI executable, so they can be started without a console, but cannot use standard streams unless application code redirects them. Other platforms do not have the same distinction."
msgstr ""

#: ../source/specifications/entry-points.rst:151
msgid "Install tools are expected to set up wrappers for both ``console_scripts`` and ``gui_scripts`` in the scripts directory of the install scheme. They are not responsible for putting this directory in the ``PATH`` environment variable which defines where command-line tools are found."
msgstr ""

#: ../source/specifications/entry-points.rst:156
msgid "As files are created from the names, and some filesystems are case-insensitive, packages should avoid using names in these groups which differ only in case. The behaviour of install tools when names differ only in case is undefined."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:6
msgid "Externally Managed Environments"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:8
msgid "While some Python installations are entirely managed by the user that installed Python, others may be provided and managed by another means (such as the operating system package manager in a Linux distribution, or as a bundled Python environment in an application with a dedicated installer)."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:13
msgid "Attempting to use conventional Python packaging tools to manipulate such environments can be confusing at best and outright break the entire underlying operating system at worst. Documentation and interoperability guides only go so far in resolving such problems."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:18
msgid "This specification defines an ``EXTERNALLY-MANAGED`` marker file that allows a Python installation to indicate to Python-specific tools such as ``pip`` that they neither install nor remove packages into the interpreter’s default installation environment, and should instead guide the end user towards using :ref:`virtual-environments`."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:24
msgid "It also standardizes an interpretation of the ``sysconfig`` schemes so that, if a Python-specific package manager is about to install a package in an interpreter-wide context, it can do so in a manner that will avoid conflicting with the external package manager and reduces the risk of breaking software shipped by the external package manager."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:32
msgid "Terminology"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:34
msgid "A few terms used in this specification have multiple meanings in the contexts that it spans. For clarity, this specification uses the following terms in specific ways:"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:61
msgid "distro"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:39
msgid "Short for \"distribution,\" a collection of various sorts of software, ideally designed to work properly together, including (in contexts relevant to this document) the Python interpreter itself, software written in Python, and software written in other languages. That is, this is the sense used in phrases such as \"Linux distro\" or \"Berkeley Software Distribution.\""
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:46
msgid "A distro can be an operating system (OS) of its own, such as Debian, Fedora, or FreeBSD. It can also be an overlay distribution that installs on top of an existing OS, such as Homebrew or MacPorts."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:51
msgid "This document uses the short term \"distro,\" because the term \"distribution\" has another meaning in Python packaging contexts: a source or binary distribution package of a single piece of Python language software, that is, in the sense of ``setuptools.dist.Distribution`` or \"sdist\". To avoid confusion, this document does not use the plain term \"distribution\" at all. In the Python packaging sense, it uses the full phrase \"distribution package\" or just \"package\" (see below)."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:60
msgid "The provider of a distro - the team or company that collects and publishes the software and makes any needed modifications - is its **distributor**."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:79
msgid "package"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:64
msgid "A unit of software that can be installed and used within Python. That is, this refers to what Python-specific packaging tools tend to call a :term:`distribution package` or simply a \"distribution\"; the colloquial abbreviation \"package\" is used in the sense of the Python Package Index."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:70
msgid "This document does not use \"package\" in the sense of an importable name that contains Python modules, though in many cases, a distribution package consists of a single importable package of the same name."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:75
msgid "This document generally does not use the term \"package\" to refer to units of installation by a distro's package manager (such as ``.deb`` or ``.rpm`` files). When needed, it uses phrasing such as \"a distro's package.\" (Again, in many cases, a Python package is shipped inside a distro's package named something like ``python-`` plus the Python package name.)"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:102
msgid "Python-specific package manager"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:82
msgid "A tool for installing, upgrading, and/or removing Python packages in a manner that conforms to Python packaging standards. The most popular Python-specific package manager is pip_; other examples include the old `Easy Install command <easy-install_>`_ as well as direct usage of a ``setup.py`` command."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:92
msgid "(Note that the ``easy_install`` command was removed in setuptools version 52, released 23 January 2021.)"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:96
msgid "(Conda_ is a bit of a special case, as the ``conda`` command can install much more than just Python packages, making it more like a distro package manager in some senses. Since the ``conda`` command generally only operates on Conda-created environments, most of the concerns in this document do not apply to ``conda`` when acting as a Python-specific package manager.)"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:118
msgid "distro package manager"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:105
msgid "A tool for installing, upgrading, and/or removing a distro's packages in an installed instance of that distro, which is capable of installing Python packages as well as non-Python packages, and therefore generally has its own database of installed software unrelated to the :ref:`database of installed distributions <recording-installed-packages>`. Examples include ``apt``, ``dpkg``, ``dnf``, ``rpm``, ``pacman``, and ``brew``. The salient feature is that if a package was installed by a distro package manager, removing or upgrading it in a way that would satisfy a Python-specific package manager will generally leave a distro package manager in an inconsistent state."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:117
msgid "This document also uses phrases like \"external package manager\" or \"system's package manager\" to refer to a distro package manager in certain contexts."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:127
msgid "shadow"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:121
msgid "To shadow an installed Python package is to cause some other package to be preferred for imports without removing any files from the shadowed package. This requires multiple entries on ``sys.path``: if package A 2.0 installs module ``a.py`` in one ``sys.path`` entry, and package A 1.0 installs module ``a.py`` in a later ``sys.path`` entry, then ``import a`` returns the module from the former, and we say that A 2.0 shadows A 1.0."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:132
msgid "This specification is twofold."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:134
msgid "First, it describes **a way for distributors of a Python interpreter to mark that interpreter as having its packages managed by means external to Python**, such that Python-specific tools like pip should not change the installed packages in the interpreter's global ``sys.path`` in any way (add, upgrade/downgrade, or remove) unless specifically overridden. It also provides a means for the distributor to indicate how to use a virtual environment as an alternative."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:142
msgid "This is an opt-in mechanism: by default, the Python interpreter compiled from upstream sources will not be so marked, and so running ``pip install`` with a self-compiled interpreter, or with a distro that has not explicitly marked its interpreter, will work as it always has worked."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:148
msgid "Second, it sets the rule that when installing packages to an interpreter's global context (either to an unmarked interpreter, or if overriding the marking), **Python-specific package managers should modify or delete files only within the directories of the sysconfig scheme in which they would create files**. This permits a distributor of a Python interpreter to set up two directories, one for its own managed packages, and one for unmanaged packages installed by the end user, and ensure that installing unmanaged packages will not delete (or overwrite) files owned by the external package manager."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:160
msgid "Marking an interpreter as using an external package manager"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:162
msgid "Before a Python-specific package installer (that is, a tool such as pip - not an external tool such as apt) installs a package into a certain Python context, it should make the following checks by default:"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:167
msgid "Is it running outside of a virtual environment? It can determine this by whether ``sys.prefix == sys.base_prefix``."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:170
msgid "Is there an ``EXTERNALLY-MANAGED`` file in the directory identified by ``sysconfig.get_path(\"stdlib\", sysconfig.get_default_scheme())``?"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:173
msgid "If both of these conditions are true, the installer should exit with an error message indicating that package installation into this Python interpreter's directory are disabled outside of a virtual environment."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:177
msgid "The installer should have a way for the user to override these rules, such as a command-line flag ``--break-system-packages``. This option should not be enabled by default and should carry some connotation that its use is risky."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:182
msgid "The ``EXTERNALLY-MANAGED`` file is an INI-style metadata file intended to be parsable by the standard library configparser_ module. If the file can be parsed by ``configparser.ConfigParser(interpolation=None)`` using the UTF-8 encoding, and it contains a section ``[externally-managed]``, then the installer should look for an error message specified in the file and output it as part of its error. If the first element of the tuple returned by ``locale.getlocale(locale.LC_MESSAGES)``, i.e., the language code, is not ``None``, it should look for the error message as the value of a key named ``Error-`` followed by the language code. If that key does not exist, and if the language code contains underscore or hyphen, it should look for a key named ``Error-`` followed by the portion of the language code before the underscore or hyphen. If it cannot find either of those, or if the language code is ``None``, it should look for a key simply named ``Error``."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:200
msgid "If the installer cannot find an error message in the file (either because the file cannot be parsed or because no suitable error key exists), then the installer should just use a pre-defined error message of its own, which should suggest that the user create a virtual environment to install packages."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:206
msgid "Software distributors who have a non-Python-specific package manager that manages libraries in the ``sys.path`` of their Python package should, in general, ship a ``EXTERNALLY-MANAGED`` file in their standard library directory. For instance, Debian may ship a file in ``/usr/lib/python3.9/EXTERNALLY-MANAGED`` consisting of something like"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:230
msgid "which provides useful and distro-relevant information to a user trying to install a package. Optionally, translations can be provided in the same file:"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:240
msgid "In certain contexts, such as single-application container images that aren't updated after creation, a distributor may choose not to ship an ``EXTERNALLY-MANAGED`` file, so that users can install whatever they like (as they can today) without having to manually override this rule."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:247
msgid "Writing to only the target ``sysconfig`` scheme"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:249
msgid "Usually, a Python package installer installs to directories in a scheme returned by the ``sysconfig`` standard library package. Ordinarily, this is the scheme returned by ``sysconfig.get_default_scheme()``, but based on configuration (e.g. ``pip install --user``), it may use a different scheme."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:255
msgid "Whenever the installer is installing to a ``sysconfig`` scheme, this specification declares that the installer should never modify or delete files outside of that scheme. For instance, if it's upgrading a package, and the package is already installed in a directory outside that scheme (perhaps in a directory from another scheme), it should leave the existing files alone."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:262
msgid "If the installer does end up shadowing an existing installation during an upgrade, we recommend that it produces a warning at the end of its run."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:266
msgid "If the installer is installing to a location outside of a ``sysconfig`` scheme (e.g., ``pip install --target``), then this subsection does not apply."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:271
msgid "Recommendations for distros"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:273
msgid "This section is non-normative. It provides best practices we believe distros should follow unless they have a specific reason otherwise."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:277
msgid "Mark the installation as externally managed"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:279
msgid "Distros should create an ``EXTERNALLY-MANAGED`` file in their ``stdlib`` directory."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:283
msgid "Guide users towards virtual environments"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:285
msgid "The file should contain a useful and distro-relevant error message indicating both how to install system-wide packages via the distro's package manager and how to set up a virtual environment. If your distro is often used by users in a state where the ``python3`` command is available (and especially where ``pip`` or ``get-pip`` is available) but ``python3 -m venv`` does not work, the message should indicate clearly how to make ``python3 -m venv`` work properly."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:293
msgid "Consider packaging pipx_, a tool for installing Python-language applications, and suggesting it in the error. pipx automatically creates a virtual environment for that application alone, which is a much better default for end users who want to install some Python-language software (which isn't available in the distro) but are not themselves Python users. Packaging pipx in the distro avoids the irony of instructing users to ``pip install --user --break-system-packages pipx`` to *avoid* breaking system packages. Consider arranging things so your distro's package / environment for Python for end users (e.g., ``python3`` on Fedora or ``python3-full`` on Debian) depends on pipx."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:308
msgid "Keep the marker file in container images"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:310
msgid "Distros that produce official images for single-application containers (e.g., Docker container images) should keep the ``EXTERNALLY-MANAGED`` file, preferably in a way that makes it not go away if a user of that image installs package updates inside their image (think ``RUN apt-get dist-upgrade``)."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:317
msgid "Create separate distro and local directories"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:319
msgid "Distros should place two separate paths on the system interpreter's ``sys.path``, one for distro-installed packages and one for packages installed by the local system administrator, and configure ``sysconfig.get_default_scheme()`` to point at the latter path. This ensures that tools like pip will not modify distro-installed packages. The path for the local system administrator should come before the distro path on ``sys.path`` so that local installs take preference over distro packages."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:328
msgid "For example, Fedora and Debian (and their derivatives) both implement this split by using ``/usr/local`` for locally-installed packages and ``/usr`` for distro-installed packages. Fedora uses ``/usr/local/lib/python3.x/site-packages`` vs. ``/usr/lib/python3.x/site-packages``. (Debian uses ``/usr/local/lib/python3/dist-packages`` vs. ``/usr/lib/python3/dist-packages`` as an additional layer of separation from a locally-compiled Python interpreter: if you build and install upstream CPython in ``/usr/local/bin``, it will look at ``/usr/local/lib/python3/site-packages``, and Debian wishes to make sure that packages installed via the locally-built interpreter don't show up on ``sys.path`` for the distro interpreter.)"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:341
msgid "Note that the ``/usr/local`` vs. ``/usr`` split is analogous to how the ``PATH`` environment variable typically includes ``/usr/local/bin:/usr/bin`` and non-distro software installs to ``/usr/local`` by default. This split is `recommended by the Filesystem Hierarchy Standard`__."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:349
msgid "There are two ways you could do this. One is, if you are building and packaging Python libraries directly (e.g., your packaging helpers unpack a wheel or call ``setup.py install``), arrange for those tools to use a directory that is not in a ``sysconfig`` scheme but is still on ``sys.path``."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:355
msgid "The other is to arrange for the default ``sysconfig`` scheme to change when running inside a package build versus when running on an installed system. The ``sysconfig`` customization hooks from bpo-43976_ should make this easy (once accepted and implemented): make your packaging tool set an environment variable or some other detectable configuration, and define a ``get_preferred_schemes`` function to return a different scheme when called from inside a package build. Then you can use ``pip install`` as part of your distro packaging."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:367
msgid "We propose adding a ``--scheme=...`` option to instruct pip to run against a specific scheme. (See `Implementation Notes`_ below for how pip currently determines schemes.) Once that's available, for local testing and possibly for actual packaging, you would be able to run something like ``pip install --scheme=posix_distro`` to explicitly install a package into your distro's location (bypassing ``get_preferred_schemes``). One could also, if absolutely needed, use ``pip uninstall --scheme=posix_distro`` to use pip to remove packages from the system-managed directory."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:377
msgid "To install packages with pip, you would also need to either suppress the ``EXTERNALLY-MANAGED`` marker file to allow pip to run or to override it on the command line. You may want to use the same means for suppressing the marker file in build chroots as you do in container images."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:383
msgid "The advantage of setting these up to be automatic (suppressing the marker file in your build environment and having ``get_preferred_schemes`` automatically return your distro's scheme) is that an unadorned ``pip install`` will work inside a package build, which generally means that an unmodified upstream build script that happens to internally call ``pip install`` will do the right thing. You can, of course, just ensure that your packaging process always calls ``pip install --scheme=posix_distro --break-system-packages``, which would work too."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:393
msgid "The best approach here depends a lot on your distro's conventions and mechanisms for packaging."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:396
msgid "Similarly, the ``sysconfig`` paths that are not for importable Python code - that is, ``include``, ``platinclude``, ``scripts``, and ``data`` - should also have two variants, one for use by distro-packaged software and one for use for locally-installed software, and the distro should be set up such that both are usable. For instance, a typical FHS-compliant distro will use ``/usr/local/include`` for the default scheme's ``include`` and ``/usr/include`` for distro-packaged headers and place both on the compiler's search path, and it will use ``/usr/local/bin`` for the default scheme's ``scripts`` and ``/usr/bin`` for distro-packaged entry points and place both on ``$PATH``."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:410
msgid "Implementation Notes"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:412
msgid "This section is non-normative and contains notes relevant to both the specification and potential implementations."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:415
msgid "Currently (as of May 2021), pip does not directly expose a way to choose a target ``sysconfig`` scheme, but it has three ways of looking up schemes when installing:"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:422
msgid "``pip install``"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:420
msgid "Calls ``sysconfig.get_default_scheme()``, which is usually (in upstream CPython and most current distros) the same as ``get_preferred_scheme('prefix')``."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:425
msgid "``pip install --prefix=/some/path``"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:425
msgid "Calls ``sysconfig.get_preferred_scheme('prefix')``."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:428
msgid "``pip install --user``"
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:428
msgid "Calls ``sysconfig.get_preferred_scheme('user')``."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:430
msgid "Finally, ``pip install --target=/some/path`` writes directly to ``/some/path`` without looking up any schemes."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:433
msgid "Debian currently carries a `patch to change the default install location inside a virtual environment`__, using a few heuristics (including checking for the ``VIRTUAL_ENV`` environment variable), largely so that the directory used in a virtual environment remains ``site-packages`` and not ``dist-packages``. This does not particularly affect this proposal, because the implementation of that patch does not actually change the default ``sysconfig`` scheme, and notably does not change the result of ``sysconfig.get_path(\"stdlib\")``."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:445
msgid "Fedora currently carries a `patch to change the default install location when not running inside rpmbuild`__, which they use to implement the two-system-wide-directories approach. This is conceptually the sort of hook envisioned by bpo-43976_, except implemented as a code patch to ``distutils`` instead of as a changed ``sysconfig`` scheme."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:454
msgid "The implementation of ``is_virtual_environment`` above, as well as the logic to load the ``EXTERNALLY-MANAGED`` file and find the error message from it, may as well get added to the standard library (``sys`` and ``sysconfig``, respectively), to centralize their implementations, but they don't need to be added yet."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:466
msgid "This document is placed in the public domain or under the CC0-1.0-Universal license, whichever is more permissive."
msgstr ""

#: ../source/specifications/externally-managed-environments.rst:474
msgid "This specification was originally approved as :pep:`668`."
msgstr ""

#: ../source/specifications/index.rst:4
msgid "PyPA specifications"
msgstr ""

#: ../source/specifications/index.rst:6
msgid "This is a list of currently active interoperability specifications maintained by the Python Packaging Authority. The process for updating these standards, and for proposing new ones, is documented on `pypa.io <https://www.pypa.io/en/latest/specifications/>`__."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:3
msgid "Inline script metadata"
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:6
msgid "This specification has been **provisionally accepted**. It is subject to being changed or abandoned. See the `PEP 723 conditional acceptance thread <pep723-thread_>`_ for details."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:12
msgid "This specification defines a metadata format that can be embedded in single-file Python scripts to assist launchers, IDEs and other external tools which may need to interact with such scripts."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:20
msgid "This specification defines a metadata comment block format (loosely inspired by `reStructuredText Directives`__)."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:25
msgid "Any Python script may have top-level comment blocks that MUST start with the line ``# /// TYPE`` where ``TYPE`` determines how to process the content. That is: a single ``#``, followed by a single space, followed by three forward slashes, followed by a single space, followed by the type of metadata. Block MUST end with the line ``# ///``. That is: a single ``#``, followed by a single space, followed by three forward slashes. The ``TYPE`` MUST only consist of ASCII letters, numbers and hyphens."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:33
msgid "Every line between these two lines (``# /// TYPE`` and ``# ///``) MUST be a comment starting with ``#``. If there are characters after the ``#`` then the first character MUST be a space. The embedded content is formed by taking away the first two characters of each line if the second character is a space, otherwise just the first character (which means the line consists of only a single ``#``)."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:40
msgid "Precedence for an ending line ``# ///`` is given when the next line is not a valid embedded content line as described above. For example, the following is a single fully valid block:"
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:56
msgid "A starting line MUST NOT be placed between another starting line and its ending line. In such cases tools MAY produce an error. Unclosed blocks MUST be ignored."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:59
msgid "When there are multiple comment blocks of the same ``TYPE`` defined, tools MUST produce an error."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:62
msgid "Tools reading embedded metadata MAY respect the standard Python encoding declaration. If they choose not to do so, they MUST process the file as UTF-8."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:65
msgid "This is the canonical regular expression that MAY be used to parse the metadata:"
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:72
msgid "In circumstances where there is a discrepancy between the text specification and the regular expression, the text specification takes precedence."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:75
msgid "Tools MUST NOT read from metadata blocks with types that have not been standardized by this PEP or future ones."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:79
msgid "pyproject type"
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:81
msgid "The first type of metadata block is named ``pyproject`` which represents content similar to what one would see in a ``pyproject.toml`` file."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:84
msgid "This document MAY include the ``[run]`` and ``[tool]`` tables."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:86
msgid "The :ref:`tool table <pyproject-tool-table>` MAY be used by any tool, script runner or otherwise, to configure behavior."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:89
msgid "The ``[run]`` table MAY include the following optional fields:"
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:91
msgid "``dependencies``: A list of strings that specifies the runtime dependencies of the script. Each entry MUST be a valid :ref:`dependency specifier <dependency-specifiers>`."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:94
msgid "``requires-python``: A string that specifies the Python version(s) with which the script is compatible. The value of this field MUST be a valid :ref:`version specifier <version-specifiers>`."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:98
msgid "Any future specifications that define additional fields for the ``[run]`` table when used in a ``pyproject.toml`` file MUST include the aforementioned fields exactly as specified. The fields defined by this specification are equally as applicable to full-fledged projects as they are to single-file scripts."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:103
msgid "Script runners MUST error if the specified ``dependencies`` cannot be provided. Script runners SHOULD error if no version of Python that satisfies the specified ``requires-python`` can be provided."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:108
msgid "Example"
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:110
msgid "The following is an example of a script with an embedded ``pyproject.toml``:"
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:130
msgid "The following is an example of a proposed syntax for single-file Rust projects that embeds their equivalent of ``pyproject.toml``, which is called ``Cargo.toml``:"
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:149
msgid "Reference Implementation"
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:151
msgid "The following is an example of how to read the metadata on Python 3.11 or higher."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:177
msgid "Often tools will edit dependencies like package managers or dependency update automation in CI. The following is a crude example of modifying the content using the ``tomlkit`` library__."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:208
msgid "Note that this example used a library that preserves TOML formatting. This is not a requirement for editing by any means but rather is a \"nice to have\" feature."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:212
msgid "The following is an example of how to read a stream of arbitrary metadata blocks."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:231
msgid "Recommendations"
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:233
msgid "Tools that support managing different versions of Python should attempt to use the highest available version of Python that is compatible with the script's ``requires-python`` metadata, if defined."
msgstr ""

#: ../source/specifications/inline-script-metadata.rst:241
msgid "This specification was originally defined as :pep:`723`."
msgstr ""

#: ../source/specifications/name-normalization.rst:5
msgid "Package name normalization"
msgstr ""

#: ../source/specifications/name-normalization.rst:7
msgid "Project names are \"normalized\" for use in various contexts. This document describes how project names should be normalized."
msgstr ""

#: ../source/specifications/name-normalization.rst:10
msgid "Valid non-normalized names"
msgstr ""

#: ../source/specifications/name-normalization.rst:12
msgid "A valid name consists only of ASCII letters and numbers, period, underscore and hyphen. It must start and end with a letter or number. This means that valid project names are limited to those which match the following regex (run with ``re.IGNORECASE``)::"
msgstr ""

#: ../source/specifications/name-normalization.rst:20
#: ../source/specifications/version-specifiers.rst:392
msgid "Normalization"
msgstr ""

#: ../source/specifications/name-normalization.rst:22
msgid "The name should be lowercased with all runs of the characters ``.``, ``-``, or ``_`` replaced with a single ``-`` character. This can be implemented in Python with the re module:"
msgstr ""

#: ../source/specifications/name-normalization.rst:31
msgid "This means that the following names are all equivalent:"
msgstr ""

#: ../source/specifications/name-normalization.rst:33
msgid "``friendly-bard``  (normalized form)"
msgstr ""

#: ../source/specifications/name-normalization.rst:34
msgid "``Friendly-Bard``"
msgstr ""

#: ../source/specifications/name-normalization.rst:35
msgid "``FRIENDLY-BARD``"
msgstr ""

#: ../source/specifications/name-normalization.rst:36
msgid "``friendly.bard``"
msgstr ""

#: ../source/specifications/name-normalization.rst:37
msgid "``friendly_bard``"
msgstr ""

#: ../source/specifications/name-normalization.rst:38
msgid "``friendly--bard``"
msgstr ""

#: ../source/specifications/name-normalization.rst:39
msgid "``FrIeNdLy-._.-bArD`` (a *terrible* way to write a name, but it is valid)"
msgstr ""

#: ../source/specifications/name-normalization.rst:44
msgid "`September 2015 <https://mail.python.org/pipermail/distutils-sig/2015-September/026899.html>`_: normalized name was originally specified in :pep:`503#normalized-names`."
msgstr ""

#: ../source/specifications/name-normalization.rst:45
msgid "`November 2015 <https://mail.python.org/pipermail/distutils-sig/2015-November/027868.html>`_: valid non-normalized name was originally specified in :pep:`508#names`."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:6
msgid "Platform compatibility tags"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:8
msgid "Platform compatibility tags allow build tools to mark distributions as being compatible with specific platforms, and allows installers to understand which distributions are compatible with the system they are running on."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:12
msgid "The following PEPs contributed to this spec:"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:14
msgid ":pep:`425`"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:15
msgid ":pep:`513`"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:16
msgid ":pep:`571`"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:17
msgid ":pep:`599`"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:18
msgid ":pep:`600`"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:23
msgid "The tag format is ``{python tag}-{abi tag}-{platform tag}``."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:25
msgid "python tag"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:26
msgid "'py27', 'cp33'"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:28
msgid "'cp32dmu', 'none'"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:30
msgid "'linux_x86_64', 'any'"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:32
msgid "For example, the tag ``py27-none-any`` indicates compatibility with Python 2.7 (any Python 2.7 implementation) with no abi requirement, on any platform."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:36
#: ../source/specifications/platform-compatibility-tags.rst:170
msgid "Use"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:38
msgid "The ``wheel`` built package format includes these tags in its filenames, of the form ``{distribution}-{version}(-{build tag})?-{python tag}-{abitag}-{platform tag}.whl``. Other package formats may have their own conventions."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:43
msgid "Any potential spaces in any tag should be replaced with ``_``."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:49
msgid "Python Tag"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:51
msgid "The Python tag indicates the implementation and version required by a distribution.  Major implementations have abbreviated codes, initially:"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:54
msgid "py: Generic Python (does not require implementation-specific features)"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:55
msgid "cp: CPython"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:56
msgid "ip: IronPython"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:57
msgid "pp: PyPy"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:58
msgid "jy: Jython"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:60
msgid "Other Python implementations should use ``sys.implementation.name``."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:62
msgid "The version is ``py_version_nodot``.  CPython gets away with no dot, but if one is needed the underscore ``_`` is used instead.  PyPy should probably use its own versions here ``pp18``, ``pp19``."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:66
msgid "The version can be just the major version ``2`` or ``3`` ``py2``, ``py3`` for many pure-Python distributions."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:69
msgid "Importantly, major-version-only tags like ``py2`` and ``py3`` are not shorthand for ``py20`` and ``py30``.  Instead, these tags mean the packager intentionally released a cross-version-compatible distribution."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:73
msgid "A single-source Python 2/3 compatible distribution can use the compound tag ``py2.py3``.  See `Compressed Tag Sets`_, below."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:77
msgid "ABI Tag"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:79
msgid "The ABI tag indicates which Python ABI is required by any included extension modules.  For implementation-specific ABIs, the implementation is abbreviated in the same way as the Python Tag, e.g. ``cp33d`` would be the CPython 3.3 ABI with debugging."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:84
msgid "The CPython stable ABI is ``abi3`` as in the shared library suffix."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:86
msgid "Implementations with a very unstable ABI may use the first 6 bytes (as 8 base64-encoded characters) of the SHA-256 hash of their source code revision and compiler flags, etc, but will probably not have a great need to distribute binary distributions. Each implementation's community may decide how to best use the ABI tag."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:93
msgid "Platform Tag"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:95
msgid "The platform tag is simply ``sysconfig.get_platform()`` with all hyphens ``-`` and periods ``.`` replaced with underscore ``_``. Until the removal of :ref:`distutils` in Python 3.12, this was ``distutils.util.get_platform()``."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:100
msgid "win32"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:101
msgid "linux_i386"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:102
msgid "linux_x86_64"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:107
msgid "``manylinux``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:110
msgid "The scheme defined in :pep:`425` was insufficient for public distribution of wheel files (and \\*nix wheel files in general) to Linux platforms, due to the large ecosystem of Linux platforms and subtle differences between them."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:114
msgid "Instead, :pep:`600` defines the ``manylinux`` standard, which represents a common subset of Linux platforms, and allows building wheels tagged with the ``manylinux`` platform tag which can be used across most common Linux distributions."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:119
msgid "There were multiple iterations of the ``manylinux`` specification, each representing the common subset of Linux platforms at a given point in time:"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:122
msgid "``manylinux1`` (:pep:`513`) supports ``x86_64`` and ``i686`` architectures, and is based on a compatible Linux platform from 2007."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:124
msgid "``manylinux2010`` (:pep:`571`) supports ``x86_64`` and ``i686`` architectures. and updates the previous specification to be based on a compatible Linux platform from 2010 instead."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:127
msgid "``manylinux2014`` (:pep:`599`) adds support for a number of additional architectures (``aarch64``, ``armv7l``, ``ppc64``, ``ppc64le``, and ``s390x``) and updates the base platform to a compatible Linux platform from 2014."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:132
msgid "``manylinux_x_y`` (:pep:`600`) supersedes all previous PEPs to define a future-proof standard. It defines ``x`` and ``y`` as glibc major an minor versions supported (e.g. ``manylinux_2_24`` should work on any distro using glibc 2.24+). Previous tags are still supported for backward compatibility."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:137
msgid "In general, distributions built for older versions of the specification are forwards-compatible (meaning that ``manylinux1`` distributions should continue to work on modern systems) but not backwards-compatible (meaning that ``manylinux2010`` distributions are not expected to work on platforms that existed before 2010)."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:143
msgid "Package maintainers should attempt to target the most compatible specification possible, with the caveat that the provided build environment for ``manylinux1`` and ``manylinux2010`` have reached end-of-life meaning that these images will no longer receive security updates."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:149
msgid "Manylinux compatibility support"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:152
msgid "The ``manylinux2014`` specification is relatively new and is not yet widely recognised by install tools."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:154
msgid "The ``manylinux_x_y`` specification is relatively new and is not yet widely recognised by install tools."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:157
msgid "The following table shows the minimum versions of relevant projects to support the various ``manylinux`` standards:"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:161
msgid "Tool"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:161
msgid "``manylinux1``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:161
msgid "``manylinux2010``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:161
msgid "``manylinux2014``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:161
msgid "``manylinux_x_y``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:163
msgid "``>=8.1.0``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:163
msgid "``>=19.0``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:163
msgid "``>=19.3``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:163
msgid "``>=20.3``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:164
msgid "auditwheel"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:164
msgid "``>=1.0.0``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:164
msgid "``>=2.0.0``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:164
msgid "``>=3.0.0``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:164
msgid "``>=3.3.0`` [#]_"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:167
msgid "Only support for ``manylinux_2_24`` has been added in auditwheel 3.3.0"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:172
msgid "The tags are used by installers to decide which built distribution (if any) to download from a list of potential built distributions. The installer maintains a list of (pyver, abi, arch) tuples that it will support.  If the built distribution's tag is ``in`` the list, then it can be installed."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:178
msgid "It is recommended that installers try to choose the most feature complete built distribution available (the one most specific to the installation environment) by default before falling back to pure Python versions published for older Python releases. Installers are also recommended to provide a way to configure and re-order the list of allowed compatibility tags; for example, a user might accept only the ``*-none-any`` tags to only download built packages that advertise themselves as being pure Python."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:186
msgid "Another desirable installer feature might be to include \"re-compile from source if possible\" as more preferable than some of the compatible but legacy pre-built options."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:190
msgid "This example list is for an installer running under CPython 3.3 on a linux_x86_64 system. It is in order from most-preferred (a distribution with a compiled extension module, built for the current version of Python) to least-preferred (a pure-Python distribution built with an older version of Python):"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:196
msgid "cp33-cp33m-linux_x86_64"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:197
msgid "cp33-abi3-linux_x86_64"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:198
msgid "cp3-abi3-linux_x86_64"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:199
msgid "cp33-none-linux_x86_64*"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:200
msgid "cp3-none-linux_x86_64*"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:201
msgid "py33-none-linux_x86_64*"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:202
msgid "py3-none-linux_x86_64*"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:203
msgid "cp33-none-any"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:204
msgid "cp3-none-any"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:205
msgid "py33-none-any"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:206
msgid "py3-none-any"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:207
msgid "py32-none-any"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:208
msgid "py31-none-any"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:209
msgid "py30-none-any"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:211
msgid "Built distributions may be platform specific for reasons other than C extensions, such as by including a native executable invoked as a subprocess."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:215
msgid "Sometimes there will be more than one supported built distribution for a particular version of a package.  For example, a packager could release a package tagged ``cp33-abi3-linux_x86_64`` that contains an optional C extension and the same distribution tagged ``py3-none-any`` that does not. The index of the tag in the supported tags list breaks the tie, and the package with the C extension is installed in preference to the package without because that tag appears first in the list."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:224
msgid "Compressed Tag Sets"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:226
msgid "To allow for compact filenames of bdists that work with more than one compatibility tag triple, each tag in a filename can instead be a '.'-separated, sorted, set of tags.  For example, pip, a pure-Python package that is written to run under Python 2 and 3 with the same source code, could distribute a bdist with the tag ``py2.py3-none-any``. The full list of simple tags is::"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:238
msgid "A bdist format that implements this scheme should include the expanded tags in bdist-specific metadata.  This compression scheme can generate large numbers of unsupported tags and \"impossible\" tags that are supported by no Python implementation e.g. \"cp33-cp31u-win64\", so use it sparingly."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:251
msgid "What tags are used by default?"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:247
msgid "Tools should use the most-preferred architecture dependent tag e.g. ``cp33-cp33m-win32`` or the most-preferred pure python tag e.g. ``py33-none-any`` by default.  If the packager overrides the default it indicates that they intended to provide cross-Python compatibility."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:261
msgid "What tag do I use if my distribution uses a feature exclusive to the newest version of Python?"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:254
msgid "Compatibility tags aid installers in selecting the *most compatible* build of a *single version* of a distribution. For example, when there is no Python 3.3 compatible build of ``beaglevote-1.2.0`` (it uses a Python 3.4 exclusive feature) it may still use the ``py3-none-any`` tag instead of the ``py34-none-any`` tag. A Python 3.3 user must combine other qualifiers, such as a requirement for the older release ``beaglevote-1.1.0`` that does not use the new feature, to get a compatible build."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:266
msgid "Why isn't there a ``.`` in the Python version number?"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:264
msgid "CPython has lasted 20+ years without a 3-digit major release. This should continue for some time.  Other implementations may use _ as a delimiter, since both - and . delimit the surrounding filename."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:272
msgid "Why normalise hyphens and other non-alphanumeric characters to underscores?"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:269
msgid "To avoid conflicting with the ``.`` and ``-`` characters that separate components of the filename, and for better compatibility with the widest range of filesystem limitations for filenames (including being usable in URL paths without quoting)."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:281
msgid "Why not use special character <X> rather than ``.`` or ``-``?"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:275
msgid "Either because that character is inconvenient or potentially confusing in some contexts (for example, ``+`` must be quoted in URLs, ``~`` is used to denote the user's home directory in POSIX), or because the advantages weren't sufficiently compelling to justify changing the existing reference implementation for the wheel format defined in :pep:`427` (for example, using ``,`` rather than ``.`` to separate components in a compressed tag)."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:286
msgid "Who will maintain the registry of abbreviated implementations?"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:284
msgid "New two-letter abbreviations can be requested on the python-dev mailing list.  As a rule of thumb, abbreviations are reserved for the current 4 most prominent implementations."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:291
msgid "Does the compatibility tag go into METADATA or PKG-INFO?"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:289
msgid "No.  The compatibility tag is part of the built distribution's metadata.  METADATA / PKG-INFO should be valid for an entire distribution, not a single build of that distribution."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:297
msgid "Why didn't you mention my favorite Python implementation?"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:294
msgid "The abbreviated tags facilitate sharing compiled Python code in a public index.  Your Python implementation can use this specification too, but with longer tags. Recall that all \"pure Python\" built distributions just use ``py``."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:303
msgid "Why is the ABI tag (the second tag) sometimes \"none\" in the reference implementation?"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:300
msgid "Since Python 2 does not have an easy way to get to the SOABI (the concept comes from newer versions of Python 3) the reference implementation at the time of writing guesses \"none\".  Ideally it would detect \"py27(d|m|u)\" analogous to newer versions of Python, but in the meantime \"none\" is a good enough way to say \"don't know\"."
msgstr ""

#: ../source/specifications/pypirc.rst:6
msgid "The :file:`.pypirc` file"
msgstr ""

#: ../source/specifications/pypirc.rst:8
msgid "A :file:`.pypirc` file allows you to define the configuration for :term:`package indexes <Package Index>` (referred to here as \"repositories\"), so that you don't have to enter the URL, username, or password whenever you upload a package with :ref:`twine` or :ref:`flit`."
msgstr ""

#: ../source/specifications/pypirc.rst:13
msgid "The format (originally defined by the :ref:`distutils` package) is:"
msgstr ""

#: ../source/specifications/pypirc.rst:32
msgid "The ``distutils`` section defines an ``index-servers`` field that lists the name of all sections describing a repository."
msgstr ""

#: ../source/specifications/pypirc.rst:35
msgid "Each section describing a repository defines three fields:"
msgstr ""

#: ../source/specifications/pypirc.rst:37
msgid "``repository``: The URL of the repository."
msgstr ""

#: ../source/specifications/pypirc.rst:38
msgid "``username``: The registered username on the repository."
msgstr ""

#: ../source/specifications/pypirc.rst:39
msgid "``password``: The password that will used to authenticate the username."
msgstr ""

#: ../source/specifications/pypirc.rst:43
msgid "Be aware that this stores your password in plain text. For better security, consider an alternative like `keyring`_, setting environment variables, or providing the password on the command line."
msgstr ""

#: ../source/specifications/pypirc.rst:47
msgid "Otherwise, set the permissions on :file:`.pypirc` so that only you can view or modify it. For example, on Linux or macOS, run:"
msgstr ""

#: ../source/specifications/pypirc.rst:57
msgid "Common configurations"
msgstr ""

#: ../source/specifications/pypirc.rst:61
msgid "These examples apply to :ref:`twine`. Other projects (e.g. :ref:`flit`) also use :file:`.pypirc`, but with different defaults. Please refer to each project's documentation for more details and usage instructions."
msgstr ""

#: ../source/specifications/pypirc.rst:65
msgid "Twine's default configuration mimics a :file:`.pypirc` with repository sections for PyPI and TestPyPI:"
msgstr ""

#: ../source/specifications/pypirc.rst:81
msgid "Twine will add additional configuration from :file:`$HOME/.pypirc`, the command line, and environment variables to this default configuration."
msgstr ""

#: ../source/specifications/pypirc.rst:85
msgid "Using a PyPI token"
msgstr ""

#: ../source/specifications/pypirc.rst:87
msgid "To set your `API token`_ for PyPI, you can create a :file:`$HOME/.pypirc` similar to:"
msgstr ""

#: ../source/specifications/pypirc.rst:96
msgid "For :ref:`TestPyPI <using-test-pypi>`, add a ``[testpypi]`` section, using the API token from your TestPyPI account."
msgstr ""

#: ../source/specifications/pypirc.rst:102
msgid "Using another package index"
msgstr ""

#: ../source/specifications/pypirc.rst:104
msgid "To configure an additional repository, you'll need to redefine the ``index-servers`` field to include the repository name. Here is a complete example of a :file:`$HOME/.pypirc` for PyPI, TestPyPI, and a private repository:"
msgstr ""

#: ../source/specifications/pypirc.rst:131
msgid "Instead of using the ``password`` field, consider saving your API tokens and passwords securely using `keyring`_ (which is installed by Twine):"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:5
msgid "Recording installed projects"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:7
msgid "This document specifies a common format of recording information about Python :term:`projects <Project>` installed in an environment. A common metadata format allows tools to query, manage or uninstall projects, regardless of how they were installed."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:12
msgid "Almost all information is optional. This allows tools outside the Python ecosystem, such as Linux package managers, to integrate with Python tooling as much as possible. For example, even if an installer cannot easily provide a list of installed files in a format specific to Python tooling, it should still record the name and version of the installed project."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:21
msgid "History and change workflow"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:23
msgid "The metadata described here was first specified in :pep:`376`, and later amended in :pep:`627` (and other PEPs). It was formerly known as *Database of Installed Python Distributions*. As with other PyPA specifications, editorial amendments with no functional impact may be made through the GitHub pull request workflow. Proposals for functional changes that would require amendments to package building and/or installation tools must be made through the PEP process (see :pep:`1`)."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:31
msgid "While this document is the normative specification, the PEPs that introduce changes to it may include additional information such as rationales and backwards compatibility considerations."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:39
msgid "Each project installed from a distribution must, in addition to files, install a \"``.dist-info``\" directory located alongside importable modules and packages (commonly, the ``site-packages`` directory)."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:43
msgid "This directory is named as ``{name}-{version}.dist-info``, with ``name`` and ``version`` fields corresponding to :ref:`core-metadata`. Both fields must be normalized (see the :ref:`name normalization specification <name-normalization>` and the :ref:`version normalization specification <version-specifiers-normalization>`), and replace dash (``-``) characters with underscore (``_``) characters, so the ``.dist-info`` directory always has exactly one dash (``-``) character in its stem, separating the ``name`` and ``version`` fields."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:51
msgid "Historically, tools have failed to replace dot characters or normalize case in the ``name`` field, or not perform normalization in the ``version`` field. Tools consuming ``.dist-info`` directories should expect those fields to be unnormalized, and treat them as equivalent to their normalized counterparts. New tools that write ``.dist-info`` directories MUST normalize both ``name`` and ``version`` fields using the rules described above, and existing tools are encouraged to start normalizing those fields."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:61
msgid "The ``.dist-info`` directory's name is formatted to unambiguously represent a distribution as a filesystem path. Tools presenting a distribution name to a user should avoid using the normalized name, and instead present the specified name (when needed prior to resolution to an installed package), or read the respective fields in Core Metadata, since values listed there are unescaped and accurately reflect the distribution. Libraries should provide API for such tools to consume, so tools can have access to the unnormalized name when displaying distribution information."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:70
msgid "This ``.dist-info`` directory may contain the following files, described in detail below:"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:73
msgid "``METADATA``: contains project metadata"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:74
msgid "``RECORD``: records the list of installed files."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:75
msgid "``INSTALLER``: records the name of the tool used to install the project."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:76
msgid "``entry_points.txt``: see :ref:`entry-points` for details"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:77
msgid "``direct_url.json``: see :ref:`direct-url` for details"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:79
msgid "The ``METADATA`` file is mandatory. All other files may be omitted at the installing tool's discretion. Additional installer-specific files may be present."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:85
msgid "The :ref:`binary-distribution-format` specification describes additional files that may appear in the ``.dist-info`` directory of a :term:`Wheel`. Such files may be copied to the ``.dist-info`` directory of an installed project."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:90
msgid "The previous versions of this specification also specified a ``REQUESTED`` file. This file is now considered a tool-specific extension, but may be standardized again in the future. See `PEP 376 <https://www.python.org/dev/peps/pep-0376/#requested>`_ for its original meaning."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:97
msgid "The METADATA file"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:99
msgid "The ``METADATA`` file contains metadata as described in the :ref:`core-metadata` specification, version 1.1 or greater."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:102
msgid "The ``METADATA`` file is mandatory. If it cannot be created, or if required core metadata is not available, installers must report an error and fail to install the project."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:108
msgid "The RECORD file"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:110
msgid "The ``RECORD`` file holds the list of installed files. It is a CSV file containing one record (line) per installed file."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:113
msgid "The CSV dialect must be readable with the default ``reader`` of Python's ``csv`` module:"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:116
msgid "field delimiter: ``,`` (comma),"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:117
msgid "quoting char: ``\"`` (straight double quote),"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:118
msgid "line terminator: either ``\\r\\n`` or ``\\n``."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:120
msgid "Each record is composed of three elements: the file's **path**, the **hash** of the contents, and its **size**."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:123
msgid "The *path* may be either absolute, or relative to the directory containing the ``.dist-info`` directory (commonly, the ``site-packages`` directory). On Windows, directories may be separated either by forward- or backslashes (``/`` or ``\\``)."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:128
msgid "The *hash* is either an empty string or the name of a hash algorithm from ``hashlib.algorithms_guaranteed``, followed by the equals character ``=`` and the digest of the file's contents, encoded with the urlsafe-base64-nopad encoding (``base64.urlsafe_b64encode(digest)`` with trailing ``=`` removed)."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:133
msgid "The *size* is either the empty string, or file's size in bytes, as a base 10 integer."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:136
msgid "For any file, either or both of the *hash* and *size* fields may be left empty. Commonly, entries for ``.pyc`` files and the ``RECORD`` file itself have empty *hash* and *size*. For other files, leaving the information out is discouraged, as it prevents verifying the integrity of the installed project."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:142
msgid "If the ``RECORD`` file is present, it must list all installed files of the project, except ``.pyc`` files corresponding to ``.py`` files listed in ``RECORD``, which are optional. Notably, the contents of the ``.dist-info`` directory (including the ``RECORD`` file itself) must be listed. Directories should not be listed."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:149
msgid "To completely uninstall a package, a tool needs to remove all files listed in ``RECORD``, all ``.pyc`` files (of all optimization levels) corresponding to removed ``.py`` files, and any directories emptied by the uninstallation."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:154
msgid "Here is an example snippet of a possible ``RECORD`` file::"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:173
msgid "If the ``RECORD`` file is missing, tools that rely on ``.dist-info`` must not attempt to uninstall or upgrade the package. (This restriction does not apply to tools that rely on other sources of information, such as system package managers in Linux distros.)"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:180
msgid "The INSTALLER file"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:182
msgid "If present, ``INSTALLER`` is a single-line text file naming the tool used to install the project. If the installer is executable from the command line, ``INSTALLER`` should contain the command name. Otherwise, it should contain a printable ASCII string."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:188
msgid "The file can be terminated by zero or more ASCII whitespace characters."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:190
msgid "Here are examples of two possible ``INSTALLER`` files::"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:198
msgid "This value should be used for informational purposes only. For example, if a tool is asked to uninstall a project but finds no ``RECORD`` file, it may suggest that the tool named in ``INSTALLER`` may be able to do the uninstallation."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:205
msgid "The entry_points.txt file"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:207
msgid "This file MAY be created by installers to indicate when packages contain components intended for discovery and use by other code, including console scripts and other applications that the installer has made available for execution."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:212
msgid "Its detailed specification is at :ref:`entry-points`."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:216
msgid "The direct_url.json file"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:218
msgid "This file MUST be created by installers when installing a distribution from a requirement specifying a direct URL reference (including a VCS URL)."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:224
msgid "Its detailed specification is at :ref:`direct-url`."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:228
msgid "Intentionally preventing changes to installed packages"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:230
msgid "In some cases (such as when needing to manage external dependencies in addition to Python ecosystem dependencies), it is desirable for a tool that installs packages into a Python environment to ensure that other tools are not used to uninstall or otherwise modify that installed package, as doing so may cause compatibility problems with the wider environment."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:236
msgid "To achieve this, affected tools should take the following steps:"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:238
msgid "Rename or remove the ``RECORD`` file to prevent changes via other tools (e.g. appending a suffix to create a non-standard ``RECORD.tool`` file if the tool itself needs the information, or omitting the file entirely if the package contents are tracked and managed via other means)"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:242
msgid "Write an ``INSTALLER`` file indicating the name of the tool that should be used to manage the package (this allows ``RECORD``-aware tools to provide better error notices when asked to modify affected packages)"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:246
msgid "Python runtime providers may also prevent inadvertent modification of platform provided packages by modifying the default Python package installation scheme to use a location other than that used by platform provided packages (while also ensuring both locations appear on the default Python import path)."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:251
msgid "In some circumstances, it may be desirable to block even installation of additional packages via Python-specific tools. For these cases refer to :ref:`externally-managed-environments`"
msgstr ""

#: ../source/specifications/section-distribution-formats.rst:3
msgid "Package Distribution File Formats"
msgstr ""

#: ../source/specifications/section-distribution-metadata.rst:3
msgid "Package Distribution Metadata"
msgstr ""

#: ../source/specifications/section-installation-metadata.rst:3
msgid "Package Installation Metadata"
msgstr ""

#: ../source/specifications/section-package-indices.rst:3
msgid "Package Index Interfaces"
msgstr ""

#: ../source/specifications/simple-repository-api.rst:6
msgid "Simple repository API"
msgstr ""

#: ../source/specifications/simple-repository-api.rst:8
msgid "The interface for querying available package versions and retrieving packages from an index server comes in two forms: HTML and JSON."
msgstr ""

#: ../source/specifications/simple-repository-api.rst:12
msgid "The HTML format is defined in :pep:`503`, with the addition of \"yank\" support (allowing a kind of file deletion) in :pep:`592`, specifying the interface version provided by an index server in :pep:`629`, and providing package metadata independently from a package in :pep:`658` and revised in :pep:`714`."
msgstr ""

#: ../source/specifications/simple-repository-api.rst:18
msgid "The JSON format is defined in :pep:`691`, with additional fields added in :pep:`700`, and revisions around providing package metadata independently from a package in :pep:`714`."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:6
msgid "Source distribution format"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:8
msgid "The current standard format of source distribution format is identified by the presence of a :file:`pyproject.toml` file in the distribution archive.  The layout of such a distribution was originally specified in :pep:`517` and is formally documented here."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:13
msgid "There is also the legacy source distribution format, implicitly defined by the behaviour of ``distutils`` module in the standard library, when executing :command:`setup.py sdist`. This document does not attempt to standardise this format, except to note that if a legacy source distribution contains a ``PKG-INFO`` file using metadata version 2.2 or later, then it MUST follow the rules applicable to source distributions defined in the metadata specification."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:21
msgid "Source distributions are also known as *sdists* for short."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:24
msgid "Source trees"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:26
msgid "A *source tree* is a collection of files and directories -- like a version control system checkout -- which contains a :file:`pyproject.toml` file that can be use to build a source distribution from the contained files and directories. :pep:`517` and :pep:`518` specify what is required to meet the definition of what :file:`pyproject.toml` must contain for something to be deemed a source tree."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:34
msgid "Source distribution file name"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:36
msgid "The file name of a sdist was standardised in :pep:`625`. The file name must be in the form ``{name}-{version}.tar.gz``, where ``{name}`` is normalised according to the same rules as for binary distributions (see :ref:`binary-distribution-format`), and ``{version}`` is the canonicalized form of the project version (see :ref:`version-specifiers`)."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:42
msgid "The name and version components of the filename MUST match the values stored in the metadata contained in the file."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:45
msgid "Code that produces a source distribution file MUST give the file a name that matches this specification. This includes the ``build_sdist`` hook of a :term:`build backend <Build Backend>`."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:49
msgid "Code that processes source distribution files MAY recognise source distribution files by the ``.tar.gz`` suffix and the presence of precisely *one* hyphen in the filename. Code that does this may then use the distribution name and version from the filename without further verification."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:55
msgid "Source distribution file format"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:57
msgid "A ``.tar.gz`` source distribution (sdist) contains a single top-level directory called ``{name}-{version}`` (e.g. ``foo-1.0``), containing the source files of the package. The name and version MUST match the metadata stored in the file. This directory must also contain a :file:`pyproject.toml` in the format defined in :ref:`declaring-build-dependencies`, and a ``PKG-INFO`` file containing metadata in the format described in the :ref:`core-metadata` specification. The metadata MUST conform to at least version 2.2 of the metadata specification."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:65
msgid "No other content of a sdist is required or defined. Build systems can store whatever information they need in the sdist to build the project."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:68
msgid "The tarball should use the modern POSIX.1-2001 pax tar format, which specifies UTF-8 based file names. In particular, source distribution files must be readable using the standard library tarfile module with the open flag 'r:gz'."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:76
msgid "Source distribution archive features"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:78
msgid "Because extracting tar files as-is is dangerous, and the results are platform-specific, archive features of source distributions are limited."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:82
msgid "Unpacking with the data filter"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:84
msgid "When extracting a source distribution, tools MUST either use :py:func:`tarfile.data_filter` (e.g. :py:meth:`TarFile.extractall(..., filter='data') <tarfile.TarFile.extractall>`), OR follow the *Unpacking without the data filter* section below."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:88
msgid "As an exception, on Python interpreters without :py:func:`hasattr(tarfile, 'data_filter') <tarfile.data_filter>` (:pep:`706`), tools that normally use that filter (directly on indirectly) MAY warn the user and ignore this specification. The trade-off between usability (e.g. fully trusting the archive) and security (e.g. refusing to unpack) is left up to the tool in this case."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:96
msgid "Unpacking without the data filter"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:98
msgid "Tools that do not use the ``data`` filter directly (e.g. for backwards compatibility, allowing additional features, or not using Python) MUST follow this section. (At the time of this writing, the ``data`` filter also follows this section, but it may get out of sync in the future.)"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:104
msgid "The following files are invalid in an *sdist* archive. Upon encountering such an entry, tools SHOULD notify the user, MUST NOT unpack the entry, and MAY abort with a failure:"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:108
msgid "Files that would be placed outside the destination directory."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:109
msgid "Links (symbolic or hard) pointing outside the destination directory."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:110
msgid "Device files (including pipes)."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:112
msgid "The following are also invalid. Tools MAY treat them as above, but are NOT REQUIRED to do so:"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:115
msgid "Files with a ``..`` component in the filename or link target."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:116
msgid "Links pointing to a file that is not part of the archive."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:118
msgid "Tools MAY unpack links (symbolic or hard) as regular files, using content from the archive."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:121
msgid "When extracting *sdist* archives:"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:123
msgid "Leading slashes in file names MUST be dropped. (This is nowadays standard behaviour for ``tar`` unpacking.)"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:125
msgid "For each ``mode`` (Unix permission) bit, tools MUST either:"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:127
msgid "use the platform's default for a new file/directory (respectively),"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:128
msgid "set the bit according to the archive, or"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:129
msgid "use the bit from ``rw-r--r--`` (``0o644``) for non-executable files or ``rwxr-xr-x`` (``0o755``) for executable files and directories."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:132
msgid "High ``mode`` bits (setuid, setgid, sticky) MUST be cleared."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:133
msgid "It is RECOMMENDED to preserve the user *executable* bit."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:137
msgid "Further hints"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:139
msgid "Tool authors are encouraged to consider how *hints for further verification* in ``tarfile`` documentation apply to their tool."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:146
msgid "August 2023: Standardized the source distribution archive features (:pep:`721`)"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:147
msgid "September 2022: Standardized the filename of a source distribution (:pep:`625`)"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:148
msgid "July 2021: Defined what a source tree is"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:149
msgid "November 2020: :pep:`643` converted to this specification"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:150
msgid "December 2000: Source distributions standardized in :pep:`643`"
msgstr ""

#: ../source/specifications/version-specifiers.rst:5
#: ../source/specifications/version-specifiers.rst:776
msgid "Version specifiers"
msgstr ""

#: ../source/specifications/version-specifiers.rst:8
msgid "This specification describes a scheme for identifying versions of Python software distributions, and declaring dependencies on particular versions."
msgstr ""

#: ../source/specifications/version-specifiers.rst:13
msgid "Definitions"
msgstr ""

#: ../source/specifications/version-specifiers.rst:15
msgid "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in :rfc:`2119`."
msgstr ""

#: ../source/specifications/version-specifiers.rst:19
msgid "\"Build tools\" are automated tools intended to run on development systems, producing source and binary distribution archives. Build tools may also be invoked by integration tools in order to build software distributed as sdists rather than prebuilt binary archives."
msgstr ""

#: ../source/specifications/version-specifiers.rst:24
msgid "\"Index servers\" are active distribution registries which publish version and dependency metadata and place constraints on the permitted metadata."
msgstr ""

#: ../source/specifications/version-specifiers.rst:27
msgid "\"Publication tools\" are automated tools intended to run on development systems and upload source and binary distribution archives to index servers."
msgstr ""

#: ../source/specifications/version-specifiers.rst:30
msgid "\"Installation tools\" are integration tools specifically intended to run on deployment targets, consuming source and binary distribution archives from an index server or other designated location and deploying them to the target system."
msgstr ""

#: ../source/specifications/version-specifiers.rst:35
msgid "\"Automated tools\" is a collective term covering build tools, index servers, publication tools, integration tools and any other software that produces or consumes distribution version and dependency metadata."
msgstr ""

#: ../source/specifications/version-specifiers.rst:41
msgid "Version scheme"
msgstr ""

#: ../source/specifications/version-specifiers.rst:43
msgid "Distributions are identified by a public version identifier which supports all defined version comparison operations"
msgstr ""

#: ../source/specifications/version-specifiers.rst:46
msgid "The version scheme is used both to describe the distribution version provided by a particular distribution archive, as well as to place constraints on the version of dependencies needed in order to build or run the software."
msgstr ""

#: ../source/specifications/version-specifiers.rst:55
msgid "Public version identifiers"
msgstr ""

#: ../source/specifications/version-specifiers.rst:57
msgid "The canonical public version identifiers MUST comply with the following scheme::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:62
msgid "Public version identifiers MUST NOT include leading or trailing whitespace."
msgstr ""

#: ../source/specifications/version-specifiers.rst:64
msgid "Public version identifiers MUST be unique within a given distribution."
msgstr ""

#: ../source/specifications/version-specifiers.rst:66
msgid "Installation tools SHOULD ignore any public versions which do not comply with this scheme but MUST also include the normalizations specified below. Installation tools MAY warn the user when non-compliant or ambiguous versions are detected."
msgstr ""

#: ../source/specifications/version-specifiers.rst:71
msgid "See also :ref:`version-specifiers-regex` which provides a regular expression to check strict conformance with the canonical format, as well as a more permissive regular expression accepting inputs that may require subsequent normalization."
msgstr ""

#: ../source/specifications/version-specifiers.rst:76
msgid "Public version identifiers are separated into up to five segments:"
msgstr ""

#: ../source/specifications/version-specifiers.rst:78
msgid "Epoch segment: ``N!``"
msgstr ""

#: ../source/specifications/version-specifiers.rst:79
msgid "Release segment: ``N(.N)*``"
msgstr ""

#: ../source/specifications/version-specifiers.rst:80
msgid "Pre-release segment: ``{a|b|rc}N``"
msgstr ""

#: ../source/specifications/version-specifiers.rst:81
msgid "Post-release segment: ``.postN``"
msgstr ""

#: ../source/specifications/version-specifiers.rst:82
msgid "Development release segment: ``.devN``"
msgstr ""

#: ../source/specifications/version-specifiers.rst:84
msgid "Any given release will be a \"final release\", \"pre-release\", \"post-release\" or \"developmental release\" as defined in the following sections."
msgstr ""

#: ../source/specifications/version-specifiers.rst:87
msgid "All numeric components MUST be non-negative integers represented as sequences of ASCII digits."
msgstr ""

#: ../source/specifications/version-specifiers.rst:90
msgid "All numeric components MUST be interpreted and ordered according to their numeric value, not as text strings."
msgstr ""

#: ../source/specifications/version-specifiers.rst:93
msgid "All numeric components MAY be zero. Except as described below for the release segment, a numeric component of zero has no special significance aside from always being the lowest possible value in the version ordering."
msgstr ""

#: ../source/specifications/version-specifiers.rst:99
msgid "Some hard to read version identifiers are permitted by this scheme in order to better accommodate the wide range of versioning practices across existing public and private Python projects."
msgstr ""

#: ../source/specifications/version-specifiers.rst:103
msgid "Accordingly, some of the versioning practices which are technically permitted by the specification are strongly discouraged for new projects. Where this is the case, the relevant details are noted in the following sections."
msgstr ""

#: ../source/specifications/version-specifiers.rst:112
msgid "Local version identifiers MUST comply with the following scheme::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:116
msgid "They consist of a normal public version identifier (as defined in the previous section), along with an arbitrary \"local version label\", separated from the public version identifier by a plus. Local version labels have no specific semantics assigned, but some syntactic restrictions are imposed."
msgstr ""

#: ../source/specifications/version-specifiers.rst:121
msgid "Local version identifiers are used to denote fully API (and, if applicable, ABI) compatible patched versions of upstream projects. For example, these may be created by application developers and system integrators by applying specific backported bug fixes when upgrading to a new upstream release would be too disruptive to the application or other integrated system (such as a Linux distribution)."
msgstr ""

#: ../source/specifications/version-specifiers.rst:128
msgid "The inclusion of the local version label makes it possible to differentiate upstream releases from potentially altered rebuilds by downstream integrators. The use of a local version identifier does not affect the kind of a release but, when applied to a source distribution, does indicate that it may not contain the exact same code as the corresponding upstream release."
msgstr ""

#: ../source/specifications/version-specifiers.rst:134
msgid "To ensure local version identifiers can be readily incorporated as part of filenames and URLs, and to avoid formatting inconsistencies in hexadecimal hash representations, local version labels MUST be limited to the following set of permitted characters:"
msgstr ""

#: ../source/specifications/version-specifiers.rst:139
msgid "ASCII letters (``[a-zA-Z]``)"
msgstr ""

#: ../source/specifications/version-specifiers.rst:140
msgid "ASCII digits (``[0-9]``)"
msgstr ""

#: ../source/specifications/version-specifiers.rst:141
msgid "periods (``.``)"
msgstr ""

#: ../source/specifications/version-specifiers.rst:143
msgid "Local version labels MUST start and end with an ASCII letter or digit."
msgstr ""

#: ../source/specifications/version-specifiers.rst:145
msgid "Comparison and ordering of local versions considers each segment of the local version (divided by a ``.``) separately. If a segment consists entirely of ASCII digits then that section should be considered an integer for comparison purposes and if a segment contains any ASCII letters then that segment is compared lexicographically with case insensitivity. When comparing a numeric and lexicographic segment, the numeric section always compares as greater than the lexicographic segment. Additionally a local version with a great number of segments will always compare as greater than a local version with fewer segments, as long as the shorter local version's segments match the beginning of the longer local version's segments exactly."
msgstr ""

#: ../source/specifications/version-specifiers.rst:156
msgid "An \"upstream project\" is a project that defines its own public versions. A \"downstream project\" is one which tracks and redistributes an upstream project, potentially backporting security and bug fixes from later versions of the upstream project."
msgstr ""

#: ../source/specifications/version-specifiers.rst:161
msgid "Local version identifiers SHOULD NOT be used when publishing upstream projects to a public index server, but MAY be used to identify private builds created directly from the project source. Local version identifiers SHOULD be used by downstream projects when releasing a version that is API compatible with the version of the upstream project identified by the public version identifier, but contains additional changes (such as bug fixes). As the Python Package Index is intended solely for indexing and hosting upstream projects, it MUST NOT allow the use of local version identifiers."
msgstr ""

#: ../source/specifications/version-specifiers.rst:171
msgid "Source distributions using a local version identifier SHOULD provide the ``python.integrator`` extension metadata (as defined in :pep:`459`)."
msgstr ""

#: ../source/specifications/version-specifiers.rst:176
msgid "Final releases"
msgstr ""

#: ../source/specifications/version-specifiers.rst:178
msgid "A version identifier that consists solely of a release segment and optionally an epoch identifier is termed a \"final release\"."
msgstr ""

#: ../source/specifications/version-specifiers.rst:181
msgid "The release segment consists of one or more non-negative integer values, separated by dots::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:186
msgid "Final releases within a project MUST be numbered in a consistently increasing fashion, otherwise automated tools will not be able to upgrade them correctly."
msgstr ""

#: ../source/specifications/version-specifiers.rst:190
msgid "Comparison and ordering of release segments considers the numeric value of each component of the release segment in turn. When comparing release segments with different numbers of components, the shorter segment is padded out with additional zeros as necessary."
msgstr ""

#: ../source/specifications/version-specifiers.rst:195
msgid "While any number of additional components after the first are permitted under this scheme, the most common variants are to use two components (\"major.minor\") or three components (\"major.minor.micro\")."
msgstr ""

#: ../source/specifications/version-specifiers.rst:214
msgid "A release series is any set of final release numbers that start with a common prefix. For example, ``3.3.1``, ``3.3.5`` and ``3.3.9.45`` are all part of the ``3.3`` release series."
msgstr ""

#: ../source/specifications/version-specifiers.rst:220
msgid "``X.Y`` and ``X.Y.0`` are not considered distinct release numbers, as the release segment comparison rules implicit expand the two component form to ``X.Y.0`` when comparing it to any release segment that includes three components."
msgstr ""

#: ../source/specifications/version-specifiers.rst:225
msgid "Date based release segments are also permitted. An example of a date based release scheme using the year and month of the release::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:237
msgid "Pre-releases"
msgstr ""

#: ../source/specifications/version-specifiers.rst:239
msgid "Some projects use an \"alpha, beta, release candidate\" pre-release cycle to support testing by their users prior to a final release."
msgstr ""

#: ../source/specifications/version-specifiers.rst:242
msgid "If used as part of a project's development cycle, these pre-releases are indicated by including a pre-release segment in the version identifier::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:250
msgid "A version identifier that consists solely of a release segment and a pre-release segment is termed a \"pre-release\"."
msgstr ""

#: ../source/specifications/version-specifiers.rst:253
msgid "The pre-release segment consists of an alphabetical identifier for the pre-release phase, along with a non-negative integer value. Pre-releases for a given release are ordered first by phase (alpha, beta, release candidate) and then by the numerical component within that phase."
msgstr ""

#: ../source/specifications/version-specifiers.rst:258
msgid "Installation tools MAY accept both ``c`` and ``rc`` releases for a common release segment in order to handle some existing legacy distributions."
msgstr ""

#: ../source/specifications/version-specifiers.rst:261
msgid "Installation tools SHOULD interpret ``c`` versions as being equivalent to ``rc`` versions (that is, ``c1`` indicates the same version as ``rc1``)."
msgstr ""

#: ../source/specifications/version-specifiers.rst:264
msgid "Build tools, publication tools and index servers SHOULD disallow the creation of both ``rc`` and ``c`` releases for a common release segment."
msgstr ""

#: ../source/specifications/version-specifiers.rst:269
msgid "Post-releases"
msgstr ""

#: ../source/specifications/version-specifiers.rst:271
msgid "Some projects use post-releases to address minor errors in a final release that do not affect the distributed software (for example, correcting an error in the release notes)."
msgstr ""

#: ../source/specifications/version-specifiers.rst:275
msgid "If used as part of a project's development cycle, these post-releases are indicated by including a post-release segment in the version identifier::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:280
msgid "A version identifier that includes a post-release segment without a developmental release segment is termed a \"post-release\"."
msgstr ""

#: ../source/specifications/version-specifiers.rst:283
msgid "The post-release segment consists of the string ``.post``, followed by a non-negative integer value. Post-releases are ordered by their numerical component, immediately following the corresponding release, and ahead of any subsequent release."
msgstr ""

#: ../source/specifications/version-specifiers.rst:290
msgid "The use of post-releases to publish maintenance releases containing actual bug fixes is strongly discouraged. In general, it is better to use a longer release number and increment the final component for each maintenance release."
msgstr ""

#: ../source/specifications/version-specifiers.rst:295
msgid "Post-releases are also permitted for pre-releases::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:303
msgid "Creating post-releases of pre-releases is strongly discouraged, as it makes the version identifier difficult to parse for human readers. In general, it is substantially clearer to simply create a new pre-release by incrementing the numeric component."
msgstr ""

#: ../source/specifications/version-specifiers.rst:310
msgid "Developmental releases"
msgstr ""

#: ../source/specifications/version-specifiers.rst:312
msgid "Some projects make regular developmental releases, and system packagers (especially for Linux distributions) may wish to create early releases directly from source control which do not conflict with later project releases."
msgstr ""

#: ../source/specifications/version-specifiers.rst:317
msgid "If used as part of a project's development cycle, these developmental releases are indicated by including a developmental release segment in the version identifier::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:323
msgid "A version identifier that includes a developmental release segment is termed a \"developmental release\"."
msgstr ""

#: ../source/specifications/version-specifiers.rst:326
msgid "The developmental release segment consists of the string ``.dev``, followed by a non-negative integer value. Developmental releases are ordered by their numerical component, immediately before the corresponding release (and before any pre-releases with the same release segment), and following any previous release (including any post-releases)."
msgstr ""

#: ../source/specifications/version-specifiers.rst:332
msgid "Developmental releases are also permitted for pre-releases and post-releases::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:342
msgid "While they may be useful for continuous integration purposes, publishing developmental releases of pre-releases to general purpose public index servers is strongly discouraged, as it makes the version identifier difficult to parse for human readers. If such a release needs to be published, it is substantially clearer to instead create a new pre-release by incrementing the numeric component."
msgstr ""

#: ../source/specifications/version-specifiers.rst:349
msgid "Developmental releases of post-releases are also strongly discouraged, but they may be appropriate for projects which use the post-release notation for full maintenance releases which may include code changes."
msgstr ""

#: ../source/specifications/version-specifiers.rst:355
msgid "Version epochs"
msgstr ""

#: ../source/specifications/version-specifiers.rst:357
msgid "If included in a version identifier, the epoch appears before all other components, separated from the release segment by an exclamation mark::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:362
msgid "If no explicit epoch is given, the implicit epoch is ``0``."
msgstr ""

#: ../source/specifications/version-specifiers.rst:364
msgid "Most version identifiers will not include an epoch, as an explicit epoch is only needed if a project *changes* the way it handles version numbering in a way that means the normal version ordering rules will give the wrong answer. For example, if a project is using date based versions like ``2014.04`` and would like to switch to semantic versions like ``1.0``, then the new releases would be identified as *older* than the date based releases when using the normal sorting scheme::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:378
msgid "However, by specifying an explicit epoch, the sort order can be changed appropriately, as all versions from a later epoch are sorted after versions from an earlier epoch::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:394
msgid "In order to maintain better compatibility with existing versions there are a number of \"alternative\" syntaxes that MUST be taken into account when parsing versions. These syntaxes MUST be considered when parsing a version, however they should be \"normalized\" to the standard syntax defined above."
msgstr ""

#: ../source/specifications/version-specifiers.rst:401
msgid "Case sensitivity"
msgstr ""

#: ../source/specifications/version-specifiers.rst:403
msgid "All ascii letters should be interpreted case insensitively within a version and the normal form is lowercase. This allows versions such as ``1.1RC1`` which would be normalized to ``1.1rc1``."
msgstr ""

#: ../source/specifications/version-specifiers.rst:409
msgid "Integer Normalization"
msgstr ""

#: ../source/specifications/version-specifiers.rst:411
msgid "All integers are interpreted via the ``int()`` built in and normalize to the string form of the output. This means that an integer version of ``00`` would normalize to ``0`` while ``09000`` would normalize to ``9000``. This does not hold true for integers inside of an alphanumeric segment of a local version such as ``1.0+foo0100`` which is already in its normalized form."
msgstr ""

#: ../source/specifications/version-specifiers.rst:419
msgid "Pre-release separators"
msgstr ""

#: ../source/specifications/version-specifiers.rst:421
msgid "Pre-releases should allow a ``.``, ``-``, or ``_`` separator between the release segment and the pre-release segment. The normal form for this is without a separator. This allows versions such as ``1.1.a1`` or ``1.1-a1`` which would be normalized to ``1.1a1``. It should also allow a separator to be used between the pre-release signifier and the numeral. This allows versions such as ``1.0a.1`` which would be normalized to ``1.0a1``."
msgstr ""

#: ../source/specifications/version-specifiers.rst:430
msgid "Pre-release spelling"
msgstr ""

#: ../source/specifications/version-specifiers.rst:432
msgid "Pre-releases allow the additional spellings of ``alpha``, ``beta``, ``c``, ``pre``, and ``preview`` for ``a``, ``b``, ``rc``, ``rc``, and ``rc`` respectively. This allows versions such as ``1.1alpha1``, ``1.1beta2``, or ``1.1c3`` which normalize to ``1.1a1``, ``1.1b2``, and ``1.1rc3``. In every case the additional spelling should be considered equivalent to their normal forms."
msgstr ""

#: ../source/specifications/version-specifiers.rst:441
msgid "Implicit pre-release number"
msgstr ""

#: ../source/specifications/version-specifiers.rst:443
msgid "Pre releases allow omitting the numeral in which case it is implicitly assumed to be ``0``. The normal form for this is to include the ``0`` explicitly. This allows versions such as ``1.2a`` which is normalized to ``1.2a0``."
msgstr ""

#: ../source/specifications/version-specifiers.rst:449
msgid "Post release separators"
msgstr ""

#: ../source/specifications/version-specifiers.rst:451
msgid "Post releases allow a ``.``, ``-``, or ``_`` separator as well as omitting the separator all together. The normal form of this is with the ``.`` separator. This allows versions such as ``1.2-post2`` or ``1.2post2`` which normalize to ``1.2.post2``. Like the pre-release separator this also allows an optional separator between the post release signifier and the numeral. This allows versions like ``1.2.post-2`` which would normalize to ``1.2.post2``."
msgstr ""

#: ../source/specifications/version-specifiers.rst:460
msgid "Post release spelling"
msgstr ""

#: ../source/specifications/version-specifiers.rst:462
msgid "Post-releases allow the additional spellings of ``rev`` and ``r``. This allows versions such as ``1.0-r4`` which normalizes to ``1.0.post4``. As with the pre-releases the additional spellings should be considered equivalent to their normal forms."
msgstr ""

#: ../source/specifications/version-specifiers.rst:469
msgid "Implicit post release number"
msgstr ""

#: ../source/specifications/version-specifiers.rst:471
msgid "Post releases allow omitting the numeral in which case it is implicitly assumed to be ``0``. The normal form for this is to include the ``0`` explicitly. This allows versions such as ``1.2.post`` which is normalized to ``1.2.post0``."
msgstr ""

#: ../source/specifications/version-specifiers.rst:477
msgid "Implicit post releases"
msgstr ""

#: ../source/specifications/version-specifiers.rst:479
msgid "Post releases allow omitting the ``post`` signifier all together. When using this form the separator MUST be ``-`` and no other form is allowed. This allows versions such as ``1.0-1`` to be normalized to ``1.0.post1``. This particular normalization MUST NOT be used in conjunction with the implicit post release number rule. In other words, ``1.0-`` is *not* a valid version and it does *not* normalize to ``1.0.post0``."
msgstr ""

#: ../source/specifications/version-specifiers.rst:488
msgid "Development release separators"
msgstr ""

#: ../source/specifications/version-specifiers.rst:490
msgid "Development releases allow a ``.``, ``-``, or a ``_`` separator as well as omitting the separator all together. The normal form of this is with the ``.`` separator. This allows versions such as ``1.2-dev2`` or ``1.2dev2`` which normalize to ``1.2.dev2``."
msgstr ""

#: ../source/specifications/version-specifiers.rst:497
msgid "Implicit development release number"
msgstr ""

#: ../source/specifications/version-specifiers.rst:499
msgid "Development releases allow omitting the numeral in which case it is implicitly assumed to be ``0``. The normal form for this is to include the ``0`` explicitly. This allows versions such as ``1.2.dev`` which is normalized to ``1.2.dev0``."
msgstr ""

#: ../source/specifications/version-specifiers.rst:506
msgid "Local version segments"
msgstr ""

#: ../source/specifications/version-specifiers.rst:508
msgid "With a local version, in addition to the use of ``.`` as a separator of segments, the use of ``-`` and ``_`` is also acceptable. The normal form is using the ``.`` character. This allows versions such as ``1.0+ubuntu-1`` to be normalized to ``1.0+ubuntu.1``."
msgstr ""

#: ../source/specifications/version-specifiers.rst:515
msgid "Preceding v character"
msgstr ""

#: ../source/specifications/version-specifiers.rst:517
msgid "In order to support the common version notation of ``v1.0`` versions may be preceded by a single literal ``v`` character. This character MUST be ignored for all purposes and should be omitted from all normalized forms of the version. The same version with and without the ``v`` is considered equivalent."
msgstr ""

#: ../source/specifications/version-specifiers.rst:524
msgid "Leading and Trailing Whitespace"
msgstr ""

#: ../source/specifications/version-specifiers.rst:526
msgid "Leading and trailing whitespace must be silently ignored and removed from all normalized forms of a version. This includes ``\" \"``, ``\\t``, ``\\n``, ``\\r``, ``\\f``, and ``\\v``. This allows accidental whitespace to be handled sensibly, such as a version like ``1.0\\n`` which normalizes to ``1.0``."
msgstr ""

#: ../source/specifications/version-specifiers.rst:533
msgid "Examples of compliant version schemes"
msgstr ""

#: ../source/specifications/version-specifiers.rst:535
msgid "The standard version scheme is designed to encompass a wide range of identification practices across public and private Python projects. In practice, a single project attempting to use the full flexibility offered by the scheme would create a situation where human users had difficulty figuring out the relative order of versions, even though the rules above ensure all compliant tools will order them consistently."
msgstr ""

#: ../source/specifications/version-specifiers.rst:542
msgid "The following examples illustrate a small selection of the different approaches projects may choose to identify their releases, while still ensuring that the \"latest release\" and the \"latest stable release\" can be easily determined, both by human users and automated tools."
msgstr ""

#: ../source/specifications/version-specifiers.rst:547
msgid "Simple \"major.minor\" versioning::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:556
msgid "Simple \"major.minor.micro\" versioning::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:564
msgid "\"major.minor\" versioning with alpha, beta and candidate pre-releases::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:576
msgid "\"major.minor\" versioning with developmental releases, release candidates and post-releases for minor corrections::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:591
msgid "Date based releases, using an incrementing serial within each year, skipping zero::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:605
msgid "Summary of permitted suffixes and relative ordering"
msgstr ""

#: ../source/specifications/version-specifiers.rst:609
msgid "This section is intended primarily for authors of tools that automatically process distribution metadata, rather than developers of Python distributions deciding on a versioning scheme."
msgstr ""

#: ../source/specifications/version-specifiers.rst:613
msgid "The epoch segment of version identifiers MUST be sorted according to the numeric value of the given epoch. If no epoch segment is present, the implicit numeric value is ``0``."
msgstr ""

#: ../source/specifications/version-specifiers.rst:617
msgid "The release segment of version identifiers MUST be sorted in the same order as Python's tuple sorting when the normalized release segment is parsed as follows::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:623
msgid "All release segments involved in the comparison MUST be converted to a consistent length by padding shorter segments with zeros as needed."
msgstr ""

#: ../source/specifications/version-specifiers.rst:626
msgid "Within a numeric release (``1.0``, ``2.7.3``), the following suffixes are permitted and MUST be ordered as shown::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:631
msgid "Note that ``c`` is considered to be semantically equivalent to ``rc`` and must be sorted as if it were ``rc``. Tools MAY reject the case of having the same ``N`` for both a ``c`` and a ``rc`` in the same release segment as ambiguous and remain in compliance with the specification."
msgstr ""

#: ../source/specifications/version-specifiers.rst:636
msgid "Within an alpha (``1.0a1``), beta (``1.0b1``), or release candidate (``1.0rc1``, ``1.0c1``), the following suffixes are permitted and MUST be ordered as shown::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:642
msgid "Within a post-release (``1.0.post1``), the following suffixes are permitted and MUST be ordered as shown::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:647
msgid "Note that ``devN`` and ``postN`` MUST always be preceded by a dot, even when used immediately following a numeric version (e.g. ``1.0.dev456``, ``1.0.post1``)."
msgstr ""

#: ../source/specifications/version-specifiers.rst:651
msgid "Within a pre-release, post-release or development release segment with a shared prefix, ordering MUST be by the value of the numeric component."
msgstr ""

#: ../source/specifications/version-specifiers.rst:654
msgid "The following example covers many of the possible combinations::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:679
msgid "Version ordering across different metadata versions"
msgstr ""

#: ../source/specifications/version-specifiers.rst:681
msgid "Metadata v1.0 (:pep:`241`) and metadata v1.1 (:pep:`314`) do not specify a standard version identification or ordering scheme. However metadata v1.2 (:pep:`345`) does specify a scheme which is defined in :pep:`386`."
msgstr ""

#: ../source/specifications/version-specifiers.rst:685
msgid "Due to the nature of the simple installer API it is not possible for an installer to be aware of which metadata version a particular distribution was using. Additionally installers required the ability to create a reasonably prioritized list that includes all, or as many as possible, versions of a project to determine which versions it should install. These requirements necessitate a standardization across one parsing mechanism to be used for all versions of a project."
msgstr ""

#: ../source/specifications/version-specifiers.rst:693
msgid "Due to the above, this specification MUST be used for all versions of metadata and supersedes :pep:`386` even for metadata v1.2. Tools SHOULD ignore any versions which cannot be parsed by the rules in this specification, but MAY fall back to implementation defined version parsing and ordering schemes if no versions complying with this specification are available."
msgstr ""

#: ../source/specifications/version-specifiers.rst:699
msgid "Distribution users may wish to explicitly remove non-compliant versions from any private package indexes they control."
msgstr ""

#: ../source/specifications/version-specifiers.rst:704
msgid "Compatibility with other version schemes"
msgstr ""

#: ../source/specifications/version-specifiers.rst:706
msgid "Some projects may choose to use a version scheme which requires translation in order to comply with the public version scheme defined in this specification. In such cases, the project specific version can be stored in the metadata while the translated public version is published in the version field."
msgstr ""

#: ../source/specifications/version-specifiers.rst:711
msgid "This allows automated distribution tools to provide consistently correct ordering of published releases, while still allowing developers to use the internal versioning scheme they prefer for their projects."
msgstr ""

#: ../source/specifications/version-specifiers.rst:717
msgid "Semantic versioning"
msgstr ""

#: ../source/specifications/version-specifiers.rst:719
msgid "`Semantic versioning`_ is a popular version identification scheme that is more prescriptive than this specification regarding the significance of different elements of a release number. Even if a project chooses not to abide by the details of semantic versioning, the scheme is worth understanding as it covers many of the issues that can arise when depending on other distributions, and when publishing a distribution that others rely on."
msgstr ""

#: ../source/specifications/version-specifiers.rst:726
msgid "The \"Major.Minor.Patch\" (described in this specification as \"major.minor.micro\") aspects of semantic versioning (clauses 1-8 in the 2.0.0 specification) are fully compatible with the version scheme defined in this specification, and abiding by these aspects is encouraged."
msgstr ""

#: ../source/specifications/version-specifiers.rst:731
msgid "Semantic versions containing a hyphen (pre-releases - clause 10) or a plus sign (builds - clause 11) are *not* compatible with this specification and are not permitted in the public version field."
msgstr ""

#: ../source/specifications/version-specifiers.rst:735
msgid "One possible mechanism to translate such semantic versioning based source labels to compatible public versions is to use the ``.devN`` suffix to specify the appropriate version order."
msgstr ""

#: ../source/specifications/version-specifiers.rst:739
msgid "Specific build information may also be included in local version labels."
msgstr ""

#: ../source/specifications/version-specifiers.rst:745
msgid "DVCS based version labels"
msgstr ""

#: ../source/specifications/version-specifiers.rst:747
msgid "Many build tools integrate with distributed version control systems like Git and Mercurial in order to add an identifying hash to the version identifier. As hashes cannot be ordered reliably such versions are not permitted in the public version field."
msgstr ""

#: ../source/specifications/version-specifiers.rst:752
msgid "As with semantic versioning, the public ``.devN`` suffix may be used to uniquely identify such releases for publication, while the original DVCS based label can be stored in the project metadata."
msgstr ""

#: ../source/specifications/version-specifiers.rst:756
msgid "Identifying hash information may also be included in local version labels."
msgstr ""

#: ../source/specifications/version-specifiers.rst:760
msgid "Olson database versioning"
msgstr ""

#: ../source/specifications/version-specifiers.rst:762
msgid "The ``pytz`` project inherits its versioning scheme from the corresponding Olson timezone database versioning scheme: the year followed by a lowercase character indicating the version of the database within that year."
msgstr ""

#: ../source/specifications/version-specifiers.rst:766
msgid "This can be translated to a compliant public version identifier as ``<year>.<serial>``, where the serial starts at zero or one (for the '<year>a' release) and is incremented with each subsequent database update within the year."
msgstr ""

#: ../source/specifications/version-specifiers.rst:771
msgid "As with other translated version identifiers, the corresponding Olson database version could be recorded in the project metadata."
msgstr ""

#: ../source/specifications/version-specifiers.rst:778
msgid "A version specifier consists of a series of version clauses, separated by commas. For example::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:783
msgid "The comparison operator determines the kind of version clause:"
msgstr ""

#: ../source/specifications/version-specifiers.rst:785
msgid "``~=``: `Compatible release`_ clause"
msgstr ""

#: ../source/specifications/version-specifiers.rst:786
msgid "``==``: `Version matching`_ clause"
msgstr ""

#: ../source/specifications/version-specifiers.rst:787
msgid "``!=``: `Version exclusion`_ clause"
msgstr ""

#: ../source/specifications/version-specifiers.rst:788
msgid "``<=``, ``>=``: `Inclusive ordered comparison`_ clause"
msgstr ""

#: ../source/specifications/version-specifiers.rst:789
msgid "``<``, ``>``: `Exclusive ordered comparison`_ clause"
msgstr ""

#: ../source/specifications/version-specifiers.rst:790
msgid "``===``: `Arbitrary equality`_ clause."
msgstr ""

#: ../source/specifications/version-specifiers.rst:792
msgid "The comma (\",\") is equivalent to a logical **and** operator: a candidate version must match all given version clauses in order to match the specifier as a whole."
msgstr ""

#: ../source/specifications/version-specifiers.rst:796
msgid "Whitespace between a conditional operator and the following version identifier is optional, as is the whitespace around the commas."
msgstr ""

#: ../source/specifications/version-specifiers.rst:799
msgid "When multiple candidate versions match a version specifier, the preferred version SHOULD be the latest version as determined by the consistent ordering defined by the standard `Version scheme`_. Whether or not pre-releases are considered as candidate versions SHOULD be handled as described in `Handling of pre-releases`_."
msgstr ""

#: ../source/specifications/version-specifiers.rst:805
msgid "Except where specifically noted below, local version identifiers MUST NOT be permitted in version specifiers, and local version labels MUST be ignored entirely when checking if candidate versions match a given version specifier."
msgstr ""

#: ../source/specifications/version-specifiers.rst:814
msgid "Compatible release"
msgstr ""

#: ../source/specifications/version-specifiers.rst:816
msgid "A compatible release clause consists of the compatible release operator ``~=`` and a version identifier. It matches any candidate version that is expected to be compatible with the specified version."
msgstr ""

#: ../source/specifications/version-specifiers.rst:820
msgid "The specified version identifier must be in the standard format described in `Version scheme`_. Local version identifiers are NOT permitted in this version specifier."
msgstr ""

#: ../source/specifications/version-specifiers.rst:824
msgid "For a given release identifier ``V.N``, the compatible release clause is approximately equivalent to the pair of comparison clauses::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:829
msgid "This operator MUST NOT be used with a single segment version number such as ``~=1``."
msgstr ""

#: ../source/specifications/version-specifiers.rst:832
msgid "For example, the following groups of version clauses are equivalent::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:840
msgid "If a pre-release, post-release or developmental release is named in a compatible release clause as ``V.N.suffix``, then the suffix is ignored when determining the required prefix match::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:850
msgid "The padding rules for release segment comparisons means that the assumed degree of forward compatibility in a compatible release clause can be controlled by appending additional zeros to the version specifier::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:862
msgid "Version matching"
msgstr ""

#: ../source/specifications/version-specifiers.rst:864
msgid "A version matching clause includes the version matching operator ``==`` and a version identifier."
msgstr ""

#: ../source/specifications/version-specifiers.rst:867
msgid "The specified version identifier must be in the standard format described in `Version scheme`_, but a trailing ``.*`` is permitted on public version identifiers as described below."
msgstr ""

#: ../source/specifications/version-specifiers.rst:871
msgid "By default, the version matching operator is based on a strict equality comparison: the specified version must be exactly the same as the requested version. The *only* substitution performed is the zero padding of the release segment to ensure the release segments are compared with the same length."
msgstr ""

#: ../source/specifications/version-specifiers.rst:877
msgid "Whether or not strict version matching is appropriate depends on the specific use case for the version specifier. Automated tools SHOULD at least issue warnings and MAY reject them entirely when strict version matches are used inappropriately."
msgstr ""

#: ../source/specifications/version-specifiers.rst:882
msgid "Prefix matching may be requested instead of strict comparison, by appending a trailing ``.*`` to the version identifier in the version matching clause. This means that additional trailing segments will be ignored when determining whether or not a version identifier matches the clause. If the specified version includes only a release segment, than trailing components (or the lack thereof) in the release segment are also ignored."
msgstr ""

#: ../source/specifications/version-specifiers.rst:889
#: ../source/specifications/version-specifiers.rst:950
msgid "For example, given the version ``1.1.post1``, the following clauses would match or not as shown::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:896
msgid "For purposes of prefix matching, the pre-release segment is considered to have an implied preceding ``.``, so given the version ``1.1a1``, the following clauses would match or not as shown::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:904
msgid "An exact match is also considered a prefix match (this interpretation is implied by the usual zero padding rules for the release segment of version identifiers). Given the version ``1.1``, the following clauses would match or not as shown::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:916
msgid "It is invalid to have a prefix match containing a development or local release such as ``1.0.dev1.*`` or ``1.0+foo1.*``. If present, the development release segment is always the final segment in the public version, and the local version is ignored for comparison purposes, so using either in a prefix match wouldn't make any sense."
msgstr ""

#: ../source/specifications/version-specifiers.rst:922
msgid "The use of ``==`` (without at least the wildcard suffix) when defining dependencies for published distributions is strongly discouraged as it greatly complicates the deployment of security fixes. The strict version comparison operator is intended primarily for use when defining dependencies for repeatable *deployments of applications* while using a shared distribution index."
msgstr ""

#: ../source/specifications/version-specifiers.rst:929
msgid "If the specified version identifier is a public version identifier (no local version label), then the local version label of any candidate versions MUST be ignored when matching versions."
msgstr ""

#: ../source/specifications/version-specifiers.rst:933
msgid "If the specified version identifier is a local version identifier, then the local version labels of candidate versions MUST be considered when matching versions, with the public version identifier being matched as described above, and the local version label being checked for equivalence using a strict string equality comparison."
msgstr ""

#: ../source/specifications/version-specifiers.rst:941
msgid "Version exclusion"
msgstr ""

#: ../source/specifications/version-specifiers.rst:943
msgid "A version exclusion clause includes the version exclusion operator ``!=`` and a version identifier."
msgstr ""

#: ../source/specifications/version-specifiers.rst:946
msgid "The allowed version identifiers and comparison semantics are the same as those of the `Version matching`_ operator, except that the sense of any match is inverted."
msgstr ""

#: ../source/specifications/version-specifiers.rst:959
msgid "Inclusive ordered comparison"
msgstr ""

#: ../source/specifications/version-specifiers.rst:961
msgid "An inclusive ordered comparison clause includes a comparison operator and a version identifier, and will match any version where the comparison is correct based on the relative position of the candidate version and the specified version given the consistent ordering defined by the standard `Version scheme`_."
msgstr ""

#: ../source/specifications/version-specifiers.rst:967
msgid "The inclusive ordered comparison operators are ``<=`` and ``>=``."
msgstr ""

#: ../source/specifications/version-specifiers.rst:969
#: ../source/specifications/version-specifiers.rst:999
msgid "As with version matching, the release segment is zero padded as necessary to ensure the release segments are compared with the same length."
msgstr ""

#: ../source/specifications/version-specifiers.rst:972
#: ../source/specifications/version-specifiers.rst:1002
msgid "Local version identifiers are NOT permitted in this version specifier."
msgstr ""

#: ../source/specifications/version-specifiers.rst:976
msgid "Exclusive ordered comparison"
msgstr ""

#: ../source/specifications/version-specifiers.rst:978
msgid "The exclusive ordered comparisons ``>`` and ``<`` are similar to the inclusive ordered comparisons in that they rely on the relative position of the candidate version and the specified version given the consistent ordering defined by the standard `Version scheme`_. However, they specifically exclude pre-releases, post-releases, and local versions of the specified version."
msgstr ""

#: ../source/specifications/version-specifiers.rst:984
msgid "The exclusive ordered comparison ``>V`` **MUST NOT** allow a post-release of the given version unless ``V`` itself is a post release. You may mandate that releases are later than a particular post release, including additional post releases, by using ``>V.postN``. For example, ``>1.7`` will allow ``1.7.1`` but not ``1.7.0.post1`` and ``>1.7.post2`` will allow ``1.7.1`` and ``1.7.0.post3`` but not ``1.7.0``."
msgstr ""

#: ../source/specifications/version-specifiers.rst:991
msgid "The exclusive ordered comparison ``>V`` **MUST NOT** match a local version of the specified version."
msgstr ""

#: ../source/specifications/version-specifiers.rst:994
msgid "The exclusive ordered comparison ``<V`` **MUST NOT** allow a pre-release of the specified version unless the specified version is itself a pre-release. Allowing pre-releases that are earlier than, but not equal to a specific pre-release may be accomplished by using ``<V.rc1`` or similar."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1006
msgid "Arbitrary equality"
msgstr ""

#: ../source/specifications/version-specifiers.rst:1008
msgid "Arbitrary equality comparisons are simple string equality operations which do not take into account any of the semantic information such as zero padding or local versions. This operator also does not support prefix matching as the ``==`` operator does."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1013
msgid "The primary use case for arbitrary equality is to allow for specifying a version which cannot otherwise be represented by this specification. This operator is special and acts as an escape hatch to allow someone using a tool which implements this specification to still install a legacy version which is otherwise incompatible with this specification."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1019
msgid "An example would be ``===foobar`` which would match a version of ``foobar``."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1021
msgid "This operator may also be used to explicitly require an unpatched version of a project such as ``===1.0`` which would not match for a version ``1.0+downstream1``."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1025
msgid "Use of this operator is heavily discouraged and tooling MAY display a warning when it is used."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1030
msgid "Handling of pre-releases"
msgstr ""

#: ../source/specifications/version-specifiers.rst:1032
msgid "Pre-releases of any kind, including developmental releases, are implicitly excluded from all version specifiers, *unless* they are already present on the system, explicitly requested by the user, or if the only available version that satisfies the version specifier is a pre-release."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1037
msgid "By default, dependency resolution tools SHOULD:"
msgstr ""

#: ../source/specifications/version-specifiers.rst:1039
msgid "accept already installed pre-releases for all version specifiers"
msgstr ""

#: ../source/specifications/version-specifiers.rst:1040
msgid "accept remotely available pre-releases for version specifiers where there is no final or post release that satisfies the version specifier"
msgstr ""

#: ../source/specifications/version-specifiers.rst:1042
msgid "exclude all other pre-releases from consideration"
msgstr ""

#: ../source/specifications/version-specifiers.rst:1044
msgid "Dependency resolution tools MAY issue a warning if a pre-release is needed to satisfy a version specifier."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1047
msgid "Dependency resolution tools SHOULD also allow users to request the following alternative behaviours:"
msgstr ""

#: ../source/specifications/version-specifiers.rst:1050
msgid "accepting pre-releases for all version specifiers"
msgstr ""

#: ../source/specifications/version-specifiers.rst:1051
msgid "excluding pre-releases for all version specifiers (reporting an error or warning if a pre-release is already installed locally, or if a pre-release is the only way to satisfy a particular specifier)"
msgstr ""

#: ../source/specifications/version-specifiers.rst:1055
msgid "Dependency resolution tools MAY also allow the above behaviour to be controlled on a per-distribution basis."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1058
msgid "Post-releases and final releases receive no special treatment in version specifiers - they are always included unless explicitly excluded."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1065
msgid "``~=3.1``: version 3.1 or later, but not version 4.0 or later."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1066
msgid "``~=3.1.2``: version 3.1.2 or later, but not version 3.2.0 or later."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1067
msgid "``~=3.1a1``: version 3.1a1 or later, but not version 4.0 or later."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1068
msgid "``== 3.1``: specifically version 3.1 (or 3.1.0), excludes all pre-releases, post releases, developmental releases and any 3.1.x maintenance releases."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1070
msgid "``== 3.1.*``: any version that starts with 3.1. Equivalent to the ``~=3.1.0`` compatible release clause."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1072
msgid "``~=3.1.0, != 3.1.3``: version 3.1.0 or later, but not version 3.1.3 and not version 3.2.0 or later."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1077
msgid "Direct references"
msgstr ""

#: ../source/specifications/version-specifiers.rst:1079
msgid "Some automated tools may permit the use of a direct reference as an alternative to a normal version specifier. A direct reference consists of the specifier ``@`` and an explicit URL."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1083
msgid "Whether or not direct references are appropriate depends on the specific use case for the version specifier. Automated tools SHOULD at least issue warnings and MAY reject them entirely when direct references are used inappropriately."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1088
msgid "Public index servers SHOULD NOT allow the use of direct references in uploaded distributions. Direct references are intended as a tool for software integrators rather than publishers."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1092
msgid "Depending on the use case, some appropriate targets for a direct URL reference may be an sdist or a wheel binary archive. The exact URLs and targets supported will be tool dependent."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1096
msgid "For example, a local source archive may be referenced directly::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:1100
msgid "Alternatively, a prebuilt archive may also be referenced::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:1104
msgid "All direct references that do not refer to a local file URL SHOULD specify a secure transport mechanism (such as ``https``) AND include an expected hash value in the URL for verification purposes. If a direct reference is specified without any hash information, with hash information that the tool doesn't understand, or with a selected hash algorithm that the tool considers too weak to trust, automated tools SHOULD at least emit a warning and MAY refuse to rely on the URL. If such a direct reference also uses an insecure transport, automated tools SHOULD NOT rely on the URL."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1113
msgid "It is RECOMMENDED that only hashes which are unconditionally provided by the latest version of the standard library's ``hashlib`` module be used for source archive hashes. At time of writing, that list consists of ``'md5'``, ``'sha1'``, ``'sha224'``, ``'sha256'``, ``'sha384'``, and ``'sha512'``."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1119
msgid "For source archive and wheel references, an expected hash value may be specified by including a ``<hash-algorithm>=<expected-hash>`` entry as part of the URL fragment."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1123
msgid "For version control references, the ``VCS+protocol`` scheme SHOULD be used to identify both the version control system and the secure transport, and a version control system with hash based commit identifiers SHOULD be used. Automated tools MAY omit warnings about missing hashes for version control systems that do not provide hash based commit identifiers."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1129
msgid "To handle version control systems that do not support including commit or tag references directly in the URL, that information may be appended to the end of the URL using the ``@<commit-hash>`` or the ``@<tag>#<commit-hash>`` notation."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1136
msgid "This isn't *quite* the same as the existing VCS reference notation supported by pip. Firstly, the distribution name is moved in front rather than embedded as part of the URL. Secondly, the commit hash is included even when retrieving based on a tag, in order to meet the requirement above that *every* link should include a hash to make things harder to forge (creating a malicious repo with a particular tag is easy, creating one with a specific *hash*, less so)."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1144
msgid "Remote URL examples::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:1152
msgid "File URLs"
msgstr ""

#: ../source/specifications/version-specifiers.rst:1154
msgid "File URLs take the form of ``file://<host>/<path>``. If the ``<host>`` is omitted it is assumed to be ``localhost`` and even if the ``<host>`` is omitted the third slash MUST still exist. The ``<path>`` defines what the file path on the filesystem that is to be accessed."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1159
msgid "On the various \\*nix operating systems the only allowed values for ``<host>`` is for it to be omitted, ``localhost``, or another FQDN that the current machine believes matches its own host. In other words, on \\*nix the ``file://`` scheme can only be used to access paths on the local machine."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1164
msgid "On Windows the file format should include the drive letter if applicable as part of the ``<path>`` (e.g. ``file:///c:/path/to/a/file``). Unlike \\*nix on Windows the ``<host>`` parameter may be used to specify a file residing on a network share. In other words, in order to translate ``\\\\machine\\volume\\file`` to a ``file://`` url, it would end up as ``file://machine/volume/file``. For more information on ``file://`` URLs on Windows see `MSDN <https://web.archive.org/web/20130321051043/http://blogs.msdn.com/b/ie/archive/2006/12/06/file-uris-in-windows.aspx>`_."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1175
msgid "Summary of differences from pkg_resources.parse_version"
msgstr ""

#: ../source/specifications/version-specifiers.rst:1177
msgid "Note: this comparison is to ``pkg_resourses.parse_version`` as it existed at the time :pep:`440` was written. After the PEP was accepted, setuptools 6.0 and later versions adopted the behaviour described here."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1181
msgid "Local versions sort differently, this specification requires that they sort as greater than the same version without a local version, whereas ``pkg_resources.parse_version`` considers it a pre-release marker."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1185
msgid "This specification purposely restricts the syntax which constitutes a valid version while ``pkg_resources.parse_version`` attempts to provide some meaning from *any* arbitrary string."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1189
msgid "``pkg_resources.parse_version`` allows arbitrarily deeply nested version signifiers like ``1.0.dev1.post1.dev5``. This specification however allows only a single use of each type and they must exist in a certain order."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1198
msgid "Appendix: Parsing version strings with regular expressions"
msgstr ""

#: ../source/specifications/version-specifiers.rst:1200
msgid "As noted earlier in the :ref:`public-version-identifiers` section, published version identifiers SHOULD use the canonical format. This section provides regular expressions that can be used to test whether a version is already in that form, and if it's not, extract the various components for subsequent normalization."
msgstr ""

#: ../source/specifications/version-specifiers.rst:1206
msgid "To test whether a version identifier is in the canonical format, you can use the following function::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:1213
msgid "To extract the components of a version identifier, use the following regular expression (as defined by the `packaging <https://github.com/pypa/packaging>`_ project)::"
msgstr ""

#: ../source/specifications/version-specifiers.rst:1258
msgid "This specification was originally approved as :pep:`440`, addressing several limitations of the previous attempt at standardized versioning, as described in :pep:`345` and :pep:`386`."
msgstr ""

#: ../source/specifications/virtual-environments.rst:6
msgid "Python Virtual Environments"
msgstr ""

#: ../source/specifications/virtual-environments.rst:8
msgid "For Python 3.3 and later versions, :pep:`405` introduced interpreter level support for the concept of \"Python Virtual Environments\". Each virtual environment has its own Python binary (allowing creation of environments with various Python versions) and can have its own independent set of installed Python packages in its site directories, but shares the standard library with the base installed Python. While the concept of virtual environments existed prior to this update, there was no previously standardised mechanism for declaring or discovering them."
msgstr ""

#: ../source/specifications/virtual-environments.rst:18
msgid "Runtime detection of virtual environments"
msgstr ""

#: ../source/specifications/virtual-environments.rst:20
msgid "At runtime, virtual environments can be identified by virtue of ``sys.prefix`` (the filesystem location of the running interpreter) having a different value from ``sys.base_prefix`` (the default filesystem location of the standard library directories)."
msgstr ""

#: ../source/specifications/virtual-environments.rst:25
msgid ":ref:`venv-explanation` in the Python standard library documentation for the :py:mod:`venv` module covers this along with the concept of \"activating\" a virtual environment in an interactive operating system shell (this activation step is optional and hence the changes it makes can't be reliably used to detect whether a Python program is running in a virtual environment or not)."
msgstr ""

#: ../source/specifications/virtual-environments.rst:33
msgid "Declaring installation environments as Python virtual environments"
msgstr ""

#: ../source/specifications/virtual-environments.rst:35
msgid "As described in :pep:`405`, a Python virtual environment in its simplest form consists of nothing more than a copy or symlink of the Python binary accompanied by a ``site-packages`` directory and a ``pyvenv.cfg`` file with a ``home`` key that indicates where to find the Python standard library modules."
msgstr ""

#: ../source/specifications/virtual-environments.rst:40
msgid "While designed to meet the needs of the standard :py:mod:`venv` module, this split installation and ``pyvenv.cfg`` file approach can be used by *any* Python installation provider that desires Python-specific tools to be aware that they are already operating in a virtual environment and no further environment nesting is required or desired."
msgstr ""

#: ../source/specifications/virtual-environments.rst:46
msgid "Even in the absence of a ``pyvenv.cfg`` file, any approach (e.g. ``sitecustomize.py``, patching the installed Python runtime) that results in ``sys.prefix`` and ``sys.base_prefix`` having different values, while still providing a matching default package installation scheme in ``sysconfig``, will be detected and behave as a Python virtual environment."
msgstr ""

#: ../source/support.rst:3
msgid "How to Get Support"
msgstr ""

#: ../source/support.rst:5
msgid "For support related to a specific project, see the links on the :doc:`Projects <key_projects>` page."
msgstr ""

#: ../source/support.rst:8
msgid "For something more general, or when you're just not sure, please `open an issue <https://github.com/pypa/packaging-problems/issues/new?template=general_issue.yml>`_ on the `packaging-problems <https://github.com/pypa/packaging-problems>`_ repository on GitHub."
msgstr ""

#: ../source/tutorials/creating-documentation.rst:4
msgid "Creating documentation"
msgstr ""

#: ../source/tutorials/creating-documentation.rst:6
msgid "This tutorial has been removed since it is not related to packaging and was unmaintained. Please see the `Sphinx tutorial <https://www.sphinx-doc.org/en/master/tutorial>`_ instead."
msgstr ""

#: ../source/tutorials/index.rst:4
msgid "**Tutorials** are opinionated step-by-step guides to help you get familiar with packaging concepts. For more detailed information on specific packaging topics, see :doc:`/guides/index`."
msgstr ""

#: ../source/tutorials/installing-packages.rst:5
msgid "Installing Packages"
msgstr ""

#: ../source/tutorials/installing-packages.rst:7
msgid "This section covers the basics of how to install Python :term:`packages <Distribution Package>`."
msgstr ""

#: ../source/tutorials/installing-packages.rst:10
msgid "It's important to note that the term \"package\" in this context is being used to describe a bundle of software to be installed (i.e. as a synonym for a :term:`distribution <Distribution Package>`). It does not refer to the kind of :term:`package <Import Package>` that you import in your Python source code (i.e. a container of modules). It is common in the Python community to refer to a :term:`distribution <Distribution Package>` using the term \"package\".  Using the term \"distribution\" is often not preferred, because it can easily be confused with a Linux distribution, or another larger software distribution like Python itself."
msgstr ""

#: ../source/tutorials/installing-packages.rst:24
msgid "Requirements for Installing Packages"
msgstr ""

#: ../source/tutorials/installing-packages.rst:26
msgid "This section describes the steps to follow before installing other Python packages."
msgstr ""

#: ../source/tutorials/installing-packages.rst:31
msgid "Ensure you can run Python from the command line"
msgstr ""

#: ../source/tutorials/installing-packages.rst:33
msgid "Before you go any further, make sure you have Python and that the expected version is available from your command line. You can check this by running:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:49
msgid "You should get some output like ``Python 3.6.3``. If you do not have Python, please install the latest 3.x version from `python.org`_ or refer to the :ref:`Installing Python <python-guide:installation>` section of the Hitchhiker's Guide to Python."
msgstr ""

#: ../source/tutorials/installing-packages.rst:53
msgid "If you're a newcomer and you get an error like this:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:62
msgid "It's because this command and other suggested commands in this tutorial are intended to be run in a *shell* (also called a *terminal* or *console*). See the Python for Beginners `getting started tutorial`_ for an introduction to using your operating system's shell and interacting with Python."
msgstr ""

#: ../source/tutorials/installing-packages.rst:68
msgid "If you're using an enhanced shell like IPython or the Jupyter notebook, you can run system commands like those in this tutorial by prefacing them with a ``!`` character:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:78
msgid "It's recommended to write ``{sys.executable}`` rather than plain ``python`` in order to ensure that commands are run in the Python installation matching the currently running notebook (which may not be the same Python installation that the ``python`` command refers to)."
msgstr ""

#: ../source/tutorials/installing-packages.rst:83
msgid "Due to the way most Linux distributions are handling the Python 3 migration, Linux users using the system Python without creating a virtual environment first should replace the ``python`` command in this tutorial with ``python3`` and the ``python -m pip`` command with ``python3 -m pip --user``. Do *not* run any of the commands in this tutorial with ``sudo``: if you get a permissions error, come back to the section on creating virtual environments, set one up, and then continue with the tutorial as written."
msgstr ""

#: ../source/tutorials/installing-packages.rst:95
msgid "Ensure you can run pip from the command line"
msgstr ""

#: ../source/tutorials/installing-packages.rst:97
msgid "Additionally, you'll need to make sure you have :ref:`pip` available. You can check this by running:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:112
msgid "If you installed Python from source, with an installer from `python.org`_, or via `Homebrew`_ you should already have pip. If you're on Linux and installed using your OS package manager, you may have to install pip separately, see :doc:`/guides/installing-using-linux-tools`."
msgstr ""

#: ../source/tutorials/installing-packages.rst:119
msgid "If ``pip`` isn't already installed, then first try to bootstrap it from the standard library:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:134
msgid "If that still doesn't allow you to run ``python -m pip``:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:136
msgid "Securely Download `get-pip.py <https://bootstrap.pypa.io/get-pip.py>`_ [1]_"
msgstr ""

#: ../source/tutorials/installing-packages.rst:139
msgid "Run ``python get-pip.py``. [2]_  This will install or upgrade pip. Additionally, it will install :ref:`setuptools` and :ref:`wheel` if they're not installed already."
msgstr ""

#: ../source/tutorials/installing-packages.rst:145
msgid "Be cautious if you're using a Python install that's managed by your operating system or another package manager. get-pip.py does not coordinate with those tools, and may leave your system in an inconsistent state. You can use ``python get-pip.py --prefix=/usr/local/`` to install in ``/usr/local`` which is designed for locally-installed software."
msgstr ""

#: ../source/tutorials/installing-packages.rst:154
msgid "Ensure pip, setuptools, and wheel are up to date"
msgstr ""

#: ../source/tutorials/installing-packages.rst:156
msgid "While ``pip`` alone is sufficient to install from pre-built binary archives, up to date copies of the ``setuptools`` and ``wheel`` projects are useful to ensure you can also install from source archives:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:173
msgid "Optionally, create a virtual environment"
msgstr ""

#: ../source/tutorials/installing-packages.rst:175
msgid "See :ref:`section below <Creating and using Virtual Environments>` for details, but here's the basic :doc:`venv <python:library/venv>` [3]_ command to use on a typical Linux system:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:192
msgid "This will create a new virtual environment in the ``tutorial_env`` subdirectory, and configure the current shell to use it as the default ``python`` environment."
msgstr ""

#: ../source/tutorials/installing-packages.rst:199
msgid "Creating Virtual Environments"
msgstr ""

#: ../source/tutorials/installing-packages.rst:201
msgid "Python \"Virtual Environments\" allow Python :term:`packages <Distribution Package>` to be installed in an isolated location for a particular application, rather than being installed globally. If you are looking to safely install global command line tools, see :doc:`/guides/installing-stand-alone-command-line-tools`."
msgstr ""

#: ../source/tutorials/installing-packages.rst:207
msgid "Imagine you have an application that needs version 1 of LibFoo, but another application requires version 2. How can you use both these applications? If you install everything into /usr/lib/python3.6/site-packages (or whatever your platform’s standard location is), it’s easy to end up in a situation where you unintentionally upgrade an application that shouldn’t be upgraded."
msgstr ""

#: ../source/tutorials/installing-packages.rst:213
msgid "Or more generally, what if you want to install an application and leave it be? If an application works, any change in its libraries or the versions of those libraries can break the application."
msgstr ""

#: ../source/tutorials/installing-packages.rst:217
msgid "Also, what if you can’t install :term:`packages <Distribution Package>` into the global site-packages directory? For instance, on a shared host."
msgstr ""

#: ../source/tutorials/installing-packages.rst:220
msgid "In all these cases, virtual environments can help you. They have their own installation directories and they don’t share libraries with other virtual environments."
msgstr ""

#: ../source/tutorials/installing-packages.rst:224
msgid "Currently, there are two common tools for creating Python virtual environments:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:226
msgid ":doc:`venv <python:library/venv>` is available by default in Python 3.3 and later, and installs :ref:`pip` and :ref:`setuptools` into created virtual environments in Python 3.4 and later."
msgstr ""

#: ../source/tutorials/installing-packages.rst:229
msgid ":ref:`virtualenv` needs to be installed separately, but supports Python 2.7+ and Python 3.3+, and :ref:`pip`, :ref:`setuptools` and :ref:`wheel` are always installed into created virtual environments by default (regardless of Python version)."
msgstr ""

#: ../source/tutorials/installing-packages.rst:234
msgid "The basic usage is like so:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:236
msgid "Using :doc:`venv <python:library/venv>`:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:252
msgid "Using :ref:`virtualenv`:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:268
msgid "For more information, see the :doc:`venv <python:library/venv>` docs or the :doc:`virtualenv <virtualenv:index>` docs."
msgstr ""

#: ../source/tutorials/installing-packages.rst:271
msgid "The use of :command:`source` under Unix shells ensures that the virtual environment's variables are set within the current shell, and not in a subprocess (which then disappears, having no useful effect)."
msgstr ""

#: ../source/tutorials/installing-packages.rst:276
msgid "In both of the above cases, Windows users should *not* use the :command:`source` command, but should rather run the :command:`activate` script directly from the command shell like so:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:286
msgid "Managing multiple virtual environments directly can become tedious, so the :ref:`dependency management tutorial <managing-dependencies>` introduces a higher level tool, :ref:`Pipenv`, that automatically manages a separate virtual environment for each project and application that you work on."
msgstr ""

#: ../source/tutorials/installing-packages.rst:293
msgid "Use pip for Installing"
msgstr ""

#: ../source/tutorials/installing-packages.rst:295
msgid ":ref:`pip` is the recommended installer.  Below, we'll cover the most common usage scenarios. For more detail, see the :doc:`pip docs <pip:index>`, which includes a complete :doc:`Reference Guide <pip:cli/index>`."
msgstr ""

#: ../source/tutorials/installing-packages.rst:301
msgid "Installing from PyPI"
msgstr ""

#: ../source/tutorials/installing-packages.rst:303
msgid "The most common usage of :ref:`pip` is to install from the :term:`Python Package Index <Python Package Index (PyPI)>` using a :term:`requirement specifier <Requirement Specifier>`. Generally speaking, a requirement specifier is composed of a project name followed by an optional :term:`version specifier <Version Specifier>`.  A full description of the supported specifiers can be found in the :ref:`Version specifier specification <version-specifiers>`. Below are some examples."
msgstr ""

#: ../source/tutorials/installing-packages.rst:311
msgid "To install the latest version of \"SomeProject\":"
msgstr ""

#: ../source/tutorials/installing-packages.rst:325
msgid "To install a specific version:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:339
msgid "To install greater than or equal to one version and less than another:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:354
msgid "To install a version that's :ref:`compatible <version-specifiers-compatible-release>` with a certain version: [4]_"
msgstr ""

#: ../source/tutorials/installing-packages.rst:369
msgid "In this case, this means to install any version \"==1.4.*\" version that's also \">=1.4.2\"."
msgstr ""

#: ../source/tutorials/installing-packages.rst:374
msgid "Source Distributions vs Wheels"
msgstr ""

#: ../source/tutorials/installing-packages.rst:376
msgid ":ref:`pip` can install from either :term:`Source Distributions (sdist) <Source Distribution (or \"sdist\")>` or :term:`Wheels <Wheel>`, but if both are present on PyPI, pip will prefer a compatible :term:`wheel <Wheel>`. You can override pip`s default behavior by e.g. using its :ref:`--no-binary <pip:install_--no-binary>` option."
msgstr ""

#: ../source/tutorials/installing-packages.rst:382
msgid ":term:`Wheels <Wheel>` are a pre-built :term:`distribution <Distribution Package>` format that provides faster installation compared to :term:`Source Distributions (sdist) <Source Distribution (or \"sdist\")>`, especially when a project contains compiled extensions."
msgstr ""

#: ../source/tutorials/installing-packages.rst:387
msgid "If :ref:`pip` does not find a wheel to install, it will locally build a wheel and cache it for future installs, instead of rebuilding the source distribution in the future."
msgstr ""

#: ../source/tutorials/installing-packages.rst:395
msgid "Upgrade an already installed ``SomeProject`` to the latest from PyPI."
msgstr ""

#: ../source/tutorials/installing-packages.rst:412
msgid "Installing to the User Site"
msgstr ""

#: ../source/tutorials/installing-packages.rst:414
msgid "To install :term:`packages <Distribution Package>` that are isolated to the current user, use the ``--user`` flag:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:429
msgid "For more information see the `User Installs <https://pip.pypa.io/en/latest/user_guide/#user-installs>`_ section from the pip docs."
msgstr ""

#: ../source/tutorials/installing-packages.rst:433
msgid "Note that the ``--user`` flag has no effect when inside a virtual environment - all installation commands will affect the virtual environment."
msgstr ""

#: ../source/tutorials/installing-packages.rst:436
msgid "If ``SomeProject`` defines any command-line scripts or console entry points, ``--user`` will cause them to be installed inside the `user base`_'s binary directory, which may or may not already be present in your shell's :envvar:`PATH`.  (Starting in version 10, pip displays a warning when installing any scripts to a directory outside :envvar:`PATH`.)  If the scripts are not available in your shell after installation, you'll need to add the directory to your :envvar:`PATH`:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:444
msgid "On Linux and macOS you can find the user base binary directory by running ``python -m site --user-base`` and adding ``bin`` to the end. For example, this will typically print ``~/.local`` (with ``~`` expanded to the absolute path to your home directory) so you'll need to add ``~/.local/bin`` to your ``PATH``.  You can set your ``PATH`` permanently by `modifying ~/.profile`_."
msgstr ""

#: ../source/tutorials/installing-packages.rst:450
msgid "On Windows you can find the user base binary directory by running ``py -m site --user-site`` and replacing ``site-packages`` with ``Scripts``. For example, this could return ``C:\\Users\\Username\\AppData\\Roaming\\Python36\\site-packages`` so you would need to set your ``PATH`` to include ``C:\\Users\\Username\\AppData\\Roaming\\Python36\\Scripts``. You can set your user ``PATH`` permanently in the `Control Panel`_. You may need to log out for the ``PATH`` changes to take effect."
msgstr ""

#: ../source/tutorials/installing-packages.rst:466
msgid "Install a list of requirements specified in a :ref:`Requirements File <pip:Requirements Files>`."
msgstr ""

#: ../source/tutorials/installing-packages.rst:482
msgid "Installing from VCS"
msgstr ""

#: ../source/tutorials/installing-packages.rst:484
msgid "Install a project from VCS in \"editable\" mode.  For a full breakdown of the syntax, see pip's section on :ref:`VCS Support <pip:VCS Support>`."
msgstr ""

#: ../source/tutorials/installing-packages.rst:506
msgid "Installing from other Indexes"
msgstr ""

#: ../source/tutorials/installing-packages.rst:508
msgid "Install from an alternate index"
msgstr ""

#: ../source/tutorials/installing-packages.rst:522
msgid "Search an additional index during install, in addition to :term:`PyPI <Python Package Index (PyPI)>`"
msgstr ""

#: ../source/tutorials/installing-packages.rst:538
msgid "Installing from a local src tree"
msgstr ""

#: ../source/tutorials/installing-packages.rst:541
msgid "Installing from local src in :doc:`Development Mode <setuptools:userguide/development_mode>`, i.e. in such a way that the project appears to be installed, but yet is still editable from the src tree."
msgstr ""

#: ../source/tutorials/installing-packages.rst:558
msgid "You can also install normally from src"
msgstr ""

#: ../source/tutorials/installing-packages.rst:573
msgid "Installing from local archives"
msgstr ""

#: ../source/tutorials/installing-packages.rst:575
msgid "Install a particular source archive file."
msgstr ""

#: ../source/tutorials/installing-packages.rst:589
msgid "Install from a local directory containing archives (and don't check :term:`PyPI <Python Package Index (PyPI)>`)"
msgstr ""

#: ../source/tutorials/installing-packages.rst:609
msgid "Installing from other sources"
msgstr ""

#: ../source/tutorials/installing-packages.rst:611
msgid "To install from other data sources (for example Amazon S3 storage) you can create a helper application that presents the data in a format compliant with the :ref:`simple repository API <simple-repository-api>`:, and use the ``--extra-index-url`` flag to direct pip to use that index."
msgstr ""

#: ../source/tutorials/installing-packages.rst:623
msgid "Installing Prereleases"
msgstr ""

#: ../source/tutorials/installing-packages.rst:625
msgid "Find pre-release and development versions, in addition to stable versions.  By default, pip only finds stable versions."
msgstr ""

#: ../source/tutorials/installing-packages.rst:641
msgid "Installing \"Extras\""
msgstr ""

#: ../source/tutorials/installing-packages.rst:643
msgid "Extras are optional \"variants\" of a package, which may include additional dependencies, and thereby enable additional functionality from the package.  If you wish to install an extra for a package which you know publishes one, you can include it in the pip installation command:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:666
msgid "\"Secure\" in this context means using a modern browser or a tool like :command:`curl` that verifies SSL certificates when downloading from https URLs."
msgstr ""

#: ../source/tutorials/installing-packages.rst:675
msgid "Beginning with Python 3.4, ``venv`` (a stdlib alternative to :ref:`virtualenv`) will create virtualenv environments with ``pip`` pre-installed, thereby making it an equal alternative to :ref:`virtualenv`."
msgstr ""

#: ../source/tutorials/installing-packages.rst:680
msgid "The compatible release specifier was accepted in :pep:`440` and support was released in :ref:`setuptools` v8.0 and :ref:`pip` v6.0"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:4
msgid "Managing Application Dependencies"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:6
msgid "The :ref:`package installation tutorial <installing-packages>` covered the basics of getting set up to install and update Python packages."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:9
msgid "However, running these commands interactively can get tedious even for your own personal projects, and things get even more difficult when trying to set up development environments automatically for projects with multiple contributors."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:13
msgid "This tutorial walks you through the use of :ref:`Pipenv` to manage dependencies for an application. It will show you how to install and use the necessary tools and make strong recommendations on best practices."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:17
msgid "Keep in mind that Python is used for a great many different purposes, and precisely how you want to manage your dependencies may change based on how you decide to publish your software. The guidance presented here is most directly applicable to the development and deployment of network services (including web applications), but is also very well suited to managing development and testing environments for any kind of project."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:24
msgid "For alternatives, see `Other Tools for Application Dependency Management`_."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:27
msgid "Installing Pipenv"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:29
msgid ":ref:`Pipenv` is a dependency manager for Python projects. If you're familiar with Node.js' `npm`_ or Ruby's `bundler`_, it is similar in spirit to those tools. While :ref:`pip` alone is often sufficient for personal use, Pipenv is recommended for collaborative projects as it's a higher-level tool that simplifies dependency management for common use cases."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:35
msgid "Use ``pip`` to install Pipenv:"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:51
msgid "This does a `user installation`_ to prevent breaking any system-wide packages. If ``pipenv`` isn't available in your shell after installation, you'll need to add the :py:data:`user base <python:site.USER_BASE>`'s binary directory to your ``PATH``. See :ref:`Installing to the User Site` for more information."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:62
msgid "Installing packages for your project"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:64
msgid "Pipenv manages dependencies on a per-project basis. To install packages, change into your project's directory (or just an empty directory for this tutorial) and run:"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:73
msgid "Pipenv will install the `Requests`_ library and create a ``Pipfile`` for you in your project's directory. The :ref:`Pipfile` is used to track which dependencies your project needs in case you need to re-install them, such as when you share your project with others. You should get output similar to this (although the exact paths shown will vary):"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:109
msgid "Using installed packages"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:111
msgid "Now that Requests is installed you can create a simple :file:`main.py` file to use it:"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:122
msgid "Then you can run this script using ``pipenv run``:"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:128
msgid "You should get output similar to this:"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:134
msgid "Using ``pipenv run`` ensures that your installed packages are available to your script. It's also possible to spawn a new shell that ensures all commands have access to your installed packages with ``pipenv shell``."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:140
#: ../source/tutorials/packaging-projects.rst:504
msgid "Next steps"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:142
msgid "Congratulations, you now know how to effectively manage dependencies and development environments on a collaborative Python project! ✨ 🍰 ✨"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:145
msgid "If you're interested in creating and distributing your own Python packages, see the :ref:`tutorial on packaging and distributing packages <distributing-packages>`."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:148
msgid "Note that when your application includes definitions of Python source packages, they (and their dependencies) can be added to your ``pipenv`` environment with ``pipenv install -e <relative-path-to-source-directory>`` (e.g. ``pipenv install -e .`` or ``pipenv install -e src``)."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:157
msgid "Other Tools for Application Dependency Management"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:159
msgid "If you find this particular approach to managing application dependencies isn't working well for you or your use case, you may want to explore these other tools and techniques, listed in alphabetical order, to see if one of them is a better fit:"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:163
msgid "`hatch <https://github.com/pypa/hatch>`_ for opinionated coverage of even more steps in the project management workflow, such as incrementing versions and creating new skeleton projects from project templates."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:166
msgid "`micropipenv <https://github.com/thoth-station/micropipenv>`_ for a lightweight wrapper around pip that supports ``requirements.txt``, Pipenv and Poetry lock files, or converting them to pip-tools compatible output. Designed for containerized Python applications, but not limited to them."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:170
msgid "`PDM <https://github.com/pdm-project/pdm>`_ for a modern Python package management relying on standards such as :pep:`517` and :pep:`621`."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:172
msgid "`pip-tools <https://github.com/jazzband/pip-tools>`_ for creating a lock file of all dependencies from a list of packages directly used in a project, and ensuring that only those dependencies are installed."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:175
msgid "`Poetry <https://github.com/python-poetry/poetry>`__ for a tool comparable in scope to Pipenv that focuses more directly on use cases where the project being managed is structured as a distributable Python package with a valid ``pyproject.toml`` file. By contrast, Pipenv explicitly avoids making the assumption that the application being worked on will support distribution as a ``pip``-installable Python package."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:2
msgid "Packaging Python Projects"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:4
msgid "This tutorial walks you through how to package a simple Python project. It will show you how to add the necessary files and structure to create the package, how to build the package, and how to upload it to the Python Package Index (PyPI)."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:10
msgid "If you have trouble running the commands in this tutorial, please copy the command and its output, then `open an issue`_ on the `packaging-problems`_ repository on GitHub. We'll do our best to help you!"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:18
msgid "Some of the commands require a newer version of :ref:`pip`, so start by making sure you have the latest version installed:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:35
msgid "A simple project"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:37
msgid "This tutorial uses a simple project named ``example_package_YOUR_USERNAME_HERE``. If your username is ``me``, then the package would be ``example_package_me``; this ensures that you have a unique package name that doesn't conflict with packages uploaded by other people following this tutorial. We recommend following this tutorial as-is using this project, before packaging your own project."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:44
msgid "Create the following file structure locally:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:54
msgid "The directory containing the Python files should match the project name. This simplifies the configuration and is more obvious to users who install the package."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:57
msgid ":file:`__init__.py` is recommended to import the directory as a regular package, even if as is our case for this tutorial that file is empty [#namespace-packages]_."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:60
msgid ":file:`example.py` is an example of a module within the package that could contain the logic (functions, classes, constants, etc.) of your package. Open that file and enter the following content:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:69
msgid "If you are unfamiliar with Python's :term:`modules <Module>` and :term:`import packages <Import Package>`, take a few minutes to read over the `Python documentation for packages and modules`_."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:73
msgid "Once you create this structure, you'll want to run all of the commands in this tutorial within the ``packaging_tutorial`` directory."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:81
msgid "Creating the package files"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:83
msgid "You will now add files that are used to prepare the project for distribution. When you're done, the project structure will look like this:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:101
msgid "Creating a test directory"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:103
msgid ":file:`tests/` is a placeholder for test files. Leave it empty for now."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:109
msgid "Choosing a build backend"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:111
msgid "Tools like :ref:`pip` and :ref:`build` do not actually convert your sources into a :term:`distribution package <Distribution Package>` (like a wheel); that job is performed by a :term:`build backend <Build Backend>`. The build backend determines how your project will specify its configuration, including metadata (information about the project, for example, the name and tags that are displayed on PyPI) and input files. Build backends have different levels of functionality, such as whether they support building :term:`extension modules <Extension Module>`, and you should choose one that suits your needs and preferences."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:120
msgid "You can choose from a number of backends; this tutorial uses :ref:`Hatchling <hatch>` by default, but it will work identically with :ref:`setuptools`, :ref:`Flit <flit>`, :ref:`PDM <pdm>`, and others that support the ``[project]`` table for :ref:`metadata <configuring metadata>`."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:127
msgid "Some build backends are part of larger tools that provide a command-line interface with additional features like project initialization and version management, as well as building, uploading, and installing packages. This tutorial uses single-purpose tools that work independently."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:132
msgid "The :file:`pyproject.toml` tells :term:`build frontend <Build Frontend>` tools like :ref:`pip` and :ref:`build` which backend to use for your project. Below are some examples for common build backends, but check your backend's own documentation for more details."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:170
msgid "The ``requires`` key is a list of packages that are needed to build your package. The :term:`frontend <Build Frontend>` should install them automatically when building your package. Frontends usually run builds in isolated environments, so omitting dependencies here may cause build-time errors. This should always include your backend's package, and might have other build-time dependencies."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:177
msgid "The ``build-backend`` key is the name of the Python object that frontends will use to perform the build."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:180
msgid "Both of these values will be provided by the documentation for your build backend, or generated by its command line interface. There should be no need for you to customize these settings."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:184
msgid "Additional configuration of the build tool will either be in a ``tool`` section of the ``pyproject.toml``, or in a special file defined by the build tool. For example, when using ``setuptools`` as your build backend, additional configuration may be added to a ``setup.py`` or ``setup.cfg`` file, and specifying ``setuptools.build_meta`` in your build allows the tools to locate and use these automatically."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:194
msgid "Configuring metadata"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:196
msgid "Open :file:`pyproject.toml` and enter the following content. Change the ``name`` to include your username; this ensures that you have a unique package name that doesn't conflict with packages uploaded by other people following this tutorial."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:222
msgid "``name`` is the *distribution name* of your package. This can be any name as long as it only contains letters, numbers, ``.``, ``_`` , and ``-``. It also must not already be taken on PyPI. **Be sure to update this with your username** for this tutorial, as this ensures you won't try to upload a package with the same name as one which already exists."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:227
msgid "``version`` is the package version. (Some build backends allow it to be specified another way, such as from a file or Git tag.)"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:229
msgid "``authors`` is used to identify the author of the package; you specify a name and an email for each author. You can also list ``maintainers`` in the same format."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:232
msgid "``description`` is a short, one-sentence summary of the package."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:233
msgid "``readme`` is a path to a file containing a detailed description of the package. This is shown on the package detail page on PyPI. In this case, the description is loaded from :file:`README.md` (which is a common pattern). There also is a more advanced table form described in the :ref:`pyproject.toml guide <writing-pyproject-toml>`."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:238
msgid "``requires-python`` gives the versions of Python supported by your project. An installer like :ref:`pip` will look back through older versions of packages until it finds one that has a matching Python version."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:241
msgid "``classifiers`` gives the index and :ref:`pip` some additional metadata about your package. In this case, the package is only compatible with Python 3, is licensed under the MIT license, and is OS-independent. You should always include at least which version(s) of Python your package works on, which license your package is available under, and which operating systems your package will work on. For a complete list of classifiers, see https://pypi.org/classifiers/."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:248
msgid "``urls`` lets you list any number of extra links to show on PyPI. Generally this could be to the source, documentation, issue trackers, etc."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:251
msgid "See the :ref:`pyproject.toml guide <writing-pyproject-toml>` for details on these and other fields that can be defined in the ``[project]`` table. Other common fields are ``keywords`` to improve discoverability and the ``dependencies`` that are required to install your package."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:258
msgid "Creating README.md"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:260
msgid "Open :file:`README.md` and enter the following content. You can customize this if you'd like."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:273
msgid "Creating a LICENSE"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:275
msgid "It's important for every package uploaded to the Python Package Index to include a license. This tells users who install your package the terms under which they can use your package. For help picking a license, see https://choosealicense.com/. Once you have chosen a license, open :file:`LICENSE` and enter the license text. For example, if you had chosen the MIT license:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:304
msgid "Most build backends automatically include license files in packages. See your backend's documentation for more details."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:309
msgid "Including other files"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:311
msgid "The files listed above will be included automatically in your :term:`source distribution <Source Distribution (or \"sdist\")>`. If you want to include additional files, see the documentation for your build backend."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:318
msgid "Generating distribution archives"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:320
msgid "The next step is to generate :term:`distribution packages <Distribution Package>` for the package. These are archives that are uploaded to the Python Package Index and can be installed by :ref:`pip`."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:324
msgid "Make sure you have the latest version of PyPA's :ref:`build` installed:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:338
msgid "If you have trouble installing these, see the :doc:`installing-packages` tutorial."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:341
msgid "Now run this command from the same directory where :file:`pyproject.toml` is located:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:355
msgid "This command should output a lot of text and once completed should generate two files in the :file:`dist` directory:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:365
msgid "The ``tar.gz`` file is a :term:`source distribution <Source Distribution (or \"sdist\")>` whereas the ``.whl`` file is a :term:`built distribution <Built Distribution>`. Newer :ref:`pip` versions preferentially install built distributions, but will fall back to source distributions if needed. You should always upload a source distribution and provide built distributions for the platforms your project is compatible with. In this case, our example package is compatible with Python on any platform so only one built distribution is needed."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:374
msgid "Uploading the distribution archives"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:376
msgid "Finally, it's time to upload your package to the Python Package Index!"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:378
msgid "The first thing you'll need to do is register an account on TestPyPI, which is a separate instance of the package index intended for testing and experimentation. It's great for things like this tutorial where we don't necessarily want to upload to the real index. To register an account, go to https://test.pypi.org/account/register/ and complete the steps on that page. You will also need to verify your email address before you're able to upload any packages.  For more details, see :doc:`/guides/using-testpypi`."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:386
msgid "To securely upload your project, you'll need a PyPI `API token`_. Create one at https://test.pypi.org/manage/account/#api-tokens, setting the \"Scope\" to \"Entire account\". **Don't close the page until you have copied and saved the token — you won't see that token again.**"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:393
msgid "Now that you are registered, you can use :ref:`twine` to upload the distribution packages. You'll need to install Twine:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:408
msgid "Once installed, run Twine to upload all of the archives under :file:`dist`:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:422
msgid "You will be prompted for a username and password. For the username, use ``__token__``. For the password, use the token value, including the ``pypi-`` prefix."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:426
msgid "After the command completes, you should see output similar to this:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:437
msgid "Once uploaded, your package should be viewable on TestPyPI; for example: ``https://test.pypi.org/project/example_package_YOUR_USERNAME_HERE``."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:442
msgid "Installing your newly uploaded package"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:444
msgid "You can use :ref:`pip` to install your package and verify that it works. Create a :ref:`virtual environment <Creating and using Virtual Environments>` and install your package from TestPyPI:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:460
msgid "Make sure to specify your username in the package name!"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:462
msgid "pip should install the package from TestPyPI and the output should look something like this:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:472
msgid "This example uses ``--index-url`` flag to specify TestPyPI instead of live PyPI. Additionally, it specifies ``--no-deps``. Since TestPyPI doesn't have the same packages as the live PyPI, it's possible that attempting to install dependencies may fail or install something unexpected. While our example package doesn't have any dependencies, it's a good practice to avoid installing dependencies when using TestPyPI."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:479
msgid "You can test that it was installed correctly by importing the package. Make sure you're still in your virtual environment, then run Python:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:494
msgid "and import the package:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:506
msgid "**Congratulations, you've packaged and distributed a Python project!** ✨ 🍰 ✨"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:509
msgid "Keep in mind that this tutorial showed you how to upload your package to Test PyPI, which isn't a permanent storage. The Test system occasionally deletes packages and accounts. It is best to use TestPyPI for testing and experiments like this tutorial."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:514
msgid "When you are ready to upload a real package to the Python Package Index you can do much the same as you did in this tutorial, but with these important differences:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:518
msgid "Choose a memorable and unique name for your package. You don't have to append your username as you did in the tutorial, but you can't use an existing name."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:520
msgid "Register an account on https://pypi.org - note that these are two separate servers and the login details from the test server are not shared with the main server."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:523
msgid "Use ``twine upload dist/*`` to upload your package and enter your credentials for the account you registered on the real PyPI.  Now that you're uploading the package in production, you don't need to specify ``--repository``; the package will upload to https://pypi.org/ by default."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:527
msgid "Install your package from the real PyPI using ``python3 -m pip install [your-package]``."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:529
msgid "At this point if you want to read more on packaging Python libraries here are some things you can do:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:535
msgid "Consider packaging tools that provide a single command-line interface for project management and packaging, such as :ref:`hatch`, :ref:`flit`, :ref:`pdm`, and :ref:`poetry`."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:538
msgid "Read :pep:`517` and :pep:`518` for background and details on build tool configuration."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:539
msgid "Read about :doc:`/guides/packaging-binary-extensions`."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:545
msgid "Notes"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:547
msgid "Technically, you can also create Python packages without an ``__init__.py`` file, but those are called :doc:`namespace packages </guides/packaging-namespace-packages>` and considered an **advanced topic** (not covered in this tutorial). If you are only getting started with Python packaging, it is recommended to stick with *regular packages* and ``__init__.py`` (even if the file is empty)."
msgstr ""
